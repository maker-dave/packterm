#!/usr/bin/env python3
# terminal_client.py
# Chunk 1 v3.3 - Imports and Config - Updated 2025-03-13  # CHANGE v3.3: Updated form UI, enhanced nav/logging, packet-only Comms Log

import time
import random
import sys
import os
import curses
import socket
import traceback
import textwrap
import glob
import shutil
import hashlib
import threading
import configparser
import pandas as pd
import queue
from tabulate import tabulate

INSTALL_DIR = os.path.dirname(os.path.realpath(__file__))
CONFIG_FILE = os.path.join(INSTALL_DIR, "terminal_client.conf")
CALLSIGN = None
COMM_MODE = 'TCP'
ROWS, COLS = 24, 80
TX_WINDOW = 10
SERVER_HOST = 'pi4.lan'
SERVER_PORT = 12345
AGW_HOST = '127.0.0.1'
AGW_PORT = 8000
LOG_FILE = os.path.join(INSTALL_DIR, "skippys_messups.log")
FORMS_DIR = os.path.join(INSTALL_DIR, "forms")
BACKUP_DIR = os.path.join(INSTALL_DIR, "backups")
MAX_RETRIES = 5
RETRY_DELAY = 5  # seconds

PACLEN = 255  # Increased from 128 in v3.01 to fit UPDATE packets

VERSION = "3.2"  # CHANGE v3.2: Bumped from 3.1 for updated UI, nav, and logging

config = configparser.ConfigParser()
if not os.path.exists(CONFIG_FILE):
    config['Settings'] = {
        'callsign': 'CLT001',
        'comm_mode': 'TCP',
        'paclen': str(PACLEN),
        'log_callsign_prompt': 'True',
        'log_connectivity': 'True',
        'log_debug': 'True',
        'log_comm_details': 'False',
        'log_form_updates': 'False',
        'log_submission': 'True',
        'log_ui_state': 'False',  # CHANGE v3.2: Off to reduce spam
        'log_packet_details': 'False',
        'log_segment_status': 'True',
        'log_submission_details': 'True',
        'log_submission_payload': 'True',
        'log_segment_failure': 'True',
        'log_socket_state': 'True',
        'log_retries': 'True',
        'log_ui_transitions': 'False',  # CHANGE v3.2: Off to reduce spam
        'log_ack_processing': 'True',
        'log_send_state': 'True',
        'log_listener_state': 'True',
        'log_search_query': 'True',
        'log_search_results': 'True',
        'log_screen_state': 'True',
        'log_field_state': 'False',  # CHANGE v3.2: Off to reduce spam
        'log_submission_flow': 'True',
        'log_debug_forms': 'False',
        'log_debug_sync': 'True',
        'log_cursor_movement': 'False',
        'log_packet_timing': 'False',
        'log_error_details': 'True',
        'log_packet_build': 'True',
        'log_packet_parse': 'False',
        'log_sync_state': 'True',
        'log_sync_md5': 'False',
        'log_sync_forms': 'False',
        'log_sync_packets': 'True',
        'log_packet_integrity': 'True',
        'log_listener_retries': 'True',
        'log_socket_reset': 'True',
        'log_connection_success': 'True',
        'log_packet_fragments': 'True',
        'log_sync_mismatches': 'True',
        'log_redraw_triggers': 'False',  # CHANGE v3.2: Off to reduce spam
        'log_form_deletion': 'True',
        'log_sync_start': 'True',
        'log_sync_completion': 'True',
        'log_form_exit': 'True',
        'log_key_context': 'True',
        'log_mode_switch': 'True',
        'log_packet_queue': 'True',
        'log_listener_queue': 'True',
        'log_ui_packet_handling': 'True',
        'log_queue_state': 'True',
        'log_connection_attempts': 'True',
        'log_packet_drop': 'True',
        'log_thread_state': 'True',
        'log_column_navigation': 'True',
        'log_form_layout': 'True',
        'log_row_movement': 'True',
        'log_form_display_error': 'True',  # CHANGE v3.2: Added for UI troubleshooting
        'log_ui_render': 'True',           # CHANGE v3.2: Added for UI rendering issues
        'log_socket_errors': 'True'        # CHANGE v3.2: Added for connectivity debugging
    }
    os.makedirs(INSTALL_DIR, exist_ok=True)
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)
config.read(CONFIG_FILE)
CALLSIGN = config.get('Settings', 'callsign', fallback='CLT001')
COMM_MODE = config.get('Settings', 'comm_mode', fallback=COMM_MODE)
PACLEN = config.getint('Settings', 'paclen', fallback=PACLEN)
LOG_CALLSIGN_PROMPT = config.getboolean('Settings', 'log_callsign_prompt', fallback=True)
LOG_CONNECTIVITY = config.getboolean('Settings', 'log_connectivity', fallback=True)
LOG_DEBUG = config.getboolean('Settings', 'log_debug', fallback=True)
LOG_COMM_DETAILS = config.getboolean('Settings', 'log_comm_details', fallback=False)
LOG_FORM_UPDATES = config.getboolean('Settings', 'log_form_updates', fallback=False)
LOG_SUBMISSION = config.getboolean('Settings', 'log_submission', fallback=True)
LOG_UI_STATE = config.getboolean('Settings', 'log_ui_state', fallback=False)
LOG_PACKET_DETAILS = config.getboolean('Settings', 'log_packet_details', fallback=False)
LOG_SEGMENT_STATUS = config.getboolean('Settings', 'log_segment_status', fallback=True)
LOG_SUBMISSION_DETAILS = config.getboolean('Settings', 'log_submission_details', fallback=True)
LOG_SUBMISSION_PAYLOAD = config.getboolean('Settings', 'log_submission_payload', fallback=True)
LOG_SEGMENT_FAILURE = config.getboolean('Settings', 'log_segment_failure', fallback=True)
LOG_SOCKET_STATE = config.getboolean('Settings', 'log_socket_state', fallback=True)
LOG_RETRIES = config.getboolean('Settings', 'log_retries', fallback=True)
LOG_UI_TRANSITIONS = config.getboolean('Settings', 'log_ui_transitions', fallback=False)
LOG_ACK_PROCESSING = config.getboolean('Settings', 'log_ack_processing', fallback=True)
LOG_SEND_STATE = config.getboolean('Settings', 'log_send_state', fallback=True)
LOG_LISTENER_STATE = config.getboolean('Settings', 'log_listener_state', fallback=True)
LOG_SEARCH_QUERY = config.getboolean('Settings', 'log_search_query', fallback=True)
LOG_SEARCH_RESULTS = config.getboolean('Settings', 'log_search_results', fallback=True)
LOG_SCREEN_STATE = config.getboolean('Settings', 'log_screen_state', fallback=True)
LOG_FIELD_STATE = config.getboolean('Settings', 'log_field_state', fallback=False)
LOG_SUBMISSION_FLOW = config.getboolean('Settings', 'log_submission_flow', fallback=True)
LOG_DEBUG_FORMS = config.getboolean('Settings', 'log_debug_forms', fallback=False)
LOG_DEBUG_SYNC = config.getboolean('Settings', 'log_debug_sync', fallback=True)
LOG_CURSOR_MOVEMENT = config.getboolean('Settings', 'log_cursor_movement', fallback=False)
LOG_PACKET_TIMING = config.getboolean('Settings', 'log_packet_timing', fallback=False)
LOG_ERROR_DETAILS = config.getboolean('Settings', 'log_error_details', fallback=True)
LOG_PACKET_BUILD = config.getboolean('Settings', 'log_packet_build', fallback=True)
LOG_PACKET_PARSE = config.getboolean('Settings', 'log_packet_parse', fallback=False)
LOG_SYNC_STATE = config.getboolean('Settings', 'log_sync_state', fallback=True)
LOG_SYNC_MD5 = config.getboolean('Settings', 'log_sync_md5', fallback=False)
LOG_SYNC_FORMS = config.getboolean('Settings', 'log_sync_forms', fallback=False)
LOG_SYNC_PACKETS = config.getboolean('Settings', 'log_sync_packets', fallback=True)
LOG_PACKET_INTEGRITY = config.getboolean('Settings', 'log_packet_integrity', fallback=True)
LOG_LISTENER_RETRIES = config.getboolean('Settings', 'log_listener_retries', fallback=True)
LOG_SOCKET_RESET = config.getboolean('Settings', 'log_socket_reset', fallback=True)
LOG_CONNECTION_SUCCESS = config.getboolean('Settings', 'log_connection_success', fallback=True)
LOG_PACKET_FRAGMENTS = config.getboolean('Settings', 'log_packet_fragments', fallback=True)
LOG_SYNC_MISMATCHES = config.getboolean('Settings', 'log_sync_mismatches', fallback=True)
LOG_REDRAW_TRIGGERS = config.getboolean('Settings', 'log_redraw_triggers', fallback=False)
LOG_FORM_DELETION = config.getboolean('Settings', 'log_form_deletion', fallback=True)
LOG_SYNC_START = config.getboolean('Settings', 'log_sync_start', fallback=True)
LOG_SYNC_COMPLETION = config.getboolean('Settings', 'log_sync_completion', fallback=True)
LOG_FORM_EXIT = config.getboolean('Settings', 'log_form_exit', fallback=True)
LOG_KEY_CONTEXT = config.getboolean('Settings', 'log_key_context', fallback=True)
LOG_MODE_SWITCH = config.getboolean('Settings', 'log_mode_switch', fallback=True)
LOG_PACKET_QUEUE = config.getboolean('Settings', 'log_packet_queue', fallback=True)
LOG_LISTENER_QUEUE = config.getboolean('Settings', 'log_listener_queue', fallback=True)
LOG_UI_PACKET_HANDLING = config.getboolean('Settings', 'log_ui_packet_handling', fallback=True)
LOG_QUEUE_STATE = config.getboolean('Settings', 'log_queue_state', fallback=True)
LOG_CONNECTION_ATTEMPTS = config.getboolean('Settings', 'log_connection_attempts', fallback=True)
LOG_PACKET_DROP = config.getboolean('Settings', 'log_packet_drop', fallback=True)
LOG_THREAD_STATE = config.getboolean('Settings', 'log_thread_state', fallback=True)
LOG_COLUMN_NAVIGATION = config.getboolean('Settings', 'log_column_navigation', fallback=True)
LOG_FORM_LAYOUT = config.getboolean('Settings', 'log_form_layout', fallback=True)
LOG_ROW_MOVEMENT = config.getboolean('Settings', 'log_row_movement', fallback=True)
LOG_FORM_DISPLAY_ERROR = config.getboolean('Settings', 'log_form_display_error', fallback=True)
LOG_UI_RENDER = config.getboolean('Settings', 'log_ui_render', fallback=True)          # CHANGE v3.2: Added
LOG_SOCKET_ERRORS = config.getboolean('Settings', 'log_socket_errors', fallback=True)  # CHANGE v3.2: Added

# Chunk 2 v3.2 - Global State (unchanged)
cursor_row, cursor_col = None, None
form_fields = {}
field_values = {}
cursor_offset = 0
current_field = None
comms_log = []
debug_log = []
screen_dirty = True
form_id = None
selecting_mode = False
show_menu = False
menu_selection = 0
mode = None
messages = []
unread_messages = False
listener_socket = None
last_no_data = 0
sending = False
submission_result = None
syncing = False
packet_queue = queue.Queue(maxsize=100)

# Chunk 3 v3.2 - Utility Functions
def log_event(message, ui=False, debug=False, submission=False, ui_state=False, packet=False, segment=False, submission_details=False, payload=False, segment_failure=False, socket_state=False, retries=False, ui_transitions=False, ack_processing=False, send_state=False, listener_state=False, search_query=False, search_results=False, screen_state=False, field_state=False, submission_flow=False, cursor_movement=False, packet_timing=False, error_details=False, packet_build=False, packet_parse=False, sync_state=False, sync_md5=False, sync_forms=False, sync_packets=False, packet_integrity=False, listener_retries=False, socket_reset=False, connection_success=False, packet_fragments=False, sync_mismatches=False, redraw_triggers=False, form_deletion=False, sync_start=False, sync_completion=False, form_exit=False, key_context=False, mode_switch=False, packet_queue=False, listener_queue=False, ui_packet_handling=False, queue_state=False, connection_attempts=False, packet_drop=False, thread_state=False, column_navigation=False, form_layout=False, row_movement=False, form_display_error=False, ui_render=False, socket_errors=False):  # CHANGE v3.2: Added ui_render, socket_errors
    global screen_dirty
    timestamp = time.ctime()
    log_line = f"{timestamp}: {message}"
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    with open(LOG_FILE, 'a') as f:
        f.write(log_line + '\n')
    # Only raw packets go to Comms Log via log_comms
    if ui:
        comms_log.append((message, timestamp))
        if len(comms_log) > 20:
            comms_log.pop(0)
        screen_dirty = True
        if LOG_REDRAW_TRIGGERS:
            log_event("screen_dirty set by log_event (UI log)", redraw_triggers=True)
    if debug and LOG_DEBUG: debug_log.append((message, timestamp))
    if submission and LOG_SUBMISSION: debug_log.append((message, timestamp))
    if ui_state and LOG_UI_STATE: debug_log.append((message, timestamp))
    if packet and LOG_PACKET_DETAILS: debug_log.append((message, timestamp))
    if segment and LOG_SEGMENT_STATUS: debug_log.append((message, timestamp))
    if submission_details and LOG_SUBMISSION_DETAILS: debug_log.append((message, timestamp))
    if payload and LOG_SUBMISSION_PAYLOAD: debug_log.append((message, timestamp))
    if segment_failure and LOG_SEGMENT_FAILURE: debug_log.append((message, timestamp))
    if socket_state and LOG_SOCKET_STATE: debug_log.append((message, timestamp))
    if retries and LOG_RETRIES: debug_log.append((message, timestamp))
    if ui_transitions and LOG_UI_TRANSITIONS: debug_log.append((message, timestamp))
    if ack_processing and LOG_ACK_PROCESSING: debug_log.append((message, timestamp))
    if send_state and LOG_SEND_STATE: debug_log.append((message, timestamp))
    if listener_state and LOG_LISTENER_STATE: debug_log.append((message, timestamp))
    if search_query and LOG_SEARCH_QUERY: debug_log.append((message, timestamp))
    if search_results and LOG_SEARCH_RESULTS: debug_log.append((message, timestamp))
    if screen_state and LOG_SCREEN_STATE: debug_log.append((message, timestamp))
    if field_state and LOG_FIELD_STATE: debug_log.append((message, timestamp))
    if submission_flow and LOG_SUBMISSION_FLOW: debug_log.append((message, timestamp))
    if cursor_movement and LOG_CURSOR_MOVEMENT: debug_log.append((message, timestamp))
    if packet_timing and LOG_PACKET_TIMING: debug_log.append((message, timestamp))
    if error_details and LOG_ERROR_DETAILS: debug_log.append((message, timestamp))
    if packet_build and LOG_PACKET_BUILD: debug_log.append((message, timestamp))
    if packet_parse and LOG_PACKET_PARSE: debug_log.append((message, timestamp))
    if sync_state and LOG_SYNC_STATE: debug_log.append((message, timestamp))
    if sync_md5 and LOG_SYNC_MD5: debug_log.append((message, timestamp))
    if sync_forms and LOG_SYNC_FORMS: debug_log.append((message, timestamp))
    if sync_packets and LOG_SYNC_PACKETS: debug_log.append((message, timestamp))
    if packet_integrity and LOG_PACKET_INTEGRITY: debug_log.append((message, timestamp))
    if listener_retries and LOG_LISTENER_RETRIES: debug_log.append((message, timestamp))
    if socket_reset and LOG_SOCKET_RESET: debug_log.append((message, timestamp))
    if connection_success and LOG_CONNECTION_SUCCESS: debug_log.append((message, timestamp))
    if packet_fragments and LOG_PACKET_FRAGMENTS: debug_log.append((message, timestamp))
    if sync_mismatches and LOG_SYNC_MISMATCHES: debug_log.append((message, timestamp))
    if redraw_triggers and LOG_REDRAW_TRIGGERS: debug_log.append((message, timestamp))
    if form_deletion and LOG_FORM_DELETION: debug_log.append((message, timestamp))
    if sync_start and LOG_SYNC_START: debug_log.append((message, timestamp))
    if sync_completion and LOG_SYNC_COMPLETION: debug_log.append((message, timestamp))
    if form_exit and LOG_FORM_EXIT: debug_log.append((message, timestamp))
    if key_context and LOG_KEY_CONTEXT: debug_log.append((message, timestamp))
    if mode_switch and LOG_MODE_SWITCH: debug_log.append((message, timestamp))
    if packet_queue and LOG_PACKET_QUEUE: debug_log.append((message, timestamp))
    if listener_queue and LOG_LISTENER_QUEUE: debug_log.append((message, timestamp))
    if ui_packet_handling and LOG_UI_PACKET_HANDLING: debug_log.append((message, timestamp))
    if queue_state and LOG_QUEUE_STATE: debug_log.append((message, timestamp))
    if connection_attempts and LOG_CONNECTION_ATTEMPTS: debug_log.append((message, timestamp))
    if packet_drop and LOG_PACKET_DROP: debug_log.append((message, timestamp))
    if thread_state and LOG_THREAD_STATE: debug_log.append((message, timestamp))
    if column_navigation and LOG_COLUMN_NAVIGATION: debug_log.append((message, timestamp))
    if form_layout and LOG_FORM_LAYOUT: debug_log.append((message, timestamp))
    if row_movement and LOG_ROW_MOVEMENT: debug_log.append((message, timestamp))
    if form_display_error and LOG_FORM_DISPLAY_ERROR: debug_log.append((message, timestamp))
    if ui_render and LOG_UI_RENDER: debug_log.append((message, timestamp))  # CHANGE v3.2: Added
    if socket_errors and LOG_SOCKET_ERRORS: debug_log.append((message, timestamp))  # CHANGE v3.2: Added

def log_comms(message):
    # CHANGE v3.2: Updated to log only raw over-the-air packets to Comms Log
    log_event(message, ui=True)

def backup_script():
    script_path = os.path.realpath(__file__)
    base_name = os.path.basename(script_path)
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_name = f"{base_name.rsplit('.', 1)[0]}_{timestamp}.{base_name.rsplit('.', 1)[1]}"
    backup_path = os.path.join(BACKUP_DIR, backup_name)
    try:
        shutil.copy2(script_path, backup_path)
        log_event(f"Backed up to {backup_path}", ui=False)  # Always on, debug only
    except PermissionError as e:
        log_event(f"Backup failed: {str(e)} - proceeding without backup", ui=False, error_details=True)

def init_colors():
    log_event("Initializing colors", debug=True)
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)
    return 1, 2, 3, 4

def get_callsign():
    global CALLSIGN
    CALLSIGN = config.get('Settings', 'callsign', fallback='CLT001')
    while not CALLSIGN:
        if LOG_CALLSIGN_PROMPT:
            log_event("Prompting for callsign", ui=False)  # Debug only
        print("Enter Your Callsign (e.g., KB8XYZ, required): ", end='', flush=True)
        CALLSIGN = input().strip().upper()
        if not CALLSIGN:
            print("Callsign cannot be empty—try again")
            time.sleep(1)
        else:
            config['Settings']['callsign'] = CALLSIGN
            with open(CONFIG_FILE, 'w') as configfile:
                config.write(configfile)
            log_event(f"Callsign set to {CALLSIGN}", ui=False)  # Debug only
    return CALLSIGN

def load_form_data(form_id):
    file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
    if not os.path.exists(file_path):
        log_event(f"Form file not found: {file_path}", debug=True)
        return None
    form_data = {'desc': '', 'fields': {}}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('desc:'):
                form_data['desc'] = line.split(':', 1)[1]
            elif ',' in line and len(line.split(',')) == 5:
                fid, label, row, col, length = line.split(',')
                form_data['fields'][fid] = {
                    'label': label,
                    'row': int(row),
                    'col': int(col),
                    'len': int(length)
                }
            else:
                log_event(f"Invalid line in {form_id}.txt: {line}", debug=True)
    if LOG_FORM_LAYOUT:
        log_event(f"Loaded form {form_id}: {form_data['fields']}", form_layout=True)
    return form_data

def update_form_lengths():
    if not os.path.exists(FORMS_DIR) or not os.listdir(FORMS_DIR):
        log_event("No forms yet—awaiting server", debug=True)
        return
    log_event("TEMPORARY: Starting form length update to 256", debug=True)
    for form_file in os.listdir(FORMS_DIR):
        if form_file.endswith('.txt'):
            file_path = os.path.join(FORMS_DIR, form_file)
            lines = []
            with open(file_path, 'r') as f:
                for line in f:
                    if line.startswith('desc:'):
                        lines.append(line.strip())
                    elif ',' in line and len(line.split(',')) == 5:
                        fid, label, row, col, _ = line.strip().split(',')
                        lines.append(f"{fid},{label},{row},{col},256")
                    else:
                        log_event(f"Skipping invalid line in {form_file}: {line.strip()}", debug=True)
            with open(file_path, 'w') as f:
                f.write('\n'.join(lines) + '\n')
            if LOG_DEBUG_FORMS:
                log_event(f"TEMPORARY: Updated {form_file} fields to len=256", debug=True)
    log_event("TEMPORARY: Form length update complete", debug=True)

def hash_forms_dir():
    hasher = hashlib.md5()
    if os.path.exists(FORMS_DIR):
        for filename in sorted(glob.glob(os.path.join(FORMS_DIR, '*.txt'))):
            with open(filename, 'rb') as f:
                content = f.read()
                hasher.update(content)
            if LOG_SYNC_FORMS:
                with open(filename, 'r') as f:
                    log_event(f"Hashing {filename}: {f.read()[:50]}", sync_forms=True)
    forms_data = hasher.digest()
    md5_hash = hasher.hexdigest()
    if LOG_SYNC_MD5:
        log_event(f"Forms data before hash (length): {len(forms_data)}", sync_md5=True)
        log_event(f"Computed client MD5: {md5_hash}", sync_md5=True)
    return md5_hash

def build_forms_index():
    index_parts = []
    if os.path.exists(FORMS_DIR):
        for fname in sorted(os.listdir(FORMS_DIR)):
            if fname.endswith('.txt'):
                file_path = os.path.join(FORMS_DIR, fname)
                with open(file_path, 'r') as f:
                    content = f.read()
                    md5 = hashlib.md5(content.strip().encode()).hexdigest()
                index_parts.append(f"{fname[:-4]}:{md5}")
                if LOG_SYNC_FORMS:
                    log_event(f"Indexed {fname[:-4]} with MD5: {md5}", sync_forms=True)
    index = "|".join(index_parts)
    if LOG_SYNC_PACKETS:
        log_event(f"Built forms index: {index}", sync_packets=True)
    return index

if os.path.exists(LOG_FILE):
    os.remove(LOG_FILE)
    log_event("Deleted old log file", ui=False)  # Debug only
backup_script()
CALLSIGN = get_callsign()

# Chunk 4 v3.4 - Core Display Functions
def move_cursor(stdscr, row, col):
    global cursor_row, cursor_col, screen_dirty
    cursor_row, cursor_col = min(max(row, 0), ROWS-1), min(max(col, 0), COLS-1)
    screen_dirty = True
    if LOG_REDRAW_TRIGGERS:
        log_event("screen_dirty set by move_cursor", redraw_triggers=True)
    redraw_screen(stdscr)

def redraw_screen(stdscr, sending=False):
    # CHANGE v3.4: Fixed col 80 overflow (80→79), cols 13-48/49-79 (36/31 chars), packet-only Comms Log
    global screen_dirty, form_id, selecting_mode, form_fields, current_field, show_menu, menu_selection, cursor_offset, unread_messages, mode, submission_result
    if not screen_dirty:
        return
    stdscr.erase()
    stdscr.clear()
    RED, GREEN, YELLOW, LIGHT_BLUE = 1, 2, 3, 4
    border = "=" * (COLS - 2)
    max_y, max_x = stdscr.getmaxyx()
    stdscr.addstr(0, 0, border, curses.color_pair(RED))
    if form_fields and any(form_fields) and mode in ('I', 'S'):
        max_form_row = 18
        form_id_display = form_fields.get(next(iter(form_fields), None), {}).get('form_id', '')
        form_data = load_form_data(form_id_display)
        stdscr.addstr(1, 2, f"{'Insert' if mode == 'I' else 'Search'} Form: {form_data['desc'].split('~')[0][:COLS-14]}" if form_data else '', curses.color_pair(GREEN))
        # Two-column display: Left 13-48 (36 chars), Right 49-79 (31 chars)
        sorted_fields = sorted(form_fields.keys(), key=lambda x: (form_fields[x]['row'], form_fields[x]['col']))
        for fid in sorted_fields:
            info = form_fields[fid]
            label = info['label']
            text = field_values.get(fid, '')
            color = YELLOW if fid == current_field else GREEN
            col = 13 if fid.startswith('L') else 49
            max_len = 34 if col == 13 else 29  # CHANGE v3.4: 30→29
            try:
                # [label                    ] format
                stdscr.addstr(info['row'], col, "[", curses.color_pair(GREEN))
                stdscr.addstr(info['row'], col + 1, f"{label[:max_len]}".ljust(max_len), curses.color_pair(color))
                stdscr.addstr(info['row'], col + max_len + 1, "]", curses.color_pair(GREEN))  # CHANGE v3.4: 80→79 for right col
                if fid == current_field and current_field not in ('submit', 'cancel'):
                    cursor_x = col + 1 + min(cursor_offset, max_len)
                    if info['row'] < max_form_row and cursor_x < (48 if col == 13 else 79):
                        stdscr.addstr(info['row'], cursor_x, '■', curses.color_pair(YELLOW))
            except Exception as e:
                if LOG_FORM_DISPLAY_ERROR:
                    log_event(f"Display error for {fid} at row {info['row']}, col {col}: {str(e)}", form_display_error=True)
        # Submit/Cancel at bottom
        stdscr.addstr(19, 13, "[Submit                  ]", curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(19, 49, "[Cancel                ]", curses.color_pair(LIGHT_BLUE))
        if current_field == 'submit':
            stdscr.addstr(19, 19, '■', curses.color_pair(LIGHT_BLUE))
        elif current_field == 'cancel':
            stdscr.addstr(19, 55, '■', curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(21, 2, "= Enter=Next Esc=Back Up/Down=Row Left/Right=Col =", curses.color_pair(GREEN))
        if sending:
            msg = "Sending. Please wait."
            y = max_y // 2
            x = (max_x - len(msg)) // 2
            stdscr.addstr(y, x, msg, curses.color_pair(YELLOW) | curses.A_BOLD)
    elif selecting_mode and form_id:
        stdscr.addstr(1, 2, f"Selected {form_id}", curses.color_pair(GREEN))
        stdscr.addstr(2, 2, "S=Search, I=Insert", curses.color_pair(GREEN))
        stdscr.addstr(21, 2, "= Commands: S=Search I=Insert Esc=Back =", curses.color_pair(GREEN))
    elif show_menu and menu_selection == 3:
        stdscr.addstr(1, 2, "Messages", curses.color_pair(GREEN))
        line = 3
        for msg in messages[-18:]:
            if line < 19:
                prefix, from_call, text = msg.split(':', 2)
                if prefix == 'MSG':
                    _, to_call = from_call, text.split(':', 1)[0]
                    text = text.split(':', 1)[1]
                    if to_call == CALLSIGN:
                        stdscr.addstr(line, 2, f"{from_call} -> {text[:40]}", curses.color_pair(GREEN))
                elif prefix == 'CHAT':
                    stdscr.addstr(line, 2, f"{from_call}: {text[:40]}", curses.color_pair(GREEN))
                line += 1
        stdscr.addstr(21, 2, "= Commands: Esc=Back =", curses.color_pair(GREEN))
        unread_messages = False
    else:
        stdscr.addstr(1, 2, f"Callsign: {CALLSIGN}", curses.color_pair(GREEN))
        form_files = set(f[:-4] for f in os.listdir(FORMS_DIR) if f.endswith('.txt'))
        form_list = sorted(form_files)
        form_count = len(form_list)
        stdscr.addstr(2, 2, "Select a form:" + (" *" if unread_messages else ""), curses.color_pair(GREEN))
        for i, local_form_id in enumerate(form_list[:15], 1):
            form_data = load_form_data(local_form_id)
            desc = form_data['desc'].split('~')[0] if form_data else 'Unknown'
            desc = desc[:COLS-14]
            stdscr.addstr(i + 2, 4, f"{i}: {local_form_id} - {desc}", curses.color_pair(GREEN))
        stdscr.addstr(1, 42, "Comms Log", curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(2, 42, "= " * 18, curses.color_pair(RED))
        for i, (msg, ts) in enumerate(comms_log[-18:], start=3):
            stdscr.addstr(i, 42, f"{msg[:36]}", curses.color_pair(GREEN))
        if submission_result:
            msg = f"Submission: {submission_result}"
            stdscr.addstr(20, (max_x - len(msg)) // 2, msg, curses.color_pair(YELLOW) | curses.A_BOLD)
            time.sleep(2)
            submission_result = None
            screen_dirty = True
            if LOG_REDRAW_TRIGGERS:
                log_event("screen_dirty set by submission_result clear", redraw_triggers=True)
        if show_menu:
            menu_options = [
                ("Main Screen", True),
                ("Debug Control", True),
                ("Forms Management", False),
                ("Messages", True),
                ("Group Chat", True),
                ("Quit", True)
            ]
            stdscr.addstr(6, 20, "+====================+", curses.color_pair(RED))
            for i, (option, active) in enumerate(menu_options):
                color = GREEN if active else RED
                if i == menu_selection:
                    stdscr.addstr(7 + i, 20, f"| {option:<18} |", curses.color_pair(color) | curses.A_REVERSE)
                else:
                    stdscr.addstr(7 + i, 20, f"| {option:<18} |", curses.color_pair(color))
            stdscr.addstr(13, 20, "| Up/Down=Move       |", curses.color_pair(GREEN))
            stdscr.addstr(14, 20, "| Enter=Sel Esc=Back |", curses.color_pair(GREEN))
            stdscr.addstr(15, 20, "+====================+", curses.color_pair(RED))
        stdscr.addstr(22, 0, border, curses.color_pair(RED))
        stdscr.addstr(21, 0, f"= Commands: D=Menu 1-{min(form_count, 15)}=Select =", curses.color_pair(GREEN))
    stdscr.refresh()
    screen_dirty = False
    if LOG_UI_RENDER:  # Throttle to reduce spam
        global last_ui_render_log
        if 'last_ui_render_log' not in globals():
            last_ui_render_log = 0
        now = time.time()
        if now - last_ui_render_log >= 1.0:  # Log every 1s
            log_event(f"Rendered screen: form_id={form_id}, mode={mode}", ui_render=True)
            last_ui_render_log = now
    if LOG_FORM_LAYOUT and form_fields:
        log_event(f"Form {form_id} layout rendered: {form_fields}", form_layout=True)

# Chunk 5 v3.2 - Screen Transition Functions (split from Chunk 4)
def display_form_list(stdscr):
    global comms_log, screen_dirty, form_id, selecting_mode, form_fields, current_field, show_menu, mode, submission_result
    if LOG_UI_TRANSITIONS:
        log_event("Transition to form list", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event("Screen state: Displaying form list", screen_state=True)
    form_id = None
    selecting_mode = False
    form_fields = {}
    current_field = None
    show_menu = False
    mode = None
    submission_result = None
    screen_dirty = True
    if LOG_REDRAW_TRIGGERS:
        log_event("screen_dirty set by display_form_list", redraw_triggers=True)
    redraw_screen(stdscr)

def display_mode_prompt(stdscr, selected_form_id):
    global comms_log, screen_dirty, form_id, selecting_mode
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to mode prompt for {selected_form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying mode prompt for {selected_form_id}", screen_state=True)
    form_id = selected_form_id
    selecting_mode = True
    screen_dirty = True
    if LOG_REDRAW_TRIGGERS:
        log_event("screen_dirty set by display_mode_prompt", redraw_triggers=True)
    redraw_screen(stdscr)

def load_form(stdscr, form_id):
    global form_fields, field_values, cursor_row, cursor_col, cursor_offset, current_field, screen_dirty, selecting_mode, mode
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to form {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Loading form {form_id} in mode {mode}", screen_state=True)
    stdscr.erase()
    stdscr.clear()
    form_data = load_form_data(form_id)
    if form_data:
        form_fields = form_data['fields']
        for fid in form_fields:
            form_fields[fid]['form_id'] = form_id
        field_values = {fid: '' for fid in form_fields}
        first_field = min(form_fields.keys(), key=lambda x: (form_fields[x]['row'], form_fields[x]['col']))
        current_field = first_field
        cursor_row, cursor_col = form_fields[first_field]['row'], form_fields[first_field]['col'] + 1  # Start inside [
        cursor_offset = 0
        selecting_mode = False
        screen_dirty = True
        if LOG_REDRAW_TRIGGERS:
            log_event("screen_dirty set by load_form", redraw_triggers=True)
        redraw_screen(stdscr)

# Chunk 6 v3.2 - Server Communication (was Chunk 6)
def radio_send(packet):
    if COMM_MODE == 'RADIO':
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((AGW_HOST, AGW_PORT))
            s.send(packet.encode())
            log_comms(f"AGWPE sent: {packet[:50]}")  # Raw packet only

def send_to_server(stdscr, data):
    global comms_log, screen_dirty, mode, listener_socket, sending, submission_result
    send_start = time.time()
    sending = True
    if LOG_SEND_STATE:
        log_event("Send initiated", send_state=True)
    if LOG_SUBMISSION_FLOW:
        log_event("Starting submission process", submission_flow=True)
    
    if data.startswith('INDEX:'):
        function = 'UPDATE'
        form_id = 'NONE'
        payload = data.split(':', 2)[2]
        if LOG_SYNC_PACKETS:
            log_event(f"Preparing sync UPDATE packet with payload: {payload[:50]}", sync_packets=True)
    elif data.startswith('REQ_UPDATE:'):
        function = 'REQUEST'
        form_id = 'NONE'
        payload = ''
    else:
        function = 'SEARCH' if mode == 'S' else 'INSERT'
        form_id = form_fields[next(iter(form_fields))]['form_id'] if form_fields else 'NONE'
        payload = '|'.join(f"{fid}{value.rstrip()}" for fid, value in field_values.items()) if form_fields else ''
        if LOG_SUBMISSION_PAYLOAD and payload:
            log_event(f"Submission payload: {payload}", payload=True)
    
    full_packet = f"{function}|{CALLSIGN}|{form_id}|{payload}\n"
    if LOG_PACKET_BUILD:
        log_event(f"Built packet: {full_packet.strip()}", packet_build=True)
    log_comms(full_packet.strip())  # Raw packet to Comms Log
    if LOG_PACKET_INTEGRITY:
        log_event("Send packet structure: len=" + str(len(full_packet)) + ", newlines=" + str(full_packet.count('\n')), packet_integrity=True)
    if LOG_SEARCH_QUERY and function == 'SEARCH':
        log_event(f"Search query packet: {full_packet[:50]}", search_query=True)
    
    segments = [full_packet]
    if len(full_packet) > PACLEN:
        header = f"{function}|{CALLSIGN}|{form_id}|"
        chunk_size = PACLEN - len(header) - 6
        payload_chunks = [payload[i:i+chunk_size] for i in range(0, len(payload), chunk_size)]
        segments = [f"{header}{seq}:{len(payload_chunks)}|{chunk}\n" for seq, chunk in enumerate(payload_chunks, 1)]
        if LOG_PACKET_FRAGMENTS:
            log_event(f"Packet fragmented into {len(segments)} segments", packet_fragments=True)
    
    total = len(segments)
    try:
        if COMM_MODE == 'TCP':
            if listener_socket and listener_socket.fileno() >= 0:
                s = listener_socket
                if LOG_SOCKET_STATE:
                    log_event("Socket state: Using existing listener_socket", socket_state=True)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(10)
                s.connect((SERVER_HOST, SERVER_PORT))
                if LOG_SOCKET_STATE:
                    log_event(f"Socket state: New socket created and connected to {SERVER_HOST}:{SERVER_PORT}", socket_state=True)
                if LOG_CONNECTION_SUCCESS:
                    log_event(f"Connected to {SERVER_HOST}:{SERVER_PORT}", connection_success=True)
            if function in ('INSERT', 'SEARCH'):
                redraw_screen(stdscr, sending=True)
                stdscr.refresh()
            for seq, segment in enumerate(segments, 1):
                s.send(segment.encode())
                log_comms(segment.strip())  # Raw packet segment to Comms Log
                if LOG_SEGMENT_STATUS:
                    log_event(f"Segment {seq}/{total} sent: {segment[:50]}", segment=True)
                if LOG_SYNC_PACKETS and function == 'UPDATE':
                    log_event(f"Sent sync segment {seq}/{total}: {segment[:50]}", sync_packets=True)
            if s != listener_socket:
                s.close()
                if LOG_SOCKET_STATE:
                    log_event("Socket state: Temporary send socket closed", socket_state=True)
        elif COMM_MODE == 'RADIO':
            radio_send(segments[0])
        if LOG_SEND_STATE:
            log_event("Send completed, awaiting ACK via listener", send_state=True)
        sending = False
    except Exception as e:
        log_event(f"Send failed: {str(e)}", debug=True, socket_errors=True)
        if LOG_ERROR_DETAILS:
            log_event(f"Send error details: {traceback.format_exc()}", error_details=True)
        if LOG_SEGMENT_FAILURE:
            log_event(f"Segment {seq if 'seq' in locals() else 'unknown'}/{total} failed: {str(e)}", segment_failure=True)
        submission_result = "Failed"
        sending = False
        screen_dirty = True
        if LOG_REDRAW_TRIGGERS:
            log_event("screen_dirty set by send error", redraw_triggers=True)
        display_form_list(stdscr)
        if LOG_SEND_STATE:
            log_event(f"Send failed with error: {str(e)}", send_state=True)
        return ""
    return ""

def server_listener(stdscr, stop_event):
    # CHANGE v3.2: Enhanced socket handling to prevent NoneType crash
    global comms_log, screen_dirty, messages, unread_messages, listener_socket, last_no_data, sending, submission_result, syncing, packet_queue
    log_event(f"Starting server listener, connecting to {SERVER_HOST}:{SERVER_PORT}", debug=True, listener_state=True, thread_state=True)
    buffer = ""
    last_timeout_log = 0
    retry_delay = RETRY_DELAY
    max_delay = 60
    while not stop_event.is_set():
        try:
            if not listener_socket or listener_socket.fileno() < 0:
                log_event("Listener socket invalid, creating new one", debug=True, socket_state=True)
                listener_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                listener_socket.settimeout(5)
                if LOG_CONNECTIVITY:
                    log_event(f"TCP connecting to {SERVER_HOST}:{SERVER_PORT}", debug=True)
                if LOG_SOCKET_STATE:
                    log_event(f"Socket state: Creating new socket for {SERVER_HOST}:{SERVER_PORT}", socket_state=True)
                if LOG_LISTENER_STATE:
                    log_event("Listener socket created", listener_state=True)
                
                for attempt in range(MAX_RETRIES):
                    try:
                        log_event(f"Attempting connection to {SERVER_HOST}:{SERVER_PORT} (attempt {attempt + 1}/{MAX_RETRIES})", connection_attempts=True)
                        listener_socket.connect((SERVER_HOST, SERVER_PORT))
                        if LOG_CONNECTIVITY:
                            log_comms(f"Connected to {SERVER_HOST}:{SERVER_PORT}")  # Raw connect message
                        if LOG_RETRIES:
                            log_event(f"Retry {attempt + 1}/{MAX_RETRIES} succeeded", retries=True)
                        if LOG_LISTENER_RETRIES:
                            log_event(f"Listener connected on attempt {attempt + 1}", listener_retries=True)
                        if LOG_SOCKET_STATE:
                            log_event(f"Socket state: Connected on attempt {attempt + 1}", socket_state=True)
                        if LOG_CONNECTION_SUCCESS:
                            log_event(f"Successfully connected to {SERVER_HOST}:{SERVER_PORT}", connection_success=True)
                        retry_delay = RETRY_DELAY
                        break
                    except ConnectionRefusedError:
                        if LOG_CONNECTIVITY:
                            log_event(f"Connection failed, retrying ({attempt + 1}/{MAX_RETRIES})", debug=True)
                        if LOG_RETRIES:
                            log_event(f"Connection refused, retry {attempt + 1}/{MAX_RETRIES}", retries=True)
                        if LOG_LISTENER_RETRIES:
                            log_event(f"Retry {attempt + 1}/{MAX_RETRIES} failed: Connection refused", listener_retries=True)
                        if attempt == MAX_RETRIES - 1:
                            if LOG_CONNECTIVITY:
                                log_event(f"Max retries reached, backing off for {retry_delay}s", debug=True)
                            if LOG_LISTENER_RETRIES:
                                log_event(f"Max retries exhausted, delaying {retry_delay}s", listener_retries=True)
                            time.sleep(retry_delay)
                            retry_delay = min(retry_delay * 2, max_delay)
                        else:
                            time.sleep(1)
                    except Exception as e:
                        log_event(f"Unexpected connect error: {str(e)}", debug=True, socket_errors=True)
                        if LOG_ERROR_DETAILS:
                            log_event(f"Connect error details: {traceback.format_exc()}", error_details=True)
                        if LOG_LISTENER_STATE:
                            log_event(f"Listener connect failed: {str(e)}", listener_state=True)
                        listener_socket.close()
                        listener_socket = None
                        if LOG_SOCKET_RESET:
                            log_event("Socket reset due to connect error", socket_reset=True)
                        time.sleep(retry_delay)
                        retry_delay = min(retry_delay * 2, max_delay)
                        break
                else:
                    time.sleep(retry_delay)
                    retry_delay = min(retry_delay * 2, max_delay)
                    continue

            while not stop_event.is_set():
                try:
                    if listener_socket:
                        data = listener_socket.recv(512).decode()
                        if data:
                            buffer += data
                            if "FORM_UPDATE" in data:
                                form_id = data.split('|')[2]
                                log_comms(f"Updated form: {form_id}")  # Raw packet notice
                            log_event(f"Data received: {data[:100]}", debug=True)
                            while '\n' in buffer:
                                packet_end = buffer.find('\n')
                                packet = buffer[:packet_end].strip()
                                log_comms(packet)  # Raw packet to Comms Log
                                if LOG_PACKET_INTEGRITY:
                                    log_event("Received packet structure: parts=" + str(len(packet.split('|'))) + ", newlines=" + str(packet.count('\n')) + ", tildes=" + str(packet.count('~')), packet_integrity=True)
                                parts = packet.split('|', 3)
                                if len(parts) != 4:
                                    log_event(f"Malformed packet: {packet[:50]}", debug=True)
                                    buffer = buffer[packet_end + 1:].lstrip('\n')
                                    continue
                                function, callsign, form_id, payload = parts
                                packet_data = (function, callsign, form_id, payload)
                                try:
                                    packet_queue.put_nowait(packet_data)
                                    if LOG_PACKET_QUEUE:
                                        log_event(f"Enqueued packet: {packet[:50]}", packet_queue=True)
                                    if LOG_LISTENER_QUEUE:
                                        log_event(f"Listener enqueued: {function}|{callsign}|{form_id}|{payload[:20]}", listener_queue=True)
                                    if LOG_QUEUE_STATE:
                                        log_event(f"Queue state: size={packet_queue.qsize()}, full={packet_queue.full()}", queue_state=True)
                                except queue.Full:
                                    log_event(f"Queue full, dropped packet: {packet[:50]}", debug=True, packet_queue=True, packet_drop=True)
                                buffer = buffer[packet_end + 1:].lstrip('\n')
                        else:
                            log_event("Server disconnected: Empty data received", debug=True, socket_errors=True)
                            if LOG_SOCKET_STATE:
                                log_event("Socket state: Server closed connection", socket_state=True)
                            if LOG_LISTENER_STATE:
                                log_event("Listener detected server disconnect", listener_state=True)
                            listener_socket.close()
                            listener_socket = None
                            if LOG_SOCKET_RESET:
                                log_event("Socket reset due to server disconnect", socket_reset=True)
                            buffer = ""
                            break
                    else:
                        log_event("Listener socket is None, breaking to reconnect", debug=True, socket_errors=True)
                        break
                except socket.timeout:
                    now = time.time()
                    if now - last_no_data >= 60 and now - last_timeout_log >= 60:
                        log_event("No data received, connection still alive", debug=True)
                        last_no_data = now
                        last_timeout_log = now
                except (ConnectionResetError, OSError) as e:
                    log_event(f"Socket error: {str(e)}, closing socket", debug=True, socket_errors=True)
                    if LOG_ERROR_DETAILS:
                        log_event(f"Listener socket error details: {traceback.format_exc()}", error_details=True)
                    if LOG_SOCKET_STATE:
                        log_event(f"Socket state: Closed due to error {str(e)}", socket_state=True)
                    if LOG_LISTENER_STATE:
                        log_event(f"Listener error: {str(e)}", listener_state=True)
                    if listener_socket:
                        listener_socket.close()
                        listener_socket = None
                        if LOG_SOCKET_RESET:
                            log_event("Socket reset due to connection error", socket_reset=True)
                    buffer = ""
                    break
                except AttributeError as e:
                    log_event(f"NoneType error: {str(e)}, resetting socket", debug=True, socket_errors=True)
                    if LOG_ERROR_DETAILS:
                        log_event(f"NoneType error details: {traceback.format_exc()}", error_details=True)
                    listener_socket = None
                    buffer = ""
                    break
                time.sleep(0.1)
        except Exception as e:
            log_event(f"Unexpected listener error: {str(e)}", debug=True, socket_errors=True)
            if LOG_ERROR_DETAILS:
                log_event(f"Listener crash details: {traceback.format_exc()}", error_details=True)
            if LOG_LISTENER_STATE:
                log_event(f"Listener crashed with error: {str(e)}", listener_state=True)
            if listener_socket:
                listener_socket.close()
                if LOG_SOCKET_RESET:
                    log_event("Socket reset due to listener crash", socket_reset=True)
                listener_socket = None
            buffer = ""
            time.sleep(retry_delay)
            retry_delay = min(retry_delay * 2, max_delay)

def process_server_data(stdscr, data):
    pass  # Legacy function

# Chunk 7 v3.2 - Main Loop (Navigation & Submit) (was Chunk 7)
def main(stdscr):
    global cursor_offset, current_field, cursor_row, cursor_col, comms_log, screen_dirty, form_id, selecting_mode, field_values, form_fields, show_menu, menu_selection, mode, sending, submission_result, syncing, packet_queue
    log_event(f"Script v3.2 started", debug=True)  # CHANGE v3.2: Updated version
    stdscr.resize(ROWS, COLS)
    curses.curs_set(0)
    stdscr.nodelay(True)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    cursor_offset = 0
    current_field = None
    cursor_row = None
    cursor_col = None
    comms_log = []
    debug_log = []
    screen_dirty = True
    form_id = None
    selecting_mode = False
    show_menu = False
    menu_selection = 0
    mode = None
    form_fields = {}
    field_values = {}
    sending = False
    submission_result = None
    syncing = False

    stop_event = threading.Event()
    listener_thread = threading.Thread(target=server_listener, args=(stdscr, stop_event))
    listener_thread.daemon = True
    listener_thread.start()
    if LOG_THREAD_STATE:
        log_event("Listener thread started", thread_state=True)

    log_event("Entering main", debug=True)
    display_form_list(stdscr)
    while True:
        char = stdscr.getch()
        if char != -1:
            log_event(f"Key pressed: {char}", debug=True)
            if LOG_KEY_CONTEXT:
                log_event(f"Key {char} in state: form_id={form_id}, mode={mode}, current_field={current_field}", key_context=True)
        if char == -1:
            time.sleep(0.05)
        else:
            log_event(f"Processing char: {char}", debug=True)
            if not form_id and not selecting_mode and not any(form_fields):
                if show_menu:
                    if char == curses.KEY_UP and menu_selection > 0:
                        menu_selection -= 1
                        screen_dirty = True
                        if LOG_REDRAW_TRIGGERS:
                            log_event("screen_dirty set by menu up", redraw_triggers=True)
                    elif char == curses.KEY_DOWN and menu_selection < 5:
                        menu_selection += 1
                        screen_dirty = True
                        if LOG_REDRAW_TRIGGERS:
                            log_event("screen_dirty set by menu down", redraw_triggers=True)
                    elif char == 10:
                        if menu_selection == 0:
                            show_menu = False
                            screen_dirty = True
                            if LOG_REDRAW_TRIGGERS:
                                log_event("screen_dirty set by menu Main Screen", redraw_triggers=True)
                        elif menu_selection == 1:
                            show_menu = False
                            screen_dirty = True
                            stdscr.addstr(1, 2, "Debug Control Screen - TBD", curses.color_pair(GREEN))
                            stdscr.refresh()
                            time.sleep(1)
                        elif menu_selection == 2:
                            show_menu = False
                            screen_dirty = True
                            stdscr.addstr(1, 2, "Forms Management Screen - TBD", curses.color_pair(GREEN))
                            stdscr.refresh()
                            time.sleep(1)
                        elif menu_selection == 3:
                            show_menu = True
                            screen_dirty = True
                        elif menu_selection == 4:
                            show_menu = False
                            screen_dirty = True
                            stdscr.addstr(1, 2, "Group Chat Screen - TBD", curses.color_pair(GREEN))
                            stdscr.refresh()
                            time.sleep(1)
                        elif menu_selection == 5:
                            log_comms("Quitting via menu")  # Raw quit notice
                            log_event("Script exiting: Menu quit selected", debug=True)
                            stop_event.set()
                            break
                    elif char == 27:
                        show_menu = False
                        screen_dirty = True
                        if LOG_REDRAW_TRIGGERS:
                            log_event("screen_dirty set by menu Esc", redraw_triggers=True)
                else:
                    form_files = [f[:-4] for f in os.listdir(FORMS_DIR) if f.endswith('.txt')]
                    form_files.sort()
                    if chr(char).isdigit() and 1 <= int(chr(char)) <= len(form_files):
                        form_idx = int(chr(char)) - 1
                        form_id = form_files[form_idx]
                        selecting_mode = True
                        display_mode_prompt(stdscr, form_id)
                    elif char == ord('d') or char == ord('D'):
                        show_menu = True
                        menu_selection = 0
                        screen_dirty = True
                        if LOG_REDRAW_TRIGGERS:
                            log_event("screen_dirty set by D menu", redraw_triggers=True)
                    elif char == ord('q') or char == ord('Q'):
                        log_event("Ignoring Q on main screen - use menu", debug=True)
            elif selecting_mode:
                if chr(char).lower() == 's':
                    mode = 'S'
                    if LOG_MODE_SWITCH:
                        log_event(f"Mode switched to Search for {form_id}", mode_switch=True)
                    display_search_screen(stdscr, form_id)
                elif chr(char).lower() == 'i':
                    mode = 'I'
                    if LOG_MODE_SWITCH:
                        log_event(f"Mode switched to Insert for {form_id}", mode_switch=True)
                    load_form(stdscr, form_id)
            elif char == 27 and form_fields:
                if sending:
                    redraw_screen(stdscr, sending=True)
                else:
                    if LOG_FORM_EXIT:
                        log_event(f"Form {form_id} exited via Esc, mode={mode}", form_exit=True)
                    form_id = None
                    selecting_mode = False
                    form_fields = {}
                    field_values = {}
                    current_field = None
                    display_form_list(stdscr)
            elif char == 27 and show_menu and menu_selection == 3:
                show_menu = False
                screen_dirty = True
                if LOG_REDRAW_TRIGGERS:
                    log_event("screen_dirty set by Esc from messages", redraw_triggers=True)
            elif char == 10 and current_field is not None and form_fields:
                if current_field == 'submit' and not sending:
                    if LOG_SUBMISSION_FLOW:
                        log_event("Submit triggered", submission_flow=True)
                    send_to_server(stdscr, "")
                    form_id = None
                    selecting_mode = False
                    form_fields = {}
                    field_values = {}
                    current_field = None
                    if LOG_FORM_EXIT:
                        log_event(f"Form {form_id} exited via submit, mode={mode}", form_exit=True)
                    if LOG_SUBMISSION_FLOW:
                        log_event("Post-submit reset complete", submission_flow=True)
                elif current_field == 'cancel':
                    if LOG_FORM_EXIT:
                        log_event(f"Form {form_id} exited via cancel, mode={mode}", form_exit=True)
                    form_id = None
                    selecting_mode = False
                    form_fields = {}
                    field_values = {}
                    current_field = None
                    display_form_list(stdscr)
                else:
                    field_ids = sorted(form_fields.keys(), key=lambda x: (form_fields[x]['row'], form_fields[x]['col'])) + ['submit', 'cancel']
                    idx = field_ids.index(current_field)
                    current_field = field_ids[(idx + 1) % len(field_ids)]
                    cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'])
                    row = 19 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']  # Adjusted for new UI
                    col = 19 if current_field == 'submit' else 55 if current_field == 'cancel' else form_fields[current_field]['col'] + 1  # Adjusted for new UI
                    move_cursor(stdscr, row, col + cursor_offset)
            elif char == curses.KEY_BACKSPACE:
                if current_field and current_field not in ('submit', 'cancel') and form_fields and cursor_offset > 0:
                    row = form_fields[current_field]['row']
                    col = form_fields[current_field]['col'] + 1  # Adjusted for new UI
                    field_values[current_field] = (
                        field_values[current_field][:cursor_offset - 1] +
                        field_values[current_field][cursor_offset:]
                    )
                    cursor_offset -= 1
                    move_cursor(stdscr, row, col + cursor_offset)
                    redraw_screen(stdscr)
            # CHANGE v3.2: Updated navigation for two-column UI (13-48, 49-80)
            elif char == curses.KEY_UP:
                if current_field and current_field not in ('submit', 'cancel') and form_fields:
                    is_left = current_field.startswith('L')
                    current_row = form_fields[current_field]['row']
                    above_fields = [fid for fid in form_fields if form_fields[fid]['row'] < current_row and (fid.startswith('L') if is_left else fid.startswith('R'))]
                    if above_fields:
                        next_field = max(above_fields, key=lambda x: form_fields[x]['row'])
                        current_field = next_field
                        cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                        move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                        if LOG_ROW_MOVEMENT:
                            log_event(f"Up from {current_field} to {next_field}", row_movement=True)
            elif char == curses.KEY_DOWN:
                if current_field and form_fields:
                    if current_field in ('submit', 'cancel'):
                        field_ids = sorted(form_fields.keys(), key=lambda x: (form_fields[x]['row'], form_fields[x]['col']))
                        if field_ids:
                            current_field = field_ids[0]
                            cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                            move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                    else:
                        is_left = current_field.startswith('L')
                        current_row = form_fields[current_field]['row']
                        below_fields = [fid for fid in form_fields if form_fields[fid]['row'] > current_row and (fid.startswith('L') if is_left else fid.startswith('R'))]
                        if below_fields:
                            next_field = min(below_fields, key=lambda x: form_fields[x]['row'])
                            current_field = next_field
                            cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                            move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                            if LOG_ROW_MOVEMENT:
                                log_event(f"Down from {current_field} to {next_field}", row_movement=True)
                        elif not below_fields and current_field != 'submit':
                            current_field = 'submit'
                            cursor_offset = 0
                            move_cursor(stdscr, 19, 19)  # Adjusted for new UI
            elif char == curses.KEY_LEFT:
                if current_field and current_field not in ('submit', 'cancel') and form_fields and current_field.startswith('R'):
                    current_row = form_fields[current_field]['row']
                    field_num = current_field[1:]
                    left_field = f"L{field_num}"
                    if left_field in form_fields and form_fields[left_field]['row'] == current_row:
                        current_field = left_field
                        cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                        move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                        if LOG_COLUMN_NAVIGATION:
                            log_event(f"Left from R{field_num} to L{field_num}", column_navigation=True)
            elif char == curses.KEY_RIGHT:
                if current_field and current_field not in ('submit', 'cancel') and form_fields and current_field.startswith('L'):
                    current_row = form_fields[current_field]['row']
                    field_num = current_field[1:]
                    right_field = f"R{field_num}"
                    if right_field in form_fields and form_fields[right_field]['row'] == current_row:
                        current_field = right_field
                        cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                        move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                        if LOG_COLUMN_NAVIGATION:
                            log_event(f"Right from L{field_num} to R{field_num}", column_navigation=True)
            elif char == 3:
                log_comms("Branch: Ctrl+C exit")  # Raw exit notice
                log_event("Script exiting: Ctrl+C pressed", debug=True)
                stop_event.set()
                break
            elif 32 <= char <= 126:
                if current_field and current_field not in ('submit', 'cancel') and form_fields:
                    row = form_fields[current_field]['row']
                    col = form_fields[current_field]['col'] + 1  # Adjusted for new UI
                    length = form_fields[current_field]['len']
                    if len(field_values[current_field]) < length:
                        field_values[current_field] = (
                            field_values[current_field][:cursor_offset] +
                            chr(char) +
                            field_values[current_field][cursor_offset:]
                        )[:length]
                        cursor_offset += 1
                        move_cursor(stdscr, row, col + cursor_offset)
                        screen_dirty = True
                        if LOG_REDRAW_TRIGGERS:
                            log_event("screen_dirty set by char input", redraw_triggers=True)
                        redraw_screen(stdscr)

        while not packet_queue.empty() and (not form_fields or not any(form_fields)):
            try:
                function, callsign, form_id, payload = packet_queue.get_nowait()
                if LOG_PACKET_QUEUE:
                    log_event(f"Dequeued packet: {function}|{callsign}|{form_id}|{payload[:20]}", packet_queue=True)
                if LOG_UI_PACKET_HANDLING:
                    log_event(f"UI handling packet: {function}|{callsign}|{form_id}|{payload[:20]}", ui_packet_handling=True)
                if LOG_QUEUE_STATE:
                    log_event(f"Queue state after dequeue: size={packet_queue.qsize()}, empty={packet_queue.empty()}", queue_state=True)

                if function == 'MD5' and not syncing:
                    if LOG_SYNC_STATE:
                        log_event(f"Received MD5 from {callsign}: {payload}", sync_state=True)
                    server_hash = payload
                    client_hash = hash_forms_dir()
                    if LOG_SYNC_MD5:
                        log_event(f"Server MD5: {server_hash}, Client MD5: {client_hash}", sync_md5=True)
                    if server_hash != client_hash:
                        if LOG_SYNC_MISMATCHES:
                            log_event(f"MD5 mismatch detected: server={server_hash}, client={client_hash}", sync_mismatches=True)
                        if LOG_SYNC_START:
                            log_event("Sync started due to MD5 mismatch", sync_start=True)
                        syncing = True
                        index = build_forms_index()
                        update_packet = f"INDEX:{callsign}:{index}"
                        send_to_server(stdscr, update_packet)
                    else:
                        log_event("MD5 match, no sync needed", debug=True)
                        display_form_list(stdscr)
                elif function == 'FORM_UPDATE':
                    file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
                    os.makedirs(FORMS_DIR, exist_ok=True)
                    content = payload.replace('~', '\n').rstrip() + '\n'
                    with open(file_path, 'w', newline='\n') as f:
                        f.write(content)
                    if LOG_SYNC_FORMS:
                        log_event(f"Updated {file_path}: {content[:50]}", sync_forms=True)
                    screen_dirty = True
                    if LOG_REDRAW_TRIGGERS:
                        log_event("screen_dirty set by FORM_UPDATE", redraw_triggers=True)
                    display_form_list(stdscr)
                    client_hash = hash_forms_dir()
                    if LOG_SYNC_MD5:
                        log_event(f"Post-sync MD5: {client_hash}", sync_md5=True)
                    if LOG_SYNC_COMPLETION:
                        log_event(f"Sync completed, MD5: {client_hash}", sync_completion=True)
                    syncing = False
                elif function == 'FORM_DELETE':
                    file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
                    if os.path.exists(file_path):
                        os.remove(file_path)
                        if LOG_FORM_DELETION:
                            log_event(f"Form {form_id} deleted from {file_path}", form_deletion=True)
                    else:
                        if LOG_FORM_DELETION:
                            log_event(f"Form {form_id} not found for deletion", form_deletion=True)
                    screen_dirty = True
                    if LOG_REDRAW_TRIGGERS:
                        log_event("screen_dirty set by FORM_DELETE", redraw_triggers=True)
                    display_form_list(stdscr)
                    client_hash = hash_forms_dir()
                    if LOG_SYNC_MD5:
                        log_event(f"Post-sync MD5: {client_hash}", sync_md5=True)
                    if LOG_SYNC_COMPLETION:
                        log_event(f"Sync completed, MD5: {client_hash}", sync_completion=True)
                    syncing = False
                elif function == 'SEARCH_RESULT':
                    if LOG_SEARCH_RESULTS:
                        log_event(f"Received SEARCH_RESULT: {function}|{callsign}|{form_id}|{payload[:50]}", search_results=True)
                    sending = False
                    screen_dirty = True
                    if LOG_REDRAW_TRIGGERS:
                        log_event("screen_dirty set by SEARCH_RESULT", redraw_triggers=True)
                    display_results_screen(stdscr, form_id, payload)
                elif function == 'ACK':
                    if LOG_SUBMISSION_DETAILS:
                        log_event(f"Received ACK: {payload}", submission_details=True)
                    if LOG_SUBMISSION_FLOW:
                        log_event("ACK received, submission successful", submission_flow=True)
                    sending = False
                    submission_result = payload
                    screen_dirty = True
                    if LOG_REDRAW_TRIGGERS:
                        log_event("screen_dirty set by ACK", redraw_triggers=True)
                    display_form_list(stdscr)
                elif function in ('MSG', 'CHAT'):
                    messages.append(f"{function}:{callsign}:{payload}")
                    unread_messages = True
                    screen_dirty = True
                    if LOG_REDRAW_TRIGGERS:
                        log_event("screen_dirty set by MSG/CHAT", redraw_triggers=True)
                packet_queue.task_done()
            except queue.Empty:
                break

        if screen_dirty:
            redraw_screen(stdscr)
        time.sleep(0.05)

# Chunk 8 v3.2 - Search Screen (was Chunk 8)
def display_search_screen(stdscr, form_id):
    global form_fields, field_values, current_field, cursor_offset, screen_dirty, mode
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to search screen for {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying search screen for {form_id}", screen_state=True)
    form_data = load_form_data(form_id)
    if not form_data:
        log_comms(f"Form {form_id} not found")  # Raw error notice
        display_form_list(stdscr)
        return
    form_fields = form_data['fields']
    field_values = {fid: '' for fid in form_fields}
    current_field = min(form_fields.keys())
    cursor_offset = 0
    screen_dirty = True
    if LOG_REDRAW_TRIGGERS:
        log_event("screen_dirty set by display_search_screen", redraw_triggers=True)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    while True:
        redraw_screen(stdscr)
        char = stdscr.getch()
        if char == 27 or (char == 10 and current_field == 'cancel'):
            if LOG_SCREEN_STATE:
                log_event("Screen state: Cancelled search, returning to form list", screen_state=True)
            display_form_list(stdscr)
            break
        elif char == 10 and current_field == 'submit' and not sending:
            send_to_server(stdscr, "")
            break
        elif char == 10:
            field_ids = sorted(form_fields.keys()) + ['submit', 'cancel']
            idx = field_ids.index(current_field)
            current_field = field_ids[(idx + 1) % len(field_ids)]
            cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'])
            row = 19 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']  # Adjusted for new UI
            col = 19 if current_field == 'submit' else 55 if current_field == 'cancel' else form_fields[current_field]['col'] + 1  # Adjusted for new UI
            move_cursor(stdscr, row, col)
        elif char in (curses.KEY_UP, curses.KEY_DOWN):
            field_ids = sorted(form_fields.keys()) + ['submit', 'cancel']
            idx = field_ids.index(current_field)
            delta = -1 if char == curses.KEY_UP else 1
            current_field = field_ids[(idx + delta) % len(field_ids)]
            cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'])
            row = 19 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']  # Adjusted for new UI
            col = 19 if current_field == 'submit' else 55 if current_field == 'cancel' else form_fields[current_field]['col'] + 1  # Adjusted for new UI
            move_cursor(stdscr, row, col)
        elif char == curses.KEY_BACKSPACE and current_field in form_fields and cursor_offset > 0:
            field_values[current_field] = field_values[current_field][:cursor_offset-1] + field_values[current_field][cursor_offset:]
            cursor_offset -= 1
            screen_dirty = True
            if LOG_REDRAW_TRIGGERS:
                log_event("screen_dirty set by backspace in search", redraw_triggers=True)
        elif 32 <= char <= 126 and current_field in form_fields:
            length = form_fields[current_field]['len']
            if len(field_values[current_field]) < length:
                field_values[current_field] = field_values[current_field][:cursor_offset] + chr(char) + field_values[current_field][cursor_offset:]
                cursor_offset += 1
                screen_dirty = True
                if LOG_REDRAW_TRIGGERS:
                    log_event("screen_dirty set by char in search", redraw_triggers=True)
        if screen_dirty:
            redraw_screen(stdscr)

# Chunk 9 v3.2 - Results Screen (was Chunk 9)
def display_results_screen(stdscr, form_id, payload):
    global screen_dirty
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to results screen for {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying search results for {form_id}", screen_state=True)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    rows = payload.split('~')
    parsed_rows = []
    for row in rows:
        fields = {}
        for field in row.split('|'):
            if len(field) >= 2:
                fields[field[:2]] = field[2:]
        parsed_rows.append(fields)
    all_fields = sorted(set().union(*[row.keys() for row in parsed_rows]))
    result_data = [{fid: row.get(fid, 'N/A') for fid in all_fields} for row in parsed_rows]
    result_df = pd.DataFrame(result_data)
    screen_dirty = True
    if LOG_REDRAW_TRIGGERS:
        log_event("screen_dirty set by display_results_screen", redraw_triggers=True)
    while True:
        stdscr.erase()
        stdscr.addstr(0, 0, "=" * (COLS-1), curses.color_pair(RED))
        stdscr.addstr(1, 2, f"Search Results for {form_id}", curses.color_pair(GREEN))
        table = tabulate(result_df, headers='keys', tablefmt='grid', showindex=False)
        for i, line in enumerate(table.split('\n')[:20]):
            stdscr.addstr(i+3, 2, line[:COLS-4], curses.color_pair(GREEN))
        stdscr.addstr(22, 2, "= Esc=Back =", curses.color_pair(GREEN))
        stdscr.addstr(23, 0, "=" * (COLS-1), curses.color_pair(RED))
        stdscr.refresh()
        char = stdscr.getch()
        if char == 27:
            if LOG_SCREEN_STATE:
                log_event("Screen state: Exiting results screen to form list", screen_state=True)
            display_form_list(stdscr)
            break

# Chunk 10 v3.2 - Main Loop (Exit Only) (was part of Chunk 10)
if __name__ == "__main__":
    print("Starting terminal client...")
    try:
        log_event("Client startup initiated", debug=True)
        curses.wrapper(main)
    except Exception as e:
        log_event(f"Curses failed: {str(e)}", debug=True, socket_errors=True)
        if LOG_ERROR_DETAILS:
            log_event(f"Startup error details: {traceback.format_exc()}", error_details=True)
        raise

# Chunk 11 v3.2 - Design Goals and Statuses (was part of Chunk 10)
# DESIGN GOALS:
# - v3.04: Default callsign CLT001, UI packets, enhanced logging - Done
# - v3.1: Add two-column Lxx/Rxx support with Left/Right nav in forms - Done
# - v3.2: Update form display UI to match server (cols 13-48, 49-80), enhance nav, restrict Comms Log to packets only, add logging (ui_render, socket_errors), throttle UI logs, fix NoneType crash in server_listener - Done  # CHANGE v3.2: Updated goal
# - Future: Separate people.csv sync (MD5_people:)
# - Future: Add options screen for config and logging control
# CHANGES:
# - v3.1: Updated VERSION to 3.1 (Chunk 1),
#         added two-column display in redraw_screen (Chunk 4) with Lxx at col=12, Rxx at col=32,
#         added Left/Right nav for paired rows (e.g., L03<->R03) and updated Up/Down for column consistency (Chunk 7),
#         added logging for column_navigation, form_layout, row_movement in config and log_event (Chunk 1, 3),
#         updated command hint in redraw_screen (Chunk 4),
#         line count increased from 951 to ~1000 (Chunk 10)
# - v3.2: Updated VERSION to 3.2 (Chunk 1),
#         split Chunk 4 into 4/5 (11 chunks total), renumbered Chunks 5-10 to 6-11,
#         updated redraw_screen UI to cols 13-48 (left) and 49-80 (right) with 34/30 chars inside (Chunk 4),
#         enhanced navigation for two-column consistency (Chunk 7),
#         added log_comms for packet-only Comms Log (Chunk 3), set log_event ui default to False (Chunk 3),
#         updated all chunks to use log_comms for packets and ui=False elsewhere (Chunks 1-10),
#         added log_form_display_error, log_ui_render, log_socket_errors and turned off log_ui_state, log_redraw_triggers, log_field_state, log_ui_transitions (Chunk 1, 3),
#         throttled redraw_screen logging to 1/sec (Chunk 4),
#         fixed NoneType crash in server_listener with null checks (Chunk 6),
#         line count increased from ~1000 to ~1139 due to UI updates, logging, socket fixes, and comments (Chunk 11)  # CHANGE v3.2: Detailed updates