#!/usr/bin/env python3
# terminal_client.py
# Version 4.3.1 - 2025-03-18  # CHANGE v4.3.1: Bumped for aggressive bug hunting with new logging

# Chunk 1 v4.3 - Imports and Config
import time
import random
import sys
import os
import curses
import socket
import traceback
import textwrap
import glob
import shutil
import hashlib
import threading
import configparser
import pandas as pd
import queue
from tabulate import tabulate

INSTALL_DIR = os.path.dirname(os.path.realpath(__file__))
CONFIG_FILE = os.path.join(INSTALL_DIR, "terminal_client.conf")
CALLSIGN = None
COMM_MODE = 'KISS'
ROWS, COLS = 24, 80
TX_WINDOW = 10
SERVER_HOST = 'pi4.lan'  # Retained for config compatibility
SERVER_PORT = 12345      # Retained for config compatibility
FAKE_DIREWOLF_HOST = '127.0.0.1'
FAKE_DIREWOLF_PORT = 8051
AGW_HOST = '127.0.0.1'  # Retained for commented-out RADIO mode
AGW_PORT = 8000         # Retained for commented-out RADIO mode
LOG_FILE = os.path.join(INSTALL_DIR, "skippys_messups.log")
FORMS_DIR = os.path.join(INSTALL_DIR, "forms")
BACKUP_DIR = os.path.join(INSTALL_DIR, "backups")
MAX_RETRIES = 5
RETRY_DELAY = 5  # seconds

PACLEN = 255  # Increased from 128 in v3.01 to fit UPDATE packets

VERSION = "4.3.1"  # CHANGE v4.3.1: Updated for new logging to hunt UPDATE bug

config = configparser.ConfigParser()
if not os.path.exists(CONFIG_FILE):
    config['Settings'] = {
        'callsign': 'CLT001',
        'comm_mode': 'KISS',
        'paclen': str(PACLEN),
        'fake_direwolf_host': '127.0.0.1',
        'fake_direwolf_port': '8051',
        'log_callsign_prompt': 'True',
        'log_connectivity': 'True',
        'log_debug': 'True',
        'log_comm_details': 'False',
        'log_form_updates': 'False',
        'log_submission': 'True',
        'log_ui_state': 'False',
        'log_packet_details': 'False',
        'log_segment_status': 'True',
        'log_submission_details': 'True',
        'log_submission_payload': 'True',
        'log_segment_failure': 'True',
        'log_socket_state': 'True',
        'log_retries': 'True',
        'log_ui_transitions': 'False',
        'log_ack_processing': 'True',
        'log_send_state': 'True',
        'log_listener_state': 'True',
        'log_search_query': 'True',
        'log_search_results': 'True',
        'log_screen_state': 'True',
        'log_field_state': 'False',
        'log_submission_flow': 'True',
        'log_debug_forms': 'False',
        'log_debug_sync': 'True',
        'log_cursor_movement': 'False',
        'log_packet_timing': 'False',
        'log_error_details': 'True',
        'log_packet_build': 'True',
        'log_packet_parse': 'False',
        'log_sync_state': 'True',
        'log_sync_md5': 'False',
        'log_sync_forms': 'False',
        'log_sync_packets': 'True',
        'log_packet_integrity': 'True',
        'log_listener_retries': 'True',
        'log_socket_reset': 'True',
        'log_connection_success': 'True',
        'log_packet_fragments': 'True',
        'log_sync_mismatches': 'True',
        'log_redraw_triggers': 'False',
        'log_form_deletion': 'True',
        'log_sync_start': 'True',
        'log_sync_completion': 'True',
        'log_form_exit': 'True',
        'log_key_context': 'False',
        'log_mode_switch': 'True',
        'log_packet_queue': 'True',
        'log_listener_queue': 'True',
        'log_ui_packet_handling': 'True',
        'log_queue_state': 'False',
        'log_connection_attempts': 'True',
        'log_packet_drop': 'True',
        'log_thread_state': 'True',
        'log_column_navigation': 'True',
        'log_form_layout': 'True',
        'log_row_movement': 'True',
        'log_form_display_error': 'True',
        'log_ui_render': 'False',
        'log_socket_errors': 'True',
        'log_form_ui_layout': 'True',
        'log_input_field_state': 'True',
        'log_kiss_framing': 'True',
        'log_ax25_state': 'True',
        'log_ax25_packet': 'True',
        'log_ax25_parse_error': 'True',
        'log_kiss_packet_received': 'True',
        'log_packet_validation': 'True',
        'log_md5_comparison': 'True',
        'log_packet_relay': 'True',
        'log_ui_redraw': 'True',
        'log_socket_send_bytes': 'True',
        'log_socket_send_failure': 'True',
        'log_socket_reconnect': 'True',
        'log_socket_status': 'True',
        # CHANGE v4.3.1: Added aggressive logging for bug hunting
        'log_socket_send_raw': 'True',          # Raw bytes sent to socket
        'log_socket_buffer': 'True',           # Socket buffer state
        'log_ui_comms_log': 'True',           # Comms Log updates
        'log_packet_send_time': 'True',       # Timestamp of packet sends
        'log_packet_enqueue_time': 'True',    # Timestamp of packet enqueue
        'log_packet_dequeue_time': 'True',    # Timestamp of packet dequeue
        'log_queue_size': 'True',            # Packet queue size changes
        'log_redraw_timing': 'True',         # Timing of screen redraws
        'log_kiss_receive_buffer': 'True',   # KISS listener receive buffer
        'log_kiss_frame_timing': 'True',     # Timing of KISS frame extraction
        'log_packet_content': 'True',        # Full packet content
        'log_socket_send_attempt': 'True',   # Each send attempt
        'log_ui_packet_display': 'True',     # Packet visibility in UI
    }
    os.makedirs(INSTALL_DIR, exist_ok=True)
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)
config.read(CONFIG_FILE)
CALLSIGN = config.get('Settings', 'callsign', fallback='CLT001')
COMM_MODE = config.get('Settings', 'comm_mode', fallback='KISS')
PACLEN = config.getint('Settings', 'paclen', fallback=PACLEN)
FAKE_DIREWOLF_HOST = config.get('Settings', 'fake_direwolf_host', fallback='127.0.0.1')
FAKE_DIREWOLF_PORT = config.getint('Settings', 'fake_direwolf_port', fallback=8051)
LOG_CALLSIGN_PROMPT = config.getboolean('Settings', 'log_callsign_prompt', fallback=True)
LOG_CONNECTIVITY = config.getboolean('Settings', 'log_connectivity', fallback=True)
LOG_DEBUG = config.getboolean('Settings', 'log_debug', fallback=True)
LOG_COMM_DETAILS = config.getboolean('Settings', 'log_comm_details', fallback=False)
LOG_FORM_UPDATES = config.getboolean('Settings', 'log_form_updates', fallback=False)
LOG_SUBMISSION = config.getboolean('Settings', 'log_submission', fallback=True)
LOG_UI_STATE = config.getboolean('Settings', 'log_ui_state', fallback=False)
LOG_PACKET_DETAILS = config.getboolean('Settings', 'log_packet_details', fallback=False)
LOG_SEGMENT_STATUS = config.getboolean('Settings', 'log_segment_status', fallback=True)
LOG_SUBMISSION_DETAILS = config.getboolean('Settings', 'log_submission_details', fallback=True)
LOG_SUBMISSION_PAYLOAD = config.getboolean('Settings', 'log_submission_payload', fallback=True)
LOG_SEGMENT_FAILURE = config.getboolean('Settings', 'log_segment_failure', fallback=True)
LOG_SOCKET_STATE = config.getboolean('Settings', 'log_socket_state', fallback=True)
LOG_RETRIES = config.getboolean('Settings', 'log_retries', fallback=True)
LOG_UI_TRANSITIONS = config.getboolean('Settings', 'log_ui_transitions', fallback=False)
LOG_ACK_PROCESSING = config.getboolean('Settings', 'log_ack_processing', fallback=True)
LOG_SEND_STATE = config.getboolean('Settings', 'log_send_state', fallback=True)
LOG_LISTENER_STATE = config.getboolean('Settings', 'log_listener_state', fallback=True)
LOG_SEARCH_QUERY = config.getboolean('Settings', 'log_search_query', fallback=True)
LOG_SEARCH_RESULTS = config.getboolean('Settings', 'log_search_results', fallback=True)
LOG_SCREEN_STATE = config.getboolean('Settings', 'log_screen_state', fallback=True)
LOG_FIELD_STATE = config.getboolean('Settings', 'log_field_state', fallback=False)
LOG_SUBMISSION_FLOW = config.getboolean('Settings', 'log_submission_flow', fallback=True)
LOG_DEBUG_FORMS = config.getboolean('Settings', 'log_debug_forms', fallback=False)
LOG_DEBUG_SYNC = config.getboolean('Settings', 'log_debug_sync', fallback=True)
LOG_CURSOR_MOVEMENT = config.getboolean('Settings', 'log_cursor_movement', fallback=False)
LOG_PACKET_TIMING = config.getboolean('Settings', 'log_packet_timing', fallback=False)
LOG_ERROR_DETAILS = config.getboolean('Settings', 'log_error_details', fallback=True)
LOG_PACKET_BUILD = config.getboolean('Settings', 'log_packet_build', fallback=True)
LOG_PACKET_PARSE = config.getboolean('Settings', 'log_packet_parse', fallback=False)
LOG_SYNC_STATE = config.getboolean('Settings', 'log_sync_state', fallback=True)
LOG_SYNC_MD5 = config.getboolean('Settings', 'log_sync_md5', fallback=False)
LOG_SYNC_FORMS = config.getboolean('Settings', 'log_sync_forms', fallback=False)
LOG_SYNC_PACKETS = config.getboolean('Settings', 'log_sync_packets', fallback=True)
LOG_PACKET_INTEGRITY = config.getboolean('Settings', 'log_packet_integrity', fallback=True)
LOG_LISTENER_RETRIES = config.getboolean('Settings', 'log_listener_retries', fallback=True)
LOG_SOCKET_RESET = config.getboolean('Settings', 'log_socket_reset', fallback=True)
LOG_CONNECTION_SUCCESS = config.getboolean('Settings', 'log_connection_success', fallback=True)
LOG_PACKET_FRAGMENTS = config.getboolean('Settings', 'log_packet_fragments', fallback=True)
LOG_SYNC_MISMATCHES = config.getboolean('Settings', 'log_sync_mismatches', fallback=True)
LOG_REDRAW_TRIGGERS = config.getboolean('Settings', 'log_redraw_triggers', fallback=False)
LOG_FORM_DELETION = config.getboolean('Settings', 'log_form_deletion', fallback=True)
LOG_SYNC_START = config.getboolean('Settings', 'log_sync_start', fallback=True)
LOG_SYNC_COMPLETION = config.getboolean('Settings', 'log_sync_completion', fallback=True)
LOG_FORM_EXIT = config.getboolean('Settings', 'log_form_exit', fallback=True)
LOG_KEY_CONTEXT = config.getboolean('Settings', 'log_key_context', fallback=False)
LOG_MODE_SWITCH = config.getboolean('Settings', 'log_mode_switch', fallback=True)
LOG_PACKET_QUEUE = config.getboolean('Settings', 'log_packet_queue', fallback=True)
LOG_LISTENER_QUEUE = config.getboolean('Settings', 'log_listener_queue', fallback=True)
LOG_UI_PACKET_HANDLING = config.getboolean('Settings', 'log_ui_packet_handling', fallback=True)
LOG_QUEUE_STATE = config.getboolean('Settings', 'log_queue_state', fallback=False)
LOG_CONNECTION_ATTEMPTS = config.getboolean('Settings', 'log_connection_attempts', fallback=True)
LOG_PACKET_DROP = config.getboolean('Settings', 'log_packet_drop', fallback=True)
LOG_THREAD_STATE = config.getboolean('Settings', 'log_thread_state', fallback=True)
LOG_COLUMN_NAVIGATION = config.getboolean('Settings', 'log_column_navigation', fallback=True)
LOG_FORM_LAYOUT = config.getboolean('Settings', 'log_form_layout', fallback=True)
LOG_ROW_MOVEMENT = config.getboolean('Settings', 'log_row_movement', fallback=True)
LOG_FORM_DISPLAY_ERROR = config.getboolean('Settings', 'log_form_display_error', fallback=True)
LOG_UI_RENDER = config.getboolean('Settings', 'log_ui_render', fallback=False)
LOG_SOCKET_ERRORS = config.getboolean('Settings', 'log_socket_errors', fallback=True)
LOG_FORM_UI_LAYOUT = config.getboolean('Settings', 'log_form_ui_layout', fallback=True)
LOG_INPUT_FIELD_STATE = config.getboolean('Settings', 'log_input_field_state', fallback=True)
LOG_KISS_FRAMING = config.getboolean('Settings', 'log_kiss_framing', fallback=True)
LOG_AX25_STATE = config.getboolean('Settings', 'log_ax25_state', fallback=True)
LOG_AX25_PACKET = config.getboolean('Settings', 'log_ax25_packet', fallback=True)
LOG_AX25_PARSE_ERROR = config.getboolean('Settings', 'log_ax25_parse_error', fallback=True)
LOG_KISS_PACKET_RECEIVED = config.getboolean('Settings', 'log_kiss_packet_received', fallback=True)
LOG_PACKET_VALIDATION = config.getboolean('Settings', 'log_packet_validation', fallback=True)
LOG_MD5_COMPARISON = config.getboolean('Settings', 'log_md5_comparison', fallback=True)
LOG_PACKET_RELAY = config.getboolean('Settings', 'log_packet_relay', fallback=True)
LOG_UI_REDRAW = config.getboolean('Settings', 'log_ui_redraw', fallback=True)
LOG_SOCKET_SEND_BYTES = config.getboolean('Settings', 'log_socket_send_bytes', fallback=True)
LOG_SOCKET_SEND_FAILURE = config.getboolean('Settings', 'log_socket_send_failure', fallback=True)
LOG_SOCKET_RECONNECT = config.getboolean('Settings', 'log_socket_reconnect', fallback=True)
LOG_SOCKET_STATUS = config.getboolean('Settings', 'log_socket_status', fallback=True)
# CHANGE v4.3.1: Added new logging types for aggressive bug hunting
LOG_SOCKET_SEND_RAW = config.getboolean('Settings', 'log_socket_send_raw', fallback=True)
LOG_SOCKET_BUFFER = config.getboolean('Settings', 'log_socket_buffer', fallback=True)
LOG_UI_COMMS_LOG = config.getboolean('Settings', 'log_ui_comms_log', fallback=True)
LOG_PACKET_SEND_TIME = config.getboolean('Settings', 'log_packet_send_time', fallback=True)
LOG_PACKET_ENQUEUE_TIME = config.getboolean('Settings', 'log_packet_enqueue_time', fallback=True)
LOG_PACKET_DEQUEUE_TIME = config.getboolean('Settings', 'log_packet_dequeue_time', fallback=True)
LOG_QUEUE_SIZE = config.getboolean('Settings', 'log_queue_size', fallback=True)
LOG_REDRAW_TIMING = config.getboolean('Settings', 'log_redraw_timing', fallback=True)
LOG_KISS_RECEIVE_BUFFER = config.getboolean('Settings', 'log_kiss_receive_buffer', fallback=True)
LOG_KISS_FRAME_TIMING = config.getboolean('Settings', 'log_kiss_frame_timing', fallback=True)
LOG_PACKET_CONTENT = config.getboolean('Settings', 'log_packet_content', fallback=True)
LOG_SOCKET_SEND_ATTEMPT = config.getboolean('Settings', 'log_socket_send_attempt', fallback=True)
LOG_UI_PACKET_DISPLAY = config.getboolean('Settings', 'log_ui_packet_display', fallback=True)

# Chunk 2 v4.3 - Global State
cursor_row, cursor_col = None, None
form_fields = {}
field_values = {}
cursor_offset = 0
current_field = None
comms_log = []
debug_log = []
screen_dirty = True
form_id = None
selecting_mode = False
show_menu = False
menu_selection = 0
mode = None
messages = []
unread_messages = False
kiss_socket = None
last_no_data = 0
sending = False
submission_result = None
syncing = False
packet_queue = queue.Queue(maxsize=100)
socket_connected = False

# Chunk 3 v4.3 - Utility Functions
def log_event(message, ui=False, debug=False, submission=False, ui_state=False, packet=False, segment=False, submission_details=False, payload=False, segment_failure=False, socket_state=False, retries=False, ui_transitions=False, ack_processing=False, send_state=False, listener_state=False, search_query=False, search_results=False, screen_state=False, field_state=False, submission_flow=False, cursor_movement=False, packet_timing=False, error_details=False, packet_build=False, packet_parse=False, sync_state=False, sync_md5=False, sync_forms=False, sync_packets=False, packet_integrity=False, listener_retries=False, socket_reset=False, connection_success=False, packet_fragments=False, sync_mismatches=False, redraw_triggers=False, form_deletion=False, sync_start=False, sync_completion=False, form_exit=False, key_context=False, mode_switch=False, packet_queue=False, listener_queue=False, ui_packet_handling=False, queue_state=False, connection_attempts=False, packet_drop=False, thread_state=False, column_navigation=False, form_layout=False, row_movement=False, form_display_error=False, ui_render=False, socket_errors=False, form_ui_layout=False, input_field_state=False, kiss_framing=False, ax25_state=False, ax25_packet=False, ax25_parse_error=False, kiss_packet_received=False, packet_validation=False, md5_comparison=False, packet_relay=False, ui_redraw=False, socket_send_bytes=False, socket_send_failure=False, socket_reconnect=False, socket_status=False, socket_send_raw=False, socket_buffer=False, ui_comms_log=False, packet_send_time=False, packet_enqueue_time=False, packet_dequeue_time=False, queue_size=False, redraw_timing=False, kiss_receive_buffer=False, kiss_frame_timing=False, packet_content=False, socket_send_attempt=False, ui_packet_display=False):  # CHANGE v4.3.1: Added new logging params
    global screen_dirty
    timestamp = time.ctime()
    log_line = f"{timestamp}: {message}"
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    with open(LOG_FILE, 'a') as f:
        f.write(log_line + '\n')
    if ui:
        comms_log.append((message, timestamp))
        if len(comms_log) > 20:
            comms_log.pop(0)
        screen_dirty = True
        if LOG_REDRAW_TRIGGERS:
            log_event("screen_dirty set by log_event (UI log)", redraw_triggers=True)
        if LOG_UI_COMMS_LOG:  # CHANGE v4.3.1: Log Comms Log updates
            log_event(f"Comms Log updated: {message}", ui_comms_log=True)
    if debug and LOG_DEBUG: debug_log.append((message, timestamp))
    if submission and LOG_SUBMISSION: debug_log.append((message, timestamp))
    if ui_state and LOG_UI_STATE: debug_log.append((message, timestamp))
    if packet and LOG_PACKET_DETAILS: debug_log.append((message, timestamp))
    if segment and LOG_SEGMENT_STATUS: debug_log.append((message, timestamp))
    if submission_details and LOG_SUBMISSION_DETAILS: debug_log.append((message, timestamp))
    if payload and LOG_SUBMISSION_PAYLOAD: debug_log.append((message, timestamp))
    if segment_failure and LOG_SEGMENT_FAILURE: debug_log.append((message, timestamp))
    if socket_state and LOG_SOCKET_STATE: debug_log.append((message, timestamp))
    if retries and LOG_RETRIES: debug_log.append((message, timestamp))
    if ui_transitions and LOG_UI_TRANSITIONS: debug_log.append((message, timestamp))
    if ack_processing and LOG_ACK_PROCESSING: debug_log.append((message, timestamp))
    if send_state and LOG_SEND_STATE: debug_log.append((message, timestamp))
    if listener_state and LOG_LISTENER_STATE: debug_log.append((message, timestamp))
    if search_query and LOG_SEARCH_QUERY: debug_log.append((message, timestamp))
    if search_results and LOG_SEARCH_RESULTS: debug_log.append((message, timestamp))
    if screen_state and LOG_SCREEN_STATE: debug_log.append((message, timestamp))
    if field_state and LOG_FIELD_STATE: debug_log.append((message, timestamp))
    if submission_flow and LOG_SUBMISSION_FLOW: debug_log.append((message, timestamp))
    if cursor_movement and LOG_CURSOR_MOVEMENT: debug_log.append((message, timestamp))
    if packet_timing and LOG_PACKET_TIMING: debug_log.append((message, timestamp))
    if error_details and LOG_ERROR_DETAILS: debug_log.append((message, timestamp))
    if packet_build and LOG_PACKET_BUILD: debug_log.append((message, timestamp))
    if packet_parse and LOG_PACKET_PARSE: debug_log.append((message, timestamp))
    if sync_state and LOG_SYNC_STATE: debug_log.append((message, timestamp))
    if sync_md5 and LOG_SYNC_MD5: debug_log.append((message, timestamp))
    if sync_forms and LOG_SYNC_FORMS: debug_log.append((message, timestamp))
    if sync_packets and LOG_SYNC_PACKETS: debug_log.append((message, timestamp))
    if packet_integrity and LOG_PACKET_INTEGRITY: debug_log.append((message, timestamp))
    if listener_retries and LOG_LISTENER_RETRIES: debug_log.append((message, timestamp))
    if socket_reset and LOG_SOCKET_RESET: debug_log.append((message, timestamp))
    if connection_success and LOG_CONNECTION_SUCCESS: debug_log.append((message, timestamp))
    if packet_fragments and LOG_PACKET_FRAGMENTS: debug_log.append((message, timestamp))
    if sync_mismatches and LOG_SYNC_MISMATCHES: debug_log.append((message, timestamp))
    if redraw_triggers and LOG_REDRAW_TRIGGERS: debug_log.append((message, timestamp))
    if form_deletion and LOG_FORM_DELETION: debug_log.append((message, timestamp))
    if sync_start and LOG_SYNC_START: debug_log.append((message, timestamp))
    if sync_completion and LOG_SYNC_COMPLETION: debug_log.append((message, timestamp))
    if form_exit and LOG_FORM_EXIT: debug_log.append((message, timestamp))
    if key_context and LOG_KEY_CONTEXT: debug_log.append((message, timestamp))
    if mode_switch and LOG_MODE_SWITCH: debug_log.append((message, timestamp))
    if packet_queue and LOG_PACKET_QUEUE: debug_log.append((message, timestamp))
    if listener_queue and LOG_LISTENER_QUEUE: debug_log.append((message, timestamp))
    if ui_packet_handling and LOG_UI_PACKET_HANDLING: debug_log.append((message, timestamp))
    if queue_state and LOG_QUEUE_STATE: debug_log.append((message, timestamp))
    if connection_attempts and LOG_CONNECTION_ATTEMPTS: debug_log.append((message, timestamp))
    if packet_drop and LOG_PACKET_DROP: debug_log.append((message, timestamp))
    if thread_state and LOG_THREAD_STATE: debug_log.append((message, timestamp))
    if column_navigation and LOG_COLUMN_NAVIGATION: debug_log.append((message, timestamp))
    if form_layout and LOG_FORM_LAYOUT: debug_log.append((message, timestamp))
    if row_movement and LOG_ROW_MOVEMENT: debug_log.append((message, timestamp))
    if form_display_error and LOG_FORM_DISPLAY_ERROR: debug_log.append((message, timestamp))
    if ui_render and LOG_UI_RENDER: debug_log.append((message, timestamp))
    if socket_errors and LOG_SOCKET_ERRORS: debug_log.append((message, timestamp))
    if form_ui_layout and LOG_FORM_UI_LAYOUT: debug_log.append((message, timestamp))
    if input_field_state and LOG_INPUT_FIELD_STATE: debug_log.append((message, timestamp))
    if kiss_framing and LOG_KISS_FRAMING: debug_log.append((message, timestamp))
    if ax25_state and LOG_AX25_STATE: debug_log.append((message, timestamp))
    if ax25_packet and LOG_AX25_PACKET: debug_log.append((message, timestamp))
    if ax25_parse_error and LOG_AX25_PARSE_ERROR: debug_log.append((message, timestamp))
    if kiss_packet_received and LOG_KISS_PACKET_RECEIVED: debug_log.append((message, timestamp))
    if packet_validation and LOG_PACKET_VALIDATION: debug_log.append((message, timestamp))
    if md5_comparison and LOG_MD5_COMPARISON: debug_log.append((message, timestamp))
    if packet_relay and LOG_PACKET_RELAY: debug_log.append((message, timestamp))
    if ui_redraw and LOG_UI_REDRAW: debug_log.append((message, timestamp))
    if socket_send_bytes and LOG_SOCKET_SEND_BYTES: debug_log.append((message, timestamp))
    if socket_send_failure and LOG_SOCKET_SEND_FAILURE: debug_log.append((message, timestamp))
    if socket_reconnect and LOG_SOCKET_RECONNECT: debug_log.append((message, timestamp))
    if socket_status and LOG_SOCKET_STATUS: debug_log.append((message, timestamp))
    # CHANGE v4.3.1: Added new logging types
    if socket_send_raw and LOG_SOCKET_SEND_RAW: debug_log.append((message, timestamp))
    if socket_buffer and LOG_SOCKET_BUFFER: debug_log.append((message, timestamp))
    if ui_comms_log and LOG_UI_COMMS_LOG: debug_log.append((message, timestamp))
    if packet_send_time and LOG_PACKET_SEND_TIME: debug_log.append((message, timestamp))
    if packet_enqueue_time and LOG_PACKET_ENQUEUE_TIME: debug_log.append((message, timestamp))
    if packet_dequeue_time and LOG_PACKET_DEQUEUE_TIME: debug_log.append((message, timestamp))
    if queue_size and LOG_QUEUE_SIZE: debug_log.append((message, timestamp))
    if redraw_timing and LOG_REDRAW_TIMING: debug_log.append((message, timestamp))
    if kiss_receive_buffer and LOG_KISS_RECEIVE_BUFFER: debug_log.append((message, timestamp))
    if kiss_frame_timing and LOG_KISS_FRAME_TIMING: debug_log.append((message, timestamp))
    if packet_content and LOG_PACKET_CONTENT: debug_log.append((message, timestamp))
    if socket_send_attempt and LOG_SOCKET_SEND_ATTEMPT: debug_log.append((message, timestamp))
    if ui_packet_display and LOG_UI_PACKET_DISPLAY: debug_log.append((message, timestamp))

def log_comms(message):
    log_event(message, ui=True)
    if LOG_PACKET_CONTENT:  # CHANGE v4.3.1: Log full packet content
        log_event(f"Packet content in Comms Log: {message}", packet_content=True)

def backup_script():
    script_path = os.path.realpath(__file__)
    base_name = os.path.basename(script_path)
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_name = f"{base_name.rsplit('.', 1)[0]}_{timestamp}.{base_name.rsplit('.', 1)[1]}"
    backup_path = os.path.join(BACKUP_DIR, backup_name)
    try:
        shutil.copy2(script_path, backup_path)
        log_event(f"Backed up to {backup_path}", ui=False)  # Always on
    except PermissionError as e:
        log_event(f"Backup failed: {str(e)} - proceeding without backup", ui=False, error_details=True)

def init_colors():
    log_event("Initializing colors", debug=True)
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)
    return 1, 2, 3, 4

def get_callsign():
    global CALLSIGN
    CALLSIGN = config.get('Settings', 'callsign', fallback='CLT001')
    while not CALLSIGN:
        if LOG_CALLSIGN_PROMPT:
            log_event("Prompting for callsign", ui=False)
        print("Enter Your Callsign (e.g., KB8XYZ, required): ", end='', flush=True)
        CALLSIGN = input().strip().upper()
        if not CALLSIGN:
            print("Callsign cannot be empty—try again")
            time.sleep(1)
        else:
            config['Settings']['callsign'] = CALLSIGN
            with open(CONFIG_FILE, 'w') as configfile:
                config.write(configfile)
            log_event(f"Callsign set to {CALLSIGN}", ui=False)
    return CALLSIGN

def load_form_data(form_id):
    file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
    if not os.path.exists(file_path):
        log_event(f"Form file not found: {file_path}", debug=True)
        return None
    form_data = {'desc': '', 'fields': {}}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('desc:'):
                form_data['desc'] = line.split(':', 1)[1]
            elif ',' in line and len(line.split(',')) == 5:
                fid, label, row, col, length = line.split(',')
                form_data['fields'][fid] = {
                    'label': label,
                    'row': int(row),
                    'col': int(col),
                    'len': int(length)
                }
            else:
                log_event(f"Invalid line in {form_id}.txt: {line}", debug=True)
    if LOG_FORM_LAYOUT:
        log_event(f"Loaded form {form_id}: {form_data['fields']}", form_layout=True)
    return form_data

def update_form_lengths():
    if not os.path.exists(FORMS_DIR) or not os.listdir(FORMS_DIR):
        log_event("No forms yet—awaiting server", debug=True)
        return
    log_event("TEMPORARY: Starting form length update to 256", debug=True)
    for form_file in os.listdir(FORMS_DIR):
        if form_file.endswith('.txt'):
            file_path = os.path.join(FORMS_DIR, form_file)
            lines = []
            with open(file_path, 'r') as f:
                for line in f:
                    if line.startswith('desc:'):
                        lines.append(line.strip())
                    elif ',' in line and len(line.split(',')) == 5:
                        fid, label, row, col, _ = line.strip().split(',')
                        lines.append(f"{fid},{label},{row},{col},256")
                    else:
                        log_event(f"Skipping invalid line in {form_file}: {line.strip()}", debug=True)
            with open(file_path, 'w') as f:
                f.write('\n'.join(lines) + '\n')
            if LOG_DEBUG_FORMS:
                log_event(f"TEMPORARY: Updated {form_file} fields to len=256", debug=True)
    log_event("TEMPORARY: Form length update complete", debug=True)

def hash_forms_dir():
    hasher = hashlib.md5()
    if os.path.exists(FORMS_DIR):
        for filename in sorted(glob.glob(os.path.join(FORMS_DIR, '*.txt'))):
            with open(filename, 'rb') as f:
                content = f.read()
                hasher.update(content)
            if LOG_SYNC_FORMS:
                with open(filename, 'r') as f:
                    log_event(f"Hashing {filename}: {f.read()[:50]}", sync_forms=True)
    forms_data = hasher.digest()
    md5_hash = hasher.hexdigest()
    if LOG_SYNC_MD5:
        log_event(f"Forms data before hash (length): {len(forms_data)}", sync_md5=True)
        log_event(f"Computed client MD5: {md5_hash}", sync_md5=True)
    return md5_hash

def build_forms_index():
    index_parts = []
    if os.path.exists(FORMS_DIR):
        for fname in sorted(os.listdir(FORMS_DIR)):
            if fname.endswith('.txt'):
                file_path = os.path.join(FORMS_DIR, fname)
                with open(file_path, 'r') as f:
                    content = f.read()
                    md5 = hashlib.md5(content.strip().encode()).hexdigest()
                index_parts.append(f"{fname[:-4]}:{md5}")
                if LOG_SYNC_FORMS:
                    log_event(f"Indexed {fname[:-4]} with MD5: {md5}", sync_forms=True)
    index = "|".join(index_parts)
    if LOG_SYNC_PACKETS:
        log_event(f"Built forms index: {index}", sync_packets=True)
    return index

if os.path.exists(LOG_FILE):
    os.remove(LOG_FILE)
    log_event("Deleted old log file", ui=False)
backup_script()
CALLSIGN = get_callsign()

# Chunk 4 v4.3 - Core Display Functions
def move_cursor(stdscr, row, col):
    global cursor_row, cursor_col, screen_dirty
    cursor_row, cursor_col = min(max(row, 0), ROWS-1), min(max(col, 0), COLS-1)
    screen_dirty = True
    if LOG_REDRAW_TRIGGERS:
        log_event("screen_dirty set by move_cursor", redraw_triggers=True)
    redraw_screen(stdscr)

def redraw_screen(stdscr, sending=False):
    global screen_dirty, form_id, selecting_mode, form_fields, current_field, show_menu, menu_selection, cursor_offset, unread_messages, mode, submission_result, socket_connected
    if not screen_dirty:
        return
    redraw_start = time.time()  # CHANGE v4.3.1: Track redraw timing
    stdscr.erase()
    stdscr.clear()
    RED, GREEN, YELLOW, LIGHT_BLUE = 1, 2, 3, 4
    border = "=" * (COLS - 2)
    max_y, max_x = stdscr.getmaxyx()
    stdscr.addstr(0, 0, border, curses.color_pair(RED))
    if form_fields and any(form_fields) and mode in ('I', 'S'):
        max_form_row = 18
        form_id_display = form_fields.get(next(iter(form_fields), None), {}).get('form_id', '')
        form_data = load_form_data(form_id_display)
        stdscr.addstr(1, 2, f"{'Insert' if mode == 'I' else 'Search'} Form: {form_data['desc'].split('~')[0][:COLS-14]}" if form_data else '', curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(2, 3, form_id_display, curses.color_pair(GREEN))
        stdscr.addstr(2, 41, form_data['desc'].split('~')[0][:COLS-42] if form_data else '', curses.color_pair(GREEN))
        sorted_fields = sorted([fid for fid in form_fields.keys() if fid != 'L01' and fid != 'R01'], key=lambda x: (form_fields[x]['row'], form_fields[x]['col']))
        for fid in sorted_fields:
            info = form_fields[fid]
            label = info['label']
            text = field_values.get(fid, '')
            color = YELLOW if fid == current_field else GREEN
            col = 14 if fid.startswith('L') else 52
            label_col = 3 if fid.startswith('L') else 41
            max_len = 25
            try:
                stdscr.addstr(info['row'], label_col, label[:10], curses.color_pair(GREEN))
                stdscr.addstr(info['row'], col, "[", curses.color_pair(GREEN))
                stdscr.addstr(info['row'], col + 1, text.ljust(max_len)[:max_len], curses.color_pair(color))
                stdscr.addstr(info['row'], col + max_len + 1, "]", curses.color_pair(GREEN))
                if fid == current_field and current_field not in ('submit', 'cancel'):
                    cursor_x = col + 1 + min(cursor_offset, max_len)
                    if info['row'] < max_form_row and cursor_x < (38 if col == 14 else 76):
                        stdscr.addstr(info['row'], cursor_x, '■', curses.color_pair(YELLOW))
                if LOG_INPUT_FIELD_STATE and fid == current_field:
                    log_event(f"Field {fid}: label={label}, value={text}, cursor_offset={cursor_offset}", input_field_state=True)
            except Exception as e:
                if LOG_FORM_DISPLAY_ERROR:
                    log_event(f"Display error for {fid} at row {info['row']}, col {col}: {str(e)}", form_display_error=True)
        submit_text = "(S)ubmit"
        cancel_text = "(C)ancel"
        total_width = len(submit_text) + len(cancel_text) + 2
        start_x = (max_x - total_width) // 2
        stdscr.addstr(19, start_x, submit_text, curses.color_pair(LIGHT_BLUE if current_field != 'submit' else LIGHT_BLUE | curses.A_REVERSE))
        stdscr.addstr(19, start_x + len(submit_text) + 2, cancel_text, curses.color_pair(LIGHT_BLUE if current_field != 'cancel' else LIGHT_BLUE | curses.A_REVERSE))
        if current_field == 'submit':
            stdscr.addstr(19, start_x + 1, '■', curses.color_pair(LIGHT_BLUE))
        elif current_field == 'cancel':
            stdscr.addstr(19, start_x + len(submit_text) + 3, '■', curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(21, 2, "= Enter=Next Esc=Back Navigate=Use arrow keys =", curses.color_pair(GREEN))
        if sending:
            msg = "Sending. Please wait."
            y = max_y // 2
            x = (max_x - len(msg)) // 2
            stdscr.addstr(y, x, msg, curses.color_pair(YELLOW) | curses.A_BOLD)
        if LOG_FORM_UI_LAYOUT:
            log_event(f"Form UI layout: top={form_id_display} {form_data['desc'] if form_data else ''}, fields={[(fid, info['row'], info['col']) for fid, info in form_fields.items()]}", form_ui_layout=True)
    elif selecting_mode and form_id:
        stdscr.addstr(1, 2, f"Selected {form_id}", curses.color_pair(GREEN))
        stdscr.addstr(2, 2, "S=Search, I=Insert", curses.color_pair(GREEN))
        stdscr.addstr(21, 2, "= Commands: S=Search I=Insert Esc=Back =", curses.color_pair(GREEN))
    elif show_menu and menu_selection == 3:
        stdscr.addstr(1, 2, "Messages", curses.color_pair(GREEN))
        line = 3
        for msg in messages[-18:]:
            if line < 19:
                prefix, from_call, text = msg.split(':', 2)
                if prefix == 'MSG':
                    _, to_call = from_call, text.split(':', 1)[0]
                    text = text.split(':', 1)[1]
                    if to_call == CALLSIGN:
                        stdscr.addstr(line, 2, f"{from_call} -> {text[:40]}", curses.color_pair(GREEN))
                elif prefix == 'CHAT':
                    stdscr.addstr(line, 2, f"{from_call}: {text[:40]}", curses.color_pair(GREEN))
                line += 1
        stdscr.addstr(21, 2, "= Commands: Esc=Back =", curses.color_pair(GREEN))
        unread_messages = False
    else:
        stdscr.addstr(1, 2, f"Callsign: {CALLSIGN}", curses.color_pair(GREEN))
        form_files = set(f[:-4] for f in os.listdir(FORMS_DIR) if f.endswith('.txt'))
        form_list = sorted(form_files)
        form_count = len(form_list)
        stdscr.addstr(2, 2, "Select a form:" + (" *" if unread_messages else ""), curses.color_pair(GREEN))
        for i, local_form_id in enumerate(form_list[:15], 1):
            form_data = load_form_data(local_form_id)
            desc = form_data['desc'].split('~')[0] if form_data else 'Unknown'
            desc = desc[:COLS-14]
            stdscr.addstr(i + 2, 4, f"{i}: {local_form_id} - {desc}", curses.color_pair(GREEN))
        stdscr.addstr(1, 42, f"Comms Log [{'C' if socket_connected else 'D'}]", curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(2, 42, "(R)econnect  " + "= " * 15, curses.color_pair(RED))
        for i, (msg, ts) in enumerate(comms_log[-18:], start=3):
            stdscr.addstr(i, 42, f"{msg[:36]}", curses.color_pair(GREEN))
            if LOG_UI_PACKET_DISPLAY:  # CHANGE v4.3.1: Log packet display in UI
                log_event(f"Packet displayed in Comms Log: {msg}", ui_packet_display=True)
        if submission_result:
            msg = f"Submission: {submission_result}"
            stdscr.addstr(20, (max_x - len(msg)) // 2, msg, curses.color_pair(YELLOW) | curses.A_BOLD)
            time.sleep(2)
            submission_result = None
            screen_dirty = True
            if LOG_REDRAW_TRIGGERS:
                log_event("screen_dirty set by submission_result clear", redraw_triggers=True)
        if show_menu:
            menu_options = [
                ("Main Screen", True),
                ("Debug Control", True),
                ("Forms Management", False),
                ("Messages", True),
                ("Group Chat", True),
                ("Quit", True)
            ]
            stdscr.addstr(6, 20, "+====================+", curses.color_pair(RED))
            for i, (option, active) in enumerate(menu_options):
                color = GREEN if active else RED
                if i == menu_selection:
                    stdscr.addstr(7 + i, 20, f"| {option:<18} |", curses.color_pair(color) | curses.A_REVERSE)
                else:
                    stdscr.addstr(7 + i, 20, f"| {option:<18} |", curses.color_pair(color))
            stdscr.addstr(13, 20, "| Up/Down=Move       |", curses.color_pair(GREEN))
            stdscr.addstr(14, 20, "| Enter=Sel Esc=Back |", curses.color_pair(GREEN))
            stdscr.addstr(15, 20, "+====================+", curses.color_pair(RED))
        stdscr.addstr(22, 0, border, curses.color_pair(RED))
        stdscr.addstr(21, 0, f"= Commands: D=Menu R=Reconnect 1-{min(form_count, 15)}=Select =", curses.color_pair(GREEN))
    stdscr.refresh()
    screen_dirty = False
    if LOG_UI_RENDER:
        global last_ui_render_log
        if 'last_ui_render_log' not in globals():
            last_ui_render_log = 0
        now = time.time()
        if now - last_ui_render_log >= 1.0:
            log_event(f"Rendered screen: form_id={form_id}, mode={mode}", ui_render=True)
            last_ui_render_log = now
    if LOG_UI_REDRAW:
        log_event(f"Full UI redraw: form_id={form_id}, mode={mode}, fields={list(form_fields.keys())}", ui_redraw=True)
    if LOG_REDRAW_TIMING:  # CHANGE v4.3.1: Log redraw timing
        log_event(f"Redraw took {time.time() - redraw_start:.3f}s", redraw_timing=True)
    if LOG_FORM_LAYOUT and form_fields:
        log_event(f"Form {form_id} layout rendered: {form_fields}", form_layout=True)

# Chunk 5 v4.3 - Screen Transition Functions
def display_form_list(stdscr):
    global comms_log, screen_dirty, form_id, selecting_mode, form_fields, current_field, show_menu, mode, submission_result
    if LOG_UI_TRANSITIONS:
        log_event("Transition to form list", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event("Screen state: Displaying form list", screen_state=True)
    form_id = None
    selecting_mode = False
    form_fields = {}
    current_field = None
    show_menu = False
    mode = None
    submission_result = None
    screen_dirty = True
    if LOG_REDRAW_TRIGGERS:
        log_event("screen_dirty set by display_form_list", redraw_triggers=True)
    redraw_screen(stdscr)

def display_mode_prompt(stdscr, selected_form_id):
    global comms_log, screen_dirty, form_id, selecting_mode
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to mode prompt for {selected_form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying mode prompt for {selected_form_id}", screen_state=True)
    form_id = selected_form_id
    selecting_mode = True
    screen_dirty = True
    if LOG_REDRAW_TRIGGERS:
        log_event("screen_dirty set by display_mode_prompt", redraw_triggers=True)
    redraw_screen(stdscr)

def load_form(stdscr, form_id):
    global form_fields, field_values, cursor_row, cursor_col, cursor_offset, current_field, screen_dirty, selecting_mode, mode
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to form {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Loading form {form_id} in mode {mode}", screen_state=True)
    stdscr.erase()
    stdscr.clear()
    form_data = load_form_data(form_id)
    if form_data:
        form_fields = form_data['fields']
        for fid in form_fields:
            form_fields[fid]['form_id'] = form_id
        field_values = {fid: '' for fid in form_fields}
        first_field = min(form_fields.keys(), key=lambda x: (form_fields[x]['row'], form_fields[x]['col']))
        current_field = first_field
        cursor_row, cursor_col = form_fields[first_field]['row'], form_fields[first_field]['col'] + 1
        cursor_offset = 0
        selecting_mode = False
        screen_dirty = True
        if LOG_REDRAW_TRIGGERS:
            log_event("screen_dirty set by load_form", redraw_triggers=True)
        redraw_screen(stdscr)

# Chunk 6 v4.3 - AX.25 Communication
# Commented out TCP and AGWPE code retained from v4.0
"""
# Chunk 6 v3.6 - Server Communication
def radio_send(packet):
    if COMM_MODE == 'RADIO':
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((AGW_HOST, AGW_PORT))
            s.send(packet.encode())
            log_comms(f"AGWPE sent: {packet[:50]}")

def send_to_server(stdscr, data):
    global comms_log, screen_dirty, mode, listener_socket, sending, submission_result
    # ... [rest of send_to_server code from v3.6] ...
    return ""

def server_listener(stdscr, stop_event):
    global comms_log, screen_dirty, messages, unread_messages, listener_socket, last_no_data, sending, submission_result, syncing, packet_queue
    # ... [rest of server_listener code from v3.6] ...
"""

def send_to_kiss(stdscr, data):
    global comms_log, screen_dirty, mode, kiss_socket, sending, submission_result, socket_connected
    send_start = time.time()
    sending = True
    if LOG_SEND_STATE:
        log_event("Send initiated", send_state=True)
    if LOG_SUBMISSION_FLOW:
        log_event("Starting submission process", submission_flow=True)

    server_callsign = 'SVR001'
    if data.startswith('INDEX:'):
        function = 'UPDATE'
        form_id = 'NONE'
        payload = data.split(':', 2)[2]
        if LOG_SYNC_PACKETS:
            log_event(f"Preparing sync UPDATE packet with payload: {payload[:50]}", sync_packets=True)
    elif data.startswith('REQ_UPDATE:'):
        function = 'REQUEST'
        form_id = 'NONE'
        payload = ''
    else:
        function = 'SEARCH' if mode == 'S' else 'INSERT'
        form_id = form_fields[next(iter(form_fields))]['form_id'] if form_fields else 'NONE'
        payload = '|'.join(f"{fid}{value.rstrip()}" for fid, value in field_values.items()) if form_fields else ''
        if LOG_SUBMISSION_PAYLOAD and payload:
            log_event(f"Submission payload: {payload}", payload=True)

    full_packet = f"0{CALLSIGN}>{server_callsign}:{function}|{CALLSIGN}|{form_id}|{payload}\n"
    if LOG_PACKET_BUILD:
        log_event(f"Built packet: {full_packet.strip()}", packet_build=True)
    log_comms(full_packet.strip())
    if LOG_PACKET_INTEGRITY:
        log_event(f"Send packet structure: len={len(full_packet)}, newlines={full_packet.count('\n')}", packet_integrity=True)

    segments = [full_packet]
    if len(full_packet) > PACLEN:
        header = f"0{CALLSIGN}>{server_callsign}:{function}|{CALLSIGN}|{form_id}|"
        chunk_size = PACLEN - len(header) - 6
        payload_chunks = [payload[i:i+chunk_size] for i in range(0, len(payload), chunk_size)]
        segments = [f"{header}{seq}:{len(payload_chunks)}|{chunk}\n" for seq, chunk in enumerate(payload_chunks, 1)]
        if LOG_PACKET_FRAGMENTS:
            log_event(f"Packet fragmented into {len(segments)} segments", packet_fragments=True)

    total = len(segments)
    retry_attempts = 0
    max_send_retries = 3
    while retry_attempts < max_send_retries:
        try:
            if COMM_MODE == 'KISS':
                if kiss_socket and kiss_socket.fileno() >= 0:
                    s = kiss_socket
                    if LOG_SOCKET_STATE:
                        log_event("Socket state: Using existing kiss_socket", socket_state=True)
                else:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(10)
                    s.connect((FAKE_DIREWOLF_HOST, FAKE_DIREWOLF_PORT))
                    if LOG_SOCKET_STATE:
                        log_event(f"Socket state: New socket connected to {FAKE_DIREWOLF_HOST}:{FAKE_DIREWOLF_PORT}", socket_state=True)
                    if LOG_CONNECTION_SUCCESS:
                        log_event(f"Connected to {FAKE_DIREWOLF_HOST}:{FAKE_DIREWOLF_PORT}", connection_success=True)
                if function in ('INSERT', 'SEARCH'):
                    redraw_screen(stdscr, sending=True)
                    stdscr.refresh()
                for seq, segment in enumerate(segments, 1):
                    kiss_frame = b'\xC0' + segment.encode() + b'\xC0'
                    if LOG_SOCKET_SEND_ATTEMPT:  # CHANGE v4.3.1: Log send attempt
                        log_event(f"Attempting to send segment {seq}/{total}", socket_send_attempt=True)
                    if LOG_SOCKET_SEND_RAW:  # CHANGE v4.3.1: Log raw bytes
                        log_event(f"Raw bytes to send: {kiss_frame.hex()}", socket_send_raw=True)
                    bytes_sent = s.send(kiss_frame)
                    if LOG_SOCKET_SEND_BYTES:
                        log_event(f"Socket send bytes: {bytes_sent} for segment {seq}/{total}", socket_send_bytes=True)
                    if LOG_PACKET_SEND_TIME:  # CHANGE v4.3.1: Log send timestamp
                        log_event(f"Segment {seq}/{total} sent at {time.time()}", packet_send_time=True)
                    if bytes_sent != len(kiss_frame):
                        raise socket.error(f"Partial send: {bytes_sent}/{len(kiss_frame)} bytes")
                    log_comms(segment.strip())
                    if LOG_KISS_FRAMING:
                        log_event(f"KISS frame sent: {kiss_frame.hex()}", kiss_framing=True)
                    if LOG_SEGMENT_STATUS:
                        log_event(f"Segment {seq}/{total} sent: {segment[:50]}", segment=True)
                if s != kiss_socket:
                    s.close()
                    if LOG_SOCKET_STATE:
                        log_event("Socket state: Temporary send socket closed", socket_state=True)
                if LOG_SEND_STATE:
                    log_event("Send completed, awaiting response via listener", send_state=True)
                sending = False
                break
        except Exception as e:
            retry_attempts += 1
            log_event(f"Send failed (attempt {retry_attempts}/{max_send_retries}): {str(e)}", debug=True, socket_errors=True, socket_send_failure=True)
            if LOG_ERROR_DETAILS:
                log_event(f"Send error details: {traceback.format_exc()}", error_details=True)
            if LOG_SEGMENT_FAILURE:
                log_event(f"Segment {seq if 'seq' in locals() else 'unknown'}/{total} failed: {str(e)}", segment_failure=True)
            if retry_attempts < max_send_retries:
                time.sleep(1)
                if kiss_socket:
                    kiss_socket.close()
                    kiss_socket = None
                    if LOG_SOCKET_STATE:
                        log_event("Socket state: Closed for retry", socket_state=True)
            else:
                submission_result = "Failed"
                sending = False
                screen_dirty = True
                if LOG_REDRAW_TRIGGERS:
                    log_event("screen_dirty set by send error", redraw_triggers=True)
                display_form_list(stdscr)
                if LOG_SEND_STATE:
                    log_event(f"Send failed after {max_send_retries} attempts: {str(e)}", send_state=True)
                return ""
    return ""

def kiss_listener(stdscr, stop_event):
    global comms_log, screen_dirty, messages, unread_messages, kiss_socket, last_no_data, sending, submission_result, syncing, packet_queue, socket_connected
    log_event(f"Starting KISS listener, connecting to {FAKE_DIREWOLF_HOST}:{FAKE_DIREWOLF_PORT}", debug=True, listener_state=True, thread_state=True)
    buffer = b""
    last_timeout_log = 0
    retry_delay = RETRY_DELAY
    max_delay = 60
    while not stop_event.is_set():
        try:
            if not kiss_socket or kiss_socket.fileno() < 0:
                log_event("KISS socket invalid, creating new one", debug=True, socket_state=True)
                kiss_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                kiss_socket.settimeout(5)
                if LOG_CONNECTIVITY:
                    log_event(f"KISS connecting to {FAKE_DIREWOLF_HOST}:{FAKE_DIREWOLF_PORT}", debug=True)
                if LOG_SOCKET_STATE:
                    log_event(f"Socket state: Creating new socket for {FAKE_DIREWOLF_HOST}:{FAKE_DIREWOLF_PORT}", socket_state=True)
                if LOG_LISTENER_STATE:
                    log_event("KISS listener socket created", listener_state=True)

                for attempt in range(MAX_RETRIES):
                    try:
                        log_event(f"Attempting connection to {FAKE_DIREWOLF_HOST}:{FAKE_DIREWOLF_PORT} (attempt {attempt + 1}/{MAX_RETRIES})", connection_attempts=True)
                        kiss_socket.connect((FAKE_DIREWOLF_HOST, FAKE_DIREWOLF_PORT))
                        socket_connected = True
                        if LOG_CONNECTIVITY:
                            log_event(f"Connected to {FAKE_DIREWOLF_HOST}:{FAKE_DIREWOLF_PORT}", connection_success=True)
                        if LOG_RETRIES:
                            log_event(f"Retry {attempt + 1}/{MAX_RETRIES} succeeded", retries=True)
                        if LOG_LISTENER_RETRIES:
                            log_event(f"Listener connected on attempt {attempt + 1}", listener_retries=True)
                        if LOG_SOCKET_STATE:
                            log_event(f"Socket state: Connected on attempt {attempt + 1}", socket_state=True)
                        if LOG_CONNECTION_SUCCESS:
                            log_event(f"Successfully connected to {FAKE_DIREWOLF_HOST}:{FAKE_DIREWOLF_PORT}", connection_success=True)
                        if LOG_AX25_STATE:
                            log_event("AX.25 state: Connected to Fake Direwolf", ax25_state=True)
                        if LOG_SOCKET_STATUS:
                            log_event("Socket status: Connected", socket_status=True)
                        retry_delay = RETRY_DELAY
                        break
                    except ConnectionRefusedError:
                        if LOG_CONNECTIVITY:
                            log_event(f"Connection failed, retrying ({attempt + 1}/{MAX_RETRIES})", debug=True)
                        if LOG_RETRIES:
                            log_event(f"Connection refused, retry {attempt + 1}/{MAX_RETRIES}", retries=True)
                        if attempt == MAX_RETRIES - 1:
                            if LOG_CONNECTIVITY:
                                log_event(f"Max retries reached, backing off for {retry_delay}s", debug=True)
                            socket_connected = False
                            if LOG_SOCKET_STATUS:
                                log_event("Socket status: Disconnected after max retries", socket_status=True)
                            time.sleep(retry_delay)
                            retry_delay = min(retry_delay * 2, max_delay)
                        else:
                            time.sleep(1)
                    except Exception as e:
                        log_event(f"Unexpected connect error: {str(e)}", debug=True, socket_errors=True)
                        kiss_socket.close()
                        kiss_socket = None
                        socket_connected = False
                        if LOG_SOCKET_STATUS:
                            log_event("Socket status: Disconnected due to error", socket_status=True)
                        time.sleep(retry_delay)
                        retry_delay = min(retry_delay * 2, max_delay)
                        break
                else:
                    time.sleep(retry_delay)
                    retry_delay = min(retry_delay * 2, max_delay)
                    continue

            while not stop_event.is_set():
                try:
                    if kiss_socket:
                        data = kiss_socket.recv(512)
                        if data:
                            buffer += data
                            if LOG_KISS_PACKET_RECEIVED:
                                log_event(f"KISS data received: {data.hex()[:50]}...", kiss_packet_received=True)
                            if LOG_KISS_RECEIVE_BUFFER:  # CHANGE v4.3.1: Log receive buffer
                                log_event(f"Receive buffer updated: {buffer.hex()} (len={len(buffer)})", kiss_receive_buffer=True)
                            while b'\xC0' in buffer[1:]:
                                start = buffer.find(b'\xC0')
                                end = buffer.find(b'\xC0', start + 1)
                                if end == -1:
                                    break
                                frame_start_time = time.time()  # CHANGE v4.3.1: Track frame timing
                                frame = buffer[start:end + 1]
                                buffer = buffer[end + 1:]
                                if LOG_KISS_FRAMING:
                                    log_event(f"KISS frame extracted: {frame.hex()}", kiss_framing=True)
                                if LOG_KISS_FRAME_TIMING:  # CHANGE v4.3.1: Log frame extraction timing
                                    log_event(f"Frame extracted in {time.time() - frame_start_time:.3f}s", kiss_frame_timing=True)
                                if LOG_KISS_RECEIVE_BUFFER:  # CHANGE v4.3.1: Log buffer after split
                                    log_event(f"Buffer after frame split: {buffer.hex()} (len={len(buffer)})", kiss_receive_buffer=True)
                                if not frame.startswith(b'\xC0\x00') or not frame.endswith(b'\xC0'):
                                    if LOG_AX25_PARSE_ERROR:
                                        log_event(f"Invalid KISS frame: {frame.hex()}", ax25_parse_error=True)
                                    continue
                                ax25_packet = frame[2:-1]
                                if LOG_AX25_PACKET:
                                    log_event(f"AX.25 packet: {ax25_packet.hex()}", ax25_packet=True)
                                try:
                                    dest = ax25_packet[0:7].decode('ascii', errors='ignore').strip()
                                    src = ax25_packet[7:14].decode('ascii', errors='ignore').strip()
                                    payload_start = 17
                                    payload_end = -2
                                    if len(ax25_packet) < payload_start + 1:
                                        if LOG_AX25_PARSE_ERROR:
                                            log_event(f"AX.25 packet too short: {ax25_packet.hex()}", ax25_parse_error=True)
                                        continue
                                    payload = ax25_packet[payload_start:payload_end].decode('ascii', errors='replace').strip()
                                    packet = f"{src}>{dest}:{payload}"
                                    if LOG_KISS_PACKET_RECEIVED:
                                        log_event(f"Decoded packet: {packet}", kiss_packet_received=True)
                                    log_comms(packet)
                                    if LOG_PACKET_VALIDATION:
                                        log_event(f"Packet validated: src={src}, dest={dest}, payload_len={len(payload)}", packet_validation=True)
                                    header, payload = packet.split(':', 1)
                                    parts = payload.split('|', 3)
                                    if len(parts) != 4:
                                        if LOG_AX25_PARSE_ERROR:
                                            log_event(f"Malformed payload: {payload[:50]}", ax25_parse_error=True)
                                        continue
                                    function, callsign, form_id, payload_content = parts
                                    packet_data = (function, callsign, form_id, payload_content)
                                    try:
                                        packet_queue.put_nowait(packet_data)
                                        if LOG_PACKET_QUEUE:
                                            log_event(f"Enqueued packet: {packet[:50]}", packet_queue=True)
                                        if LOG_LISTENER_QUEUE:
                                            log_event(f"Listener enqueued: {function}|{callsign}|{form_id}|{payload_content[:20]}", listener_queue=True)
                                        if LOG_PACKET_RELAY:
                                            log_event(f"Packet relayed to queue: {function}|{callsign}|{form_id}|{payload_content[:20]}", packet_relay=True)
                                        if LOG_PACKET_ENQUEUE_TIME:  # CHANGE v4.3.1: Log enqueue time
                                            log_event(f"Packet enqueued at {time.time()}", packet_enqueue_time=True)
                                        if LOG_QUEUE_SIZE:  # CHANGE v4.3.1: Log queue size
                                            log_event(f"Queue size after enqueue: {packet_queue.qsize()}", queue_size=True)
                                    except queue.Full:
                                        log_event(f"Queue full, dropped packet: {packet[:50]}", debug=True, packet_drop=True)
                                except UnicodeDecodeError as e:
                                    if LOG_AX25_PARSE_ERROR:
                                        log_event(f"AX.25 decode error: {str(e)}, raw: {ax25_packet.hex()}", ax25_parse_error=True)
                                    continue
                        else:
                            log_event("Fake Direwolf disconnected: Empty data", debug=True, socket_errors=True)
                            kiss_socket.close()
                            kiss_socket = None
                            socket_connected = False
                            if LOG_AX25_STATE:
                                log_event("AX.25 state: Disconnected from Fake Direwolf", ax25_state=True)
                            if LOG_SOCKET_STATUS:
                                log_event("Socket status: Disconnected (empty data)", socket_status=True)
                            buffer = b""
                            break
                    else:
                        log_event("KISS socket is None, breaking to reconnect", debug=True, socket_errors=True)
                        socket_connected = False
                        if LOG_SOCKET_STATUS:
                            log_event("Socket status: Disconnected (None)", socket_status=True)
                        break
                except socket.timeout:
                    now = time.time()
                    if now - last_no_data >= 60 and now - last_timeout_log >= 60:
                        log_event("No data received, connection still alive", debug=True)
                        last_no_data = now
                        last_timeout_log = now
                except (ConnectionResetError, OSError) as e:
                    log_event(f"Socket error: {str(e)}, closing socket", debug=True, socket_errors=True)
                    if kiss_socket:
                        kiss_socket.close()
                        kiss_socket = None
                        socket_connected = False
                        if LOG_AX25_STATE:
                            log_event("AX.25 state: Closed due to error", ax25_state=True)
                        if LOG_SOCKET_STATUS:
                            log_event("Socket status: Disconnected (error)", socket_status=True)
                    buffer = b""
                    break
                except Exception as e:
                    log_event(f"Unexpected listener error: {str(e)}", debug=True, socket_errors=True)
                    if LOG_ERROR_DETAILS:
                        log_event(f"Listener error details: {traceback.format_exc()}", error_details=True)
                    continue
                time.sleep(0.1)
        except Exception as e:
            log_event(f"Unexpected listener error: {str(e)}", debug=True, socket_errors=True)
            if kiss_socket:
                kiss_socket.close()
                kiss_socket = None
                socket_connected = False
            buffer = b""
            time.sleep(retry_delay)
            retry_delay = min(retry_delay * 2, max_delay)

def process_server_data(stdscr, data):
    pass  # Legacy function, retained

# Chunk 7 v4.3 - Main Loop (Navigation & Submit)
def main(stdscr):
    global cursor_offset, current_field, cursor_row, cursor_col, comms_log, screen_dirty, form_id, selecting_mode, field_values, form_fields, show_menu, menu_selection, mode, sending, submission_result, syncing, packet_queue, kiss_socket, socket_connected
    log_event(f"Script v4.3.1 started", debug=True)  # CHANGE v4.3.1: Updated version
    stdscr.resize(ROWS, COLS)
    curses.curs_set(0)
    stdscr.nodelay(True)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    cursor_offset = 0
    current_field = None
    cursor_row = None
    cursor_col = None
    comms_log = []
    debug_log = []
    screen_dirty = True
    form_id = None
    selecting_mode = False
    show_menu = False
    menu_selection = 0
    mode = None
    form_fields = {}
    field_values = {}
    sending = False
    submission_result = None
    syncing = False
    socket_connected = False

    stop_event = threading.Event()
    listener_thread = threading.Thread(target=kiss_listener, args=(stdscr, stop_event))
    listener_thread.daemon = True
    listener_thread.start()
    if LOG_THREAD_STATE:
        log_event("KISS listener thread started", thread_state=True)

    log_event("Entering main", debug=True)
    display_form_list(stdscr)
    while True:
        char = stdscr.getch()
        if char != -1:
            log_event(f"Key pressed: {char}", debug=True)
            if LOG_KEY_CONTEXT:
                log_event(f"Key {char} in state: form_id={form_id}, mode={mode}, current_field={current_field}", key_context=True)
        if char == -1:
            time.sleep(0.05)
        else:
            if not form_id and not selecting_mode and not any(form_fields):
                if show_menu:
                    if char == curses.KEY_UP and menu_selection > 0:
                        menu_selection -= 1
                        screen_dirty = True
                    elif char == curses.KEY_DOWN and menu_selection < 5:
                        menu_selection += 1
                        screen_dirty = True
                    elif char == 10:
                        if menu_selection == 0:
                            show_menu = False
                            screen_dirty = True
                        elif menu_selection == 1:
                            show_menu = False
                            screen_dirty = True
                            stdscr.addstr(1, 2, "Debug Control Screen - TBD", curses.color_pair(GREEN))
                            stdscr.refresh()
                            time.sleep(1)
                        elif menu_selection == 2:
                            show_menu = False
                            screen_dirty = True
                            stdscr.addstr(1, 2, "Forms Management Screen - TBD", curses.color_pair(GREEN))
                            stdscr.refresh()
                            time.sleep(1)
                        elif menu_selection == 3:
                            show_menu = True
                            screen_dirty = True
                        elif menu_selection == 4:
                            show_menu = False
                            screen_dirty = True
                            stdscr.addstr(1, 2, "Group Chat Screen - TBD", curses.color_pair(GREEN))
                            stdscr.refresh()
                            time.sleep(1)
                        elif menu_selection == 5:
                            log_comms("Quitting via menu")
                            log_event("Script exiting: Menu quit selected", debug=True)
                            stop_event.set()
                            if kiss_socket:
                                kiss_socket.close()
                                if LOG_AX25_STATE:
                                    log_event("AX.25 state: Socket closed on exit", ax25_state=True)
                            break
                    elif char == 27:
                        show_menu = False
                        screen_dirty = True
                else:
                    form_files = [f[:-4] for f in os.listdir(FORMS_DIR) if f.endswith('.txt')]
                    form_files.sort()
                    if chr(char).isdigit() and 1 <= int(chr(char)) <= len(form_files):
                        form_idx = int(chr(char)) - 1
                        form_id = form_files[form_idx]
                        selecting_mode = True
                        display_mode_prompt(stdscr, form_id)
                    elif char == ord('d') or char == ord('D'):
                        show_menu = True
                        menu_selection = 0
                        screen_dirty = True
                    elif char == ord('r') or char == ord('R'):
                        if LOG_SOCKET_RECONNECT:
                            log_event("Manual reconnect triggered", socket_reconnect=True)
                        if kiss_socket:
                            kiss_socket.close()
                            kiss_socket = None
                            socket_connected = False
                            if LOG_SOCKET_STATE:
                                log_event("Socket state: Closed for manual reconnect", socket_state=True)
                            if LOG_SOCKET_STATUS:
                                log_event("Socket status: Disconnected (manual)", socket_status=True)
                        screen_dirty = True
            elif selecting_mode:
                if chr(char).lower() == 's':
                    mode = 'S'
                    if LOG_MODE_SWITCH:
                        log_event(f"Mode switched to Search for {form_id}", mode_switch=True)
                    display_search_screen(stdscr, form_id)
                elif chr(char).lower() == 'i':
                    mode = 'I'
                    if LOG_MODE_SWITCH:
                        log_event(f"Mode switched to Insert for {form_id}", mode_switch=True)
                    load_form(stdscr, form_id)
            elif char == 27 and form_fields:
                if sending:
                    redraw_screen(stdscr, sending=True)
                else:
                    if LOG_FORM_EXIT:
                        log_event(f"Form {form_id} exited via Esc, mode={mode}", form_exit=True)
                    form_id = None
                    selecting_mode = False
                    form_fields = {}
                    field_values = {}
                    current_field = None
                    display_form_list(stdscr)
            elif char == 27 and show_menu and menu_selection == 3:
                show_menu = False
                screen_dirty = True
            elif char == 10 and current_field is not None and form_fields:
                if current_field == 'submit' and not sending:
                    if LOG_SUBMISSION_FLOW:
                        log_event("Submit triggered", submission_flow=True)
                    send_to_kiss(stdscr, "")
                    form_id = None
                    selecting_mode = False
                    form_fields = {}
                    field_values = {}
                    current_field = None
                    if LOG_FORM_EXIT:
                        log_event(f"Form {form_id} exited via submit, mode={mode}", form_exit=True)
                elif current_field == 'cancel':
                    if LOG_FORM_EXIT:
                        log_event(f"Form {form_id} exited via cancel, mode={mode}", form_exit=True)
                    form_id = None
                    selecting_mode = False
                    form_fields = {}
                    field_values = {}
                    current_field = None
                    display_form_list(stdscr)
                else:
                    field_ids = sorted([fid for fid in form_fields.keys() if fid != 'L01' and fid != 'R01'], key=lambda x: (form_fields[x]['row'], form_fields[x]['col'])) + ['submit', 'cancel']
                    idx = field_ids.index(current_field)
                    current_field = field_ids[(idx + 1) % len(field_ids)]
                    cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'] if current_field in form_fields else 25)
                    max_y, max_x = stdscr.getmaxyx()
                    row = 19 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']
                    col = (max_x - 11) // 2 + 1 if current_field == 'submit' else (max_x + 1) // 2 + 1 if current_field == 'cancel' else form_fields[current_field]['col'] + 1
                    move_cursor(stdscr, row, col + cursor_offset)
            elif char == curses.KEY_BACKSPACE:
                if current_field and current_field not in ('submit', 'cancel') and form_fields and cursor_offset > 0:
                    row = form_fields[current_field]['row']
                    col = form_fields[current_field]['col'] + 1
                    field_values[current_field] = (
                        field_values[current_field][:cursor_offset - 1] +
                        field_values[current_field][cursor_offset:]
                    )
                    cursor_offset -= 1
                    move_cursor(stdscr, row, col + cursor_offset)
                    redraw_screen(stdscr)
            elif char == curses.KEY_UP:
                if current_field and current_field not in ('submit', 'cancel') and form_fields:
                    is_left = current_field.startswith('L')
                    current_row = form_fields[current_field]['row']
                    above_fields = [fid for fid in form_fields if form_fields[fid]['row'] < current_row and (fid.startswith('L') if is_left else fid.startswith('R')) and fid not in ('L01', 'R01')]
                    if above_fields:
                        next_field = max(above_fields, key=lambda x: form_fields[x]['row'])
                        current_field = next_field
                        cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                        move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                        if LOG_ROW_MOVEMENT:
                            log_event(f"Up from {current_field} to {next_field}", row_movement=True)
            elif char == curses.KEY_DOWN:
                if current_field and form_fields:
                    if current_field in ('submit', 'cancel'):
                        field_ids = sorted([fid for fid in form_fields.keys() if fid != 'L01' and fid != 'R01'], key=lambda x: (form_fields[x]['row'], form_fields[x]['col']))
                        if field_ids:
                            current_field = field_ids[0]
                            cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                            move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                    else:
                        is_left = current_field.startswith('L')
                        current_row = form_fields[current_field]['row']
                        below_fields = [fid for fid in form_fields if form_fields[fid]['row'] > current_row and (fid.startswith('L') if is_left else fid.startswith('R')) and fid not in ('L01', 'R01')]
                        if below_fields:
                            next_field = min(below_fields, key=lambda x: form_fields[x]['row'])
                            current_field = next_field
                            cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                            move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                            if LOG_ROW_MOVEMENT:
                                log_event(f"Down from {current_field} to {next_field}", row_movement=True)
                        elif not below_fields and current_field != 'submit':
                            current_field = 'submit'
                            cursor_offset = 0
                            max_y, max_x = stdscr.getmaxyx()
                            move_cursor(stdscr, 19, (max_x - 11) // 2 + 1)
            elif char == curses.KEY_LEFT:
                if current_field and current_field not in ('submit', 'cancel') and form_fields and current_field.startswith('R'):
                    current_row = form_fields[current_field]['row']
                    field_num = current_field[1:]
                    left_field = f"L{field_num}"
                    if left_field in form_fields and form_fields[left_field]['row'] == current_row:
                        current_field = left_field
                        cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                        move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                        if LOG_COLUMN_NAVIGATION:
                            log_event(f"Left from R{field_num} to L{field_num}", column_navigation=True)
            elif char == curses.KEY_RIGHT:
                if current_field and current_field not in ('submit', 'cancel') and form_fields and current_field.startswith('L'):
                    current_row = form_fields[current_field]['row']
                    field_num = current_field[1:]
                    right_field = f"R{field_num}"
                    if right_field in form_fields and form_fields[right_field]['row'] == current_row:
                        current_field = right_field
                        cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                        move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + 1 + cursor_offset)
                        if LOG_COLUMN_NAVIGATION:
                            log_event(f"Right from L{field_num} to R{field_num}", column_navigation=True)
            elif char == 3:
                log_comms("Branch: Ctrl+C exit")
                log_event("Script exiting: Ctrl+C pressed", debug=True)
                stop_event.set()
                if kiss_socket:
                    kiss_socket.close()
                    if LOG_AX25_STATE:
                        log_event("AX.25 state: Socket closed on exit", ax25_state=True)
                break
            elif 32 <= char <= 126:
                if current_field and current_field not in ('submit', 'cancel') and form_fields:
                    row = form_fields[current_field]['row']
                    col = form_fields[current_field]['col'] + 1
                    length = form_fields[current_field]['len']
                    if len(field_values[current_field]) < length:
                        field_values[current_field] = (
                            field_values[current_field][:cursor_offset] +
                            chr(char) +
                            field_values[current_field][cursor_offset:]
                        )[:length]
                        cursor_offset += 1
                        move_cursor(stdscr, row, col + cursor_offset)
                        screen_dirty = True
                        redraw_screen(stdscr)

        while not packet_queue.empty() and (not form_fields or not any(form_fields)):
            try:
                function, callsign, form_id, payload = packet_queue.get_nowait()
                if LOG_PACKET_QUEUE:
                    log_event(f"Dequeued packet: {function}|{callsign}|{form_id}|{payload[:20]}", packet_queue=True)
                if LOG_UI_PACKET_HANDLING:
                    log_event(f"UI handling packet: {function}|{callsign}|{form_id}|{payload[:20]}", ui_packet_handling=True)
                if LOG_PACKET_DEQUEUE_TIME:  # CHANGE v4.3.1: Log dequeue time
                    log_event(f"Packet dequeued at {time.time()}", packet_dequeue_time=True)
                if LOG_QUEUE_SIZE:  # CHANGE v4.3.1: Log queue size
                    log_event(f"Queue size after dequeue: {packet_queue.qsize()}", queue_size=True)

                if function == 'MD5' and not syncing:
                    if LOG_SYNC_STATE:
                        log_event(f"Received MD5 from {callsign}: {payload}", sync_state=True)
                    server_hash = payload.strip()
                    client_hash = hash_forms_dir()
                    if LOG_MD5_COMPARISON:
                        log_event(f"MD5 comparison: server={server_hash}, client={client_hash}", md5_comparison=True)
                    if server_hash != client_hash:
                        if LOG_SYNC_MISMATCHES:
                            log_event(f"MD5 mismatch detected: server={server_hash}, client={client_hash}", sync_mismatches=True)
                        if LOG_SYNC_START:
                            log_event("Sync started due to MD5 mismatch", sync_start=True)
                        syncing = True
                        index = build_forms_index()
                        update_packet = f"INDEX:{callsign}:{index}"
                        send_to_kiss(stdscr, update_packet)
                    else:
                        log_event("MD5 match, no sync needed", debug=True)
                        display_form_list(stdscr)
                elif function == 'FORM_UPDATE':
                    file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
                    os.makedirs(FORMS_DIR, exist_ok=True)
                    content = payload.replace('~', '\n').rstrip() + '\n'
                    with open(file_path, 'w', newline='\n') as f:
                        f.write(content)
                    if LOG_SYNC_FORMS:
                        log_event(f"Updated {file_path}: {content[:50]}", sync_forms=True)
                    screen_dirty = True
                    display_form_list(stdscr)
                    client_hash = hash_forms_dir()
                    if LOG_SYNC_COMPLETION:
                        log_event(f"Sync completed, MD5: {client_hash}", sync_completion=True)
                    syncing = False
                elif function == 'FORM_DELETE':
                    file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
                    if os.path.exists(file_path):
                        os.remove(file_path)
                        if LOG_FORM_DELETION:
                            log_event(f"Form {form_id} deleted from {file_path}", form_deletion=True)
                    screen_dirty = True
                    display_form_list(stdscr)
                    client_hash = hash_forms_dir()
                    if LOG_SYNC_COMPLETION:
                        log_event(f"Sync completed, MD5: {client_hash}", sync_completion=True)
                    syncing = False
                elif function == 'SEARCH_RESULT':
                    if LOG_SEARCH_RESULTS:
                        log_event(f"Received SEARCH_RESULT: {payload[:50]}", search_results=True)
                    sending = False
                    screen_dirty = True
                    display_results_screen(stdscr, form_id, payload)
                elif function == 'ACK':
                    if LOG_SUBMISSION_DETAILS:
                        log_event(f"Received ACK: {payload}", submission_details=True)
                    sending = False
                    submission_result = payload
                    screen_dirty = True
                    display_form_list(stdscr)
                elif function in ('MSG', 'CHAT'):
                    messages.append(f"{function}:{callsign}:{payload}")
                    unread_messages = True
                    screen_dirty = True
                packet_queue.task_done()
            except queue.Empty:
                break

        if screen_dirty:
            redraw_screen(stdscr)
        time.sleep(0.05)

# Chunk 8 v4.3 - Search Screen
def display_search_screen(stdscr, form_id):
    global form_fields, field_values, current_field, cursor_offset, screen_dirty, mode
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to search screen for {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying search screen for {form_id}", screen_state=True)
    form_data = load_form_data(form_id)
    if not form_data:
        log_comms(f"Form {form_id} not found")
        display_form_list(stdscr)
        return
    form_fields = form_data['fields']
    field_values = {fid: '' for fid in form_fields}
    current_field = min(form_fields.keys())
    cursor_offset = 0
    screen_dirty = True
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    while True:
        redraw_screen(stdscr)
        char = stdscr.getch()
        if char == 27 or (char == 10 and current_field == 'cancel'):
            if LOG_SCREEN_STATE:
                log_event("Screen state: Cancelled search, returning to form list", screen_state=True)
            display_form_list(stdscr)
            break
        elif char == 10 and current_field == 'submit' and not sending:
            send_to_kiss(stdscr, "")
            break
        elif char == 10:
            field_ids = sorted(form_fields.keys()) + ['submit', 'cancel']
            idx = field_ids.index(current_field)
            current_field = field_ids[(idx + 1) % len(field_ids)]
            cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'])
            row = 19 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']
            max_x = stdscr.getmaxyx()[1]
            col = (max_x - 11) // 2 + 1 if current_field == 'submit' else (max_x + 1) // 2 + 1 if current_field == 'cancel' else form_fields[current_field]['col'] + 1
            move_cursor(stdscr, row, col)
        elif char in (curses.KEY_UP, curses.KEY_DOWN):
            field_ids = sorted(form_fields.keys()) + ['submit', 'cancel']
            idx = field_ids.index(current_field)
            delta = -1 if char == curses.KEY_UP else 1
            current_field = field_ids[(idx + delta) % len(field_ids)]
            cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'])
            row = 19 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']
            max_x = stdscr.getmaxyx()[1]
            col = (max_x - 11) // 2 + 1 if current_field == 'submit' else (max_x + 1) // 2 + 1 if current_field == 'cancel' else form_fields[current_field]['col'] + 1
            move_cursor(stdscr, row, col)
        elif char == curses.KEY_BACKSPACE and current_field in form_fields and cursor_offset > 0:
            field_values[current_field] = field_values[current_field][:cursor_offset-1] + field_values[current_field][cursor_offset:]
            cursor_offset -= 1
            screen_dirty = True
        elif 32 <= char <= 126 and current_field in form_fields:
            length = form_fields[current_field]['len']
            if len(field_values[current_field]) < length:
                field_values[current_field] = field_values[current_field][:cursor_offset] + chr(char) + field_values[current_field][cursor_offset:]
                cursor_offset += 1
                screen_dirty = True
        if screen_dirty:
            redraw_screen(stdscr)

# Chunk 9 v4.3 - Results Screen
def display_results_screen(stdscr, form_id, payload):
    global screen_dirty
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to results screen for {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying search results for {form_id}", screen_state=True)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    rows = payload.split('~')
    parsed_rows = []
    for row in rows:
        fields = {}
        for field in row.split('|'):
            if len(field) >= 2:
                fields[field[:2]] = field[2:]
        parsed_rows.append(fields)
    all_fields = sorted(set().union(*[row.keys() for row in parsed_rows]))
    result_data = [{fid: row.get(fid, 'N/A') for fid in all_fields} for row in parsed_rows]
    result_df = pd.DataFrame(result_data)
    screen_dirty = True
    while True:
        stdscr.erase()
        stdscr.addstr(0, 0, "=" * (COLS-1), curses.color_pair(RED))
        stdscr.addstr(1, 2, f"Search Results for {form_id}", curses.color_pair(GREEN))
        table = tabulate(result_df, headers='keys', tablefmt='grid', showindex=False)
        for i, line in enumerate(table.split('\n')[:20]):
            stdscr.addstr(i+3, 2, line[:COLS-4], curses.color_pair(GREEN))
        stdscr.addstr(22, 2, "= Esc=Back =", curses.color_pair(GREEN))
        stdscr.addstr(23, 0, "=" * (COLS-1), curses.color_pair(RED))
        stdscr.refresh()
        char = stdscr.getch()
        if char == 27:
            if LOG_SCREEN_STATE:
                log_event("Screen state: Exiting results screen to form list", screen_state=True)
            display_form_list(stdscr)
            break

# Chunk 10 v4.3 - Main Loop (Exit Only)
if __name__ == "__main__":
    print("Starting terminal client...")
    try:
        log_event("Client startup initiated", debug=True)
        curses.wrapper(main)
    except Exception as e:
        log_event(f"Curses failed: {str(e)}", debug=True, socket_errors=True)
        if LOG_ERROR_DETAILS:
            log_event(f"Startup error details: {traceback.format_exc()}", error_details=True)
        raise

# Chunk 11 v4.3 - Design Goals and Statuses
# DESIGN GOALS:
# - v3.04: Default callsign CLT001, UI packets, enhanced logging - Done
# - v3.1: Add two-column Lxx/Rxx support with Left/Right nav in forms - Done
# - v3.2: Update form display UI to match server (cols 13-48, 49-80), enhance nav, restrict Comms Log to packets only, add logging (ui_render, socket_errors), throttle UI logs, fix NoneType crash in server_listener - Done
# - v3.4: Fix col 80 overflow crash in redraw_screen (80→79) - Done
# - v3.5: Update redraw_screen UI (labels left of [ ], static top row, centered (S)ubmit/(C)ancel), add log_form_ui_layout and log_input_field_state, disable log_cursor_movement and log_field_state - Done
# - v4.0: Replace TCP with AX.25 via Fake Direwolf (127.0.0.1:8051, configurable), add AX.25 headers (e.g., 0CLT001>SVR001), use KISS framing, add logging (kiss_framing, ax25_state), comment out TCP and AGWPE code, update COMM_MODE to KISS - Done
# - v4.1: Fix AX.25 decode error in kiss_listener, add robust error handling, add logging (ax25_packet, ax25_parse_error, kiss_packet_received), disable spammy logs (packet_timing, packet_parse, ui_render, redraw_triggers, sync_md5, sync_forms), ensure backups always logged, restrict Comms Log to packets only - Done
# - v4.2: Fix TCP info in Comms Log (kiss_listener), improve AX.25 parsing for binary data, add logging (packet_validation, md5_comparison, packet_relay, ui_redraw), disable spammy logs (key_context, queue_state), update version and comments - Done
# - v4.3: Fix MD5 comparison (strip trailing chars), fix send failure with retries and bytes logging, add manual reconnect with UI indicator, add logging (socket_send_bytes, socket_send_failure, socket_reconnect, socket_status), line count ~1370 - Done
# - v4.3.1: Add aggressive logging to hunt UPDATE packet bug (socket_send_raw, socket_buffer, ui_comms_log, packet_send_time, packet_enqueue_time, packet_dequeue_time, queue_size, redraw_timing, kiss_receive_buffer, kiss_frame_timing, packet_content, socket_send_attempt, ui_packet_display), keep all logging enabled, line count ~1450+ - Done  # CHANGE v4.3.1: New goal for bug hunting
# - Future: Separate people.csv sync (MD5_people:)
# - Future: Add options screen for config, logging, and KISS port control
# CHANGES:
# - v3.1: Updated VERSION to 3.1 (Chunk 1), added two-column display in redraw_screen (Chunk 4) with Lxx at col=12, Rxx at col=32, added Left/Right nav for paired rows (e.g., L03<->R03) and updated Up/Down for column consistency (Chunk 7), added logging for column_navigation, form_layout, row_movement in config and log_event (Chunk 1, 3), updated command hint in redraw_screen (Chunk 4), line count increased from 951 to ~1000 (Chunk 11)
# - v3.2: Updated VERSION to 3.2 (Chunk 1), split Chunk 4 into 4/5 (11 chunks total), renumbered Chunks 5-10 to 6-11, updated redraw_screen UI to cols 13-48 (left) and 49-80 (right) with 34/30 chars inside (Chunk 4), enhanced navigation for two-column consistency (Chunk 7), added log_comms for packet-only Comms Log (Chunk 3), set log_event ui default to False (Chunk 3), updated all chunks to use log_comms for packets and ui=False elsewhere (Chunks 1-10), added log_form_display_error, log_ui_render, log_socket_errors and turned off log_ui_state, log_redraw_triggers, log_field_state, log_ui_transitions (Chunk 1, 3), throttled redraw_screen logging to 1/sec (Chunk 4), fixed NoneType crash in server_listener with null checks (Chunk 6), line count increased from ~1000 to ~1139 due to UI updates, logging, socket fixes, and comments (Chunk 11)
# - v3.4: Updated VERSION to 3.4 (Chunk 1), fixed col 80 overflow in redraw_screen (Chunk 4), line count unchanged (Chunk 11)
# - v3.5: Updated VERSION to 3.5 (Chunk 1), updated redraw_screen UI: labels at col 2, inputs at 13-48/49-79, static top row at row 2, centered (S)ubmit/(C)ancel (Chunk 4), added log_form_ui_layout and log_input_field_state to config and log_event (Chunk 1, 3), disabled log_cursor_movement and log_field_state to reduce spam (Chunk 1), adjusted navigation in main for new UI layout (Chunk 7), line count increased from ~1139 to ~1155 due to UI changes, logging additions, and comments (Chunk 11)
# - v4.0: Updated VERSION to 4.0 (Chunk 1), replaced TCP with AX.25 via Fake Direwolf (127.0.0.1:8051) in config (Chunk 1), set COMM_MODE to 'KISS' (Chunk 1), added Fake Direwolf host/port to config (Chunk 1), modified packet format with AX.25 headers and KISS framing in send_to_kiss (Chunk 6), replaced server_listener with kiss_listener (Chunk 6), added log_kiss_framing and log_ax25_state to config and log_event (Chunk 1, 3), commented out TCP (send_to_server, server_listener) and AGWPE (radio_send) code (Chunk 6), updated main to use kiss_socket and send_to_kiss (Chunk 7), line count increased from ~1155 to ~1200 due to AX.25 integration, logging, and comments (Chunk 11)
# - v4.1: Updated VERSION to 4.1 (Chunk 1), fixed AX.25 decode in kiss_listener to handle binary data, added robust error handling (Chunk 6), added log_ax25_packet, log_ax25_parse_error, log_kiss_packet_received to config and log_event (Chunk 1, 3), disabled spammy logs: log_packet_timing, log_packet_parse, log_ui_render, log_redraw_triggers, log_sync_md5, log_sync_forms (Chunk 1), ensured backup logging always on in backup_script (Chunk 3), restricted Comms Log to packets only via log_comms usage (Chunks 4, 6, 7, 8), line count increased from ~1200 to ~1250 due to logging additions, AX.25 fixes, and comments (Chunk 11)
# - v4.2: Updated VERSION to 4.2 (Chunk 1), fixed TCP info in Comms Log by replacing log_comms with log_event in kiss_listener (Chunk 6), improved AX.25 parsing in kiss_listener for binary headers (Chunk 6), added log_packet_validation, log_md5_comparison, log_packet_relay, log_ui_redraw to config and log_event (Chunk 1, 3), used new logs in kiss_listener (Chunk 6), main (Chunk 7), and redraw_screen (Chunk 4), disabled spammy logs log_key_context and log_queue_state (Chunk 1), line count increased from ~1250 to ~1290 due to new logging, fixes, and comments (Chunk 11)
# - v4.3: Updated VERSION to 4.3 (Chunk 1), fixed MD5 comparison with strip() in main (Chunk 7), added send retry logic and bytes logging in send_to_kiss (Chunk 6), added manual reconnect with (R)econnect button and [C/D] indicator in redraw_screen (Chunk 4), added log_socket_send_bytes, log_socket_send_failure, log_socket_reconnect, log_socket_status to config and log_event (Chunk 1, 3), updated kiss_listener and main for socket_connected tracking (Chunks 6, 7), line count increased from ~1290 to ~1370 due to logging, reconnect feature, fixes, and comments (Chunk 11)
# - v4.3.1: Updated VERSION to 4.3.1 (Chunk 1), added aggressive logging for UPDATE packet bug: socket_send_raw, socket_buffer, ui_comms_log, packet_send_time, packet_enqueue_time, packet_dequeue_time, queue_size, redraw_timing, kiss_receive_buffer, kiss_frame_timing, packet_content, socket_send_attempt, ui_packet_display in config and log_event (Chunk 1, 3), applied in send_to_kiss (Chunk 6), kiss_listener (Chunk 6), redraw_screen (Chunk 4), main (Chunk 7), log_comms (Chunk 3), kept all logging enabled, line count increased from ~1370 to ~1450+ due to logging and comments (Chunk 11)  # CHANGE v4.3.1: Detailed updates
