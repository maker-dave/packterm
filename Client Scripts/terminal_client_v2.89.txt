#!/usr/bin/env python3
# terminal_client.py
# Chunk 1 v2.89 - Imports and Config - Updated 2025-03-07
import time
import random
import sys
import os
import curses
import socket
import traceback
import textwrap
import glob
import shutil
import hashlib
import threading
import configparser

CONFIG_DIR = os.path.expanduser('~/terminal')
CONFIG_FILE = os.path.join(CONFIG_DIR, 'terminal_client.conf')
CALLSIGN = None
COMM_MODE = 'TCP'
ROWS, COLS = 24, 80
TX_WINDOW = 10
SERVER_HOST = 'pi4.lan'
SERVER_PORT = 12345
AGW_HOST = '127.0.0.1'
AGW_PORT = 8000
INSTALL_DIR = os.path.dirname(os.path.realpath(__file__))
LOG_FILE = os.path.join(CONFIG_DIR, "skippys_messups.log")
FORMS_DIR = os.path.join(INSTALL_DIR, "forms")
BACKUP_DIR = os.path.join(CONFIG_DIR, "backups")
MAX_RETRIES = 5
RETRY_DELAY = 5  # seconds

# DESIGN: (unchanged)
# - Current: TCP-based comms with packetized data (e.g., I|CALLSIGN|FORMID|SEQ:TOTAL|PAYLOAD)
# - Future: Transition to AX.25 packets via Direwolf over 2-meter at 1200 baud, ~12 clients

config = configparser.ConfigParser()
if not os.path.exists(CONFIG_FILE):
    config['Settings'] = {
        'callsign': '',
        'comm_mode': 'TCP',
        'log_callsign_prompt': 'True',
        'log_connectivity': 'True',
        'log_debug': 'True',
        'log_comm_details': 'False',      # Off to reduce spam
        'log_form_updates': 'False',      # Off to reduce spam
        'debug_forms': 'False',
        'debug_sync': 'True',
        'log_submission': 'True',         # Keep for tracking
        'log_ui_state': 'False',          # Off to reduce spam
        'log_packet_details': 'False',    # Off to reduce spam
        'log_segment_status': 'True',     # Keep for segment tracking
        'log_submission_details': 'True', # Keep for detailed tracking
        'log_submission_payload': 'True', # New: raw payload logging
        'log_segment_failure': 'True'     # New: specific segment fails
    }
    os.makedirs(CONFIG_DIR, exist_ok=True)
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)
config.read(CONFIG_FILE)
CALLSIGN = config.get('Settings', 'callsign', fallback='')
COMM_MODE = config.get('Settings', 'comm_mode', fallback=COMM_MODE)
LOG_CALLSIGN_PROMPT = config.getboolean('Settings', 'log_callsign_prompt', fallback=True)
LOG_CONNECTIVITY = config.getboolean('Settings', 'log_connectivity', fallback=True)
LOG_DEBUG = config.getboolean('Settings', 'log_debug', fallback=True)
LOG_COMM_DETAILS = config.getboolean('Settings', 'log_comm_details', fallback=False)
LOG_FORM_UPDATES = config.getboolean('Settings', 'log_form_updates', fallback=False)
DEBUG_FORMS = config.getboolean('Settings', 'debug_forms', fallback=False)
DEBUG_SYNC = config.getboolean('Settings', 'debug_sync', fallback=True)
LOG_SUBMISSION = config.getboolean('Settings', 'log_submission', fallback=True)
LOG_UI_STATE = config.getboolean('Settings', 'log_ui_state', fallback=False)
LOG_PACKET_DETAILS = config.getboolean('Settings', 'log_packet_details', fallback=False)
LOG_SEGMENT_STATUS = config.getboolean('Settings', 'log_segment_status', fallback=True)
LOG_SUBMISSION_DETAILS = config.getboolean('Settings', 'log_submission_details', fallback=True)
LOG_SUBMISSION_PAYLOAD = config.getboolean('Settings', 'log_submission_payload', fallback=True)  # New
LOG_SEGMENT_FAILURE = config.getboolean('Settings', 'log_segment_failure', fallback=True)        # New

# Chunk 2 v2.13 - Global State (unchanged)
cursor_row, cursor_col = None, None
form_fields = {}
field_values = {}
cursor_offset = 0
current_field = None
comms_log = []
debug_log = []
screen_dirty = True
form_id = None
selecting_mode = False
show_menu = False
menu_selection = 0
mode = None
messages = []
unread_messages = False
listener_socket = None
last_no_data = 0

# Chunk 3 v2.89 - Utility Functions - Updated 2025-03-07
def log_event(message, ui=False, debug=False, submission=False, ui_state=False, packet=False, segment=False, submission_details=False, payload=False, segment_failure=False):
    global screen_dirty
    timestamp = time.ctime()
    log_line = f"{timestamp}: {message}"
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    with open(LOG_FILE, 'a') as f:
        f.write(log_line + '\n')
    if ui and not (debug or submission or ui_state or packet or segment or submission_details or payload or segment_failure):
        comms_log.append((message, timestamp))
        if len(comms_log) > 20:
            comms_log.pop(0)
        screen_dirty = True
    if debug and LOG_DEBUG:
        debug_log.append((message, timestamp))
    if submission and LOG_SUBMISSION:
        debug_log.append((message, timestamp))
    if ui_state and LOG_UI_STATE:
        debug_log.append((message, timestamp))
    if packet and LOG_PACKET_DETAILS:
        debug_log.append((message, timestamp))
    if segment and LOG_SEGMENT_STATUS:
        debug_log.append((message, timestamp))
    if submission_details and LOG_SUBMISSION_DETAILS:
        debug_log.append((message, timestamp))
    if payload and LOG_SUBMISSION_PAYLOAD:  # New
        debug_log.append((message, timestamp))
    if segment_failure and LOG_SEGMENT_FAILURE:  # New
        debug_log.append((message, timestamp))

def log_comms(message):
    log_event(message, ui=True)

def backup_script():
    script_path = os.path.realpath(__file__)
    base_name = os.path.basename(script_path)
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_name = f"{base_name.rsplit('.', 1)[0]}_{timestamp}.{base_name.rsplit('.', 1)[1]}"
    backup_path = os.path.join(BACKUP_DIR, backup_name)
    try:
        shutil.copy2(script_path, backup_path)
        log_event(f"Backed up to {backup_path}", ui=True)  # Always on
    except PermissionError as e:
        log_event(f"Backup failed: {str(e)} - proceeding without backup", ui=True)

def init_colors():
    log_event("Initializing colors", debug=True)
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)
    return 1, 2, 3, 4

def get_callsign():
    global CALLSIGN
    CALLSIGN = config.get('Settings', 'callsign', fallback='')
    while not CALLSIGN:
        if LOG_CALLSIGN_PROMPT:
            log_event("Prompting for callsign", ui=True)
        print("Enter Your Callsign (e.g., KC8QKU): ", end='', flush=True)
        CALLSIGN = input().strip().upper()
        if not CALLSIGN:
            print("Callsign cannot be empty—try again")
            time.sleep(1)
        else:
            config['Settings']['callsign'] = CALLSIGN
            with open(CONFIG_FILE, 'w') as configfile:
                config.write(configfile)
            log_event(f"Callsign set to {CALLSIGN}", ui=True)
    return CALLSIGN

def load_form_data(form_id):
    file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
    if not os.path.exists(file_path):
        log_event(f"Form file not found: {file_path}", debug=True)
        return None
    form_data = {'desc': '', 'fields': {}}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('desc:'):
                form_data['desc'] = line.split(':', 1)[1]
            elif ',' in line and len(line.split(',')) == 5:
                fid, label, row, col, length = line.split(',')
                form_data['fields'][fid] = {
                    'label': label,
                    'row': int(row),
                    'col': int(col),
                    'len': int(length)
                }
            else:
                log_event(f"Invalid line in {form_id}.txt: {line}", debug=True)
    if DEBUG_FORMS:
        log_event(f"Loaded form: {form_id}", debug=True)
    return form_data

def update_form_lengths():
    if not os.path.exists(FORMS_DIR) or not os.listdir(FORMS_DIR):
        log_event("No forms yet—awaiting server", debug=True)
        return
    log_event("TEMPORARY: Starting form length update to 256", debug=True)
    for form_file in os.listdir(FORMS_DIR):
        if form_file.endswith('.txt'):
            file_path = os.path.join(FORMS_DIR, form_file)
            lines = []
            with open(file_path, 'r') as f:
                for line in f:
                    if line.startswith('desc:'):
                        lines.append(line.strip())
                    elif ',' in line and len(line.split(',')) == 5:
                        fid, label, row, col, _ = line.strip().split(',')
                        lines.append(f"{fid},{label},{row},{col},256")
                    else:
                        log_event(f"Skipping invalid line in {form_file}: {line.strip()}", debug=True)
            with open(file_path, 'w') as f:
                f.write('\n'.join(lines) + '\n')
            if DEBUG_FORMS:
                log_event(f"TEMPORARY: Updated {form_file} fields to len=256", debug=True)
    log_event("TEMPORARY: Form length update complete", debug=True)

def hash_forms_dir():
    hasher = hashlib.md5()
    if os.path.exists(FORMS_DIR):
        for filename in sorted(glob.glob(os.path.join(FORMS_DIR, '*.txt'))):
            with open(filename, 'rb') as f:
                hasher.update(f.read())
            if DEBUG_SYNC:
                with open(filename, 'r') as f:
                    content = f.read()
                    log_event(f"Hashing {filename}: {content[:50]}", debug=True)
    forms_data = hasher.digest()
    md5_hash = hasher.hexdigest()
    if DEBUG_SYNC:
        log_event(f"Forms data before hash (length): {len(forms_data)}", debug=True)
        log_event(f"Computed client MD5: {md5_hash}", debug=True)
    return md5_hash

def build_forms_index():
    index_parts = []
    if os.path.exists(FORMS_DIR):
        for fname in sorted(os.listdir(FORMS_DIR)):
            if fname.endswith('.txt'):
                file_path = os.path.join(FORMS_DIR, fname)
                with open(file_path, 'r') as f:
                    content = f.read()
                    md5 = hashlib.md5(content.strip().encode()).hexdigest()
                index_parts.append(f"{fname[:-4]}:{md5}")
    index = "|".join(index_parts)
    if DEBUG_SYNC:
        log_event(f"Built forms index: {index}", debug=True)
    return index

if os.path.exists(LOG_FILE):
    os.remove(LOG_FILE)
    log_event("Deleted old log file", ui=True)
backup_script()
CALLSIGN = get_callsign()

# Chunk 4 v2.89 - Screen Functions - Updated 2025-03-07
def move_cursor(stdscr, row, col):
    global cursor_row, cursor_col, screen_dirty
    if DEBUG_FORMS:
        log_event(f"Moving cursor to row: {row}, col: {col}", debug=True)
    cursor_row, cursor_col = min(max(row, 0), ROWS-1), min(max(col, 0), COLS-1)
    screen_dirty = True
    redraw_screen(stdscr)

def redraw_screen(stdscr, sending=False):
    global screen_dirty, form_id, selecting_mode, form_fields, current_field, show_menu, menu_selection, cursor_offset, unread_messages
    if not screen_dirty:
        return
    stdscr.erase()
    stdscr.clear()
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    border = "=" * (COLS - 1)
    max_y, max_x = stdscr.getmaxyx()
    if DEBUG_FORMS:
        log_event(f"Screen size: max_y={max_y}, max_x={max_x}", debug=True)
    stdscr.addstr(0, 0, border, curses.color_pair(RED))
    if form_fields and any(form_fields):
        max_form_row = 21
        form_id_display = form_fields.get(next(iter(form_fields), None), {}).get('form_id', '')
        form_data = load_form_data(form_id_display)
        stdscr.addstr(1, 2, form_data['desc'] if form_data else '', curses.color_pair(GREEN))
        line = 3
        for fid in sorted(form_fields.keys()):
            info = form_fields[fid]
            label = f"{info['label']}:"
            text = field_values.get(fid, '')
            color = YELLOW if fid == current_field else GREEN
            if DEBUG_FORMS:
                log_event(f"Draw field {fid} at {line}, text='{text}'", debug=True)
            stdscr.addstr(line, 2, f"{label}", curses.color_pair(GREEN))
            wrapped_text = textwrap.fill(text, width=COLS - 14)
            wrapped_lines = wrapped_text.split('\n')
            for i, wrapped_line in enumerate(wrapped_lines):
                if line + i < max_form_row:
                    stdscr.addstr(line + i, 12, ' ' * (COLS - 14), curses.color_pair(color))
                    stdscr.addstr(line + i, 12, wrapped_line[:COLS - 14], curses.color_pair(color))
            if fid == current_field and current_field != 'submit':
                line_offset = 0
                pos = cursor_offset
                for i, wrapped_line in enumerate(wrapped_lines):
                    if pos <= len(wrapped_line):
                        line_offset = i
                        cursor_pos = pos
                        break
                    pos -= len(wrapped_line)
                else:
                    line_offset = len(wrapped_lines) - 1 if wrapped_lines else 0
                    cursor_pos = len(wrapped_lines[-1]) if wrapped_lines else 0
                cursor_x = 12 + cursor_pos
                if DEBUG_FORMS:
                    log_event(f"Cursor redraw: offset={cursor_offset}, pos={cursor_pos}, x={cursor_x}", debug=True)
                if line + line_offset < max_form_row and cursor_x < COLS - 2:
                    try:
                        stdscr.addstr(line + line_offset, cursor_x, '■', curses.color_pair(YELLOW))
                    except Exception as e:
                        log_event(f"addch failed: {str(e)}", debug=True)
                        raise
            line += len(wrapped_lines) if wrapped_lines else 1
        stdscr.addstr(19, 2, "Use arrow keys", curses.color_pair(GREEN))
        stdscr.addstr(20, 2, "Submit", curses.color_pair(LIGHT_BLUE))
        if current_field == 'submit':
            stdscr.addch(20, 7, '■', curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(22, 2, "= Commands: Enter=Next Esc=Back Arrows=Up/Down =", curses.color_pair(GREEN))
        if sending:
            msg = "Sending. Please wait."
            y = max_y // 2
            x = (max_x - len(msg)) // 2
            stdscr.addstr(y, x, msg, curses.color_pair(YELLOW) | curses.A_BOLD)
    elif selecting_mode and form_id:
        if DEBUG_FORMS:
            log_event("Drawing mode prompt", debug=True)
        stdscr.addstr(1, 2, f"Selected {form_id}", curses.color_pair(GREEN))
        stdscr.addstr(2, 2, "S=Search, I=Insert", curses.color_pair(GREEN))
        stdscr.addstr(22, 2, "= Commands: S=Search I=Insert Esc=Back =", curses.color_pair(GREEN))
    elif show_menu and menu_selection == 3:
        if DEBUG_FORMS:
            log_event("Drawing messages screen", debug=True)
        stdscr.addstr(1, 2, "Messages", curses.color_pair(GREEN))
        line = 3
        for msg in messages[-20:]:
            if line < 20:
                prefix, from_call, text = msg.split(':', 2)
                if prefix == 'MSG':
                    _, to_call = from_call, text.split(':', 1)[0]
                    text = text.split(':', 1)[1]
                    if to_call == CALLSIGN:
                        stdscr.addstr(line, 2, f"{from_call} -> {text[:40]}", curses.color_pair(GREEN))
                elif prefix == 'CHAT':
                    stdscr.addstr(line, 2, f"{from_call}: {text[:40]}", curses.color_pair(GREEN))
                line += 1
        stdscr.addstr(22, 2, "= Commands: Esc=Back =", curses.color_pair(GREEN))
        unread_messages = False
    else:
        if DEBUG_FORMS:
            log_event("Drawing form list", debug=True)
        stdscr.addstr(1, 2, f"Callsign: {CALLSIGN}", curses.color_pair(GREEN))
        form_files = set(f[:-4] for f in os.listdir(FORMS_DIR) if f.endswith('.txt'))
        form_list = sorted(form_files)
        form_count = len(form_list)
        stdscr.addstr(2, 2, "Select a form:" + (" *" if unread_messages else ""), curses.color_pair(GREEN))
        for i, local_form_id in enumerate(form_list[:15], 1):
            form_data = load_form_data(local_form_id)
            desc = form_data['desc'] if form_data else 'Unknown'
            desc = desc.split('\n')[0][:COLS-14]
            if DEBUG_FORMS:
                log_event(f"Draw option {i}: {local_form_id}", debug=True)
            stdscr.addstr(i + 2, 4, f"{i}: {local_form_id} - {desc}", curses.color_pair(GREEN))
        stdscr.addstr(1, 42, "Comms Log", curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(2, 42, "=" * 36, curses.color_pair(RED))
        for i, (msg, ts) in enumerate(comms_log[-20:], start=3):
            stdscr.addstr(i, 42, f"{msg[:36]}", curses.color_pair(GREEN))
        if show_menu:
            menu_options = [
                ("Main Screen", True),
                ("Debug Control", True),
                ("Forms Management", False),
                ("Messages", True),
                ("Group Chat", True),
                ("Quit", True)
            ]
            stdscr.addstr(6, 20, "+====================+", curses.color_pair(RED))
            for i, (option, active) in enumerate(menu_options):
                color = GREEN if active else RED
                if i == menu_selection:
                    stdscr.addstr(7 + i, 20, f"| {option:<18} |", curses.color_pair(color) | curses.A_REVERSE)
                else:
                    stdscr.addstr(7 + i, 20, f"| {option:<18} |", curses.color_pair(color))
            stdscr.addstr(13, 20, "| Up/Down=Move       |", curses.color_pair(GREEN))
            stdscr.addstr(14, 20, "| Enter=Sel Esc=Back |", curses.color_pair(GREEN))
            stdscr.addstr(15, 20, "+====================+", curses.color_pair(RED))
        stdscr.addstr(23, 0, border, curses.color_pair(RED))
        stdscr.addstr(22, 0, f"= Commands: D=Menu 1-{min(form_count, 15)}=Select =", curses.color_pair(GREEN))
    stdscr.refresh()
    screen_dirty = False

# Chunk 5 v2.3 - Display Functions - Updated 2025-03-12 (unchanged)
def display_form_list(stdscr):
    global comms_log, screen_dirty, form_id, selecting_mode, form_fields, current_field, show_menu
    if DEBUG_FORMS:
        log_event("Showing form list", debug=True)
    form_id = None
    selecting_mode = False
    form_fields = {}
    current_field = None
    show_menu = False
    screen_dirty = True
    redraw_screen(stdscr)

def display_mode_prompt(stdscr, selected_form_id):
    global comms_log, screen_dirty, form_id, selecting_mode
    if DEBUG_FORMS:
        log_event("Showing mode prompt", debug=True)
    form_id = selected_form_id
    selecting_mode = True
    screen_dirty = True
    redraw_screen(stdscr)

def load_form(stdscr, form_id):
    global form_fields, field_values, cursor_row, cursor_col, cursor_offset, current_field, screen_dirty, selecting_mode
    if DEBUG_FORMS:
        log_event(f"Loading form: {form_id}", debug=True)
    stdscr.erase()
    stdscr.clear()
    form_data = load_form_data(form_id)
    if form_data:
        form_fields = form_data['fields']
        for fid in form_fields:
            form_fields[fid]['form_id'] = form_id
        field_values = {fid: '' for fid in form_fields}
        first_field = min(form_fields.keys())
        current_field = first_field
        cursor_row, cursor_col = form_fields[first_field]['row'], form_fields[first_field]['col']
        cursor_offset = 0
        selecting_mode = False
        screen_dirty = True
        redraw_screen(stdscr)

# Chunk 6 v2.89 - Server Communication - Updated 2025-03-07
def radio_send(packet):
    if COMM_MODE == 'RADIO':
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((AGW_HOST, AGW_PORT))
            s.send(packet.encode())
            log_comms(f"AGWPE sent: {packet[:50]}")

def send_to_server(stdscr, data):
    global comms_log, screen_dirty, mode, listener_socket
    if DEBUG_SYNC:
        log_event(f"Sending data: {data[:50]}", debug=True)
    log_comms(f"Sending data: {data[:50]}")
    response = ""
    if data.startswith('INDEX:') or data.startswith('REQ_UPDATE:'):
        full_packet = data + '\n'
    else:
        # CHANGE: Build single packet, split only if >128 bytes, no padding
        payload = '|'.join(f"{fid}{value.rstrip()}" for fid, value in field_values.items())
        log_event(f"Submission payload: {payload}", payload=True)
        base_packet = f"I|{CALLSIGN}|{form_id}|"
        full_packet = f"{base_packet}1:1|{payload}\n"
        if len(full_packet) > 128:  # paclen=128
            payload_chunks = [payload[i:i+100] for i in range(0, len(payload), 100)]  # ~100 bytes + header < 128
            total = len(payload_chunks)
            segments = [f"{base_packet}{seq}:{total}|{chunk}\n" for seq, chunk in enumerate(payload_chunks, 1)]
        else:
            segments = [full_packet]
        total = len(segments)
    try:
        if COMM_MODE == 'TCP':
            if listener_socket and listener_socket.fileno() >= 0:
                s = listener_socket
                if DEBUG_SYNC:
                    log_event("Using existing listener_socket for send", debug=True)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(10)
                s.connect((SERVER_HOST, SERVER_PORT))
                if DEBUG_SYNC:
                    log_event(f"Created new socket for send to {SERVER_HOST}:{SERVER_PORT}", debug=True)
            if not data.startswith(('INDEX:', 'REQ_UPDATE:')):
                redraw_screen(stdscr, sending=True)
                stdscr.refresh()
            for i, segment in enumerate(segments if 'segments' in locals() else [full_packet]):
                seq = i + 1
                s.send(segment.encode())
                log_comms(f"TCP sent segment {seq}/{total}: {segment[:50]}")
                log_event(f"Segment {seq}/{total} sent successfully", segment=True)
            response = s.recv(512).decode().strip() if not data.startswith(('INDEX:', 'REQ_UPDATE:')) else ""
            log_event(f"Submission response: {response if response else 'None'}", submission=True)
            if s != listener_socket:
                s.close()
                if DEBUG_SYNC:
                    log_event("Closed temporary send socket", debug=True)
        elif COMM_MODE == 'RADIO':
            radio_send(full_packet)
            response = ""
        screen_dirty = True
        redraw_screen(stdscr)
    except Exception as e:
        log_comms(f"Send error: {str(e)}")
        log_event(f"Send failed: {str(e)}", debug=True)
        if 'segments' in locals():
            log_event(f"Segment {seq}/{total} failed: {str(e)}", segment_failure=True)
        screen_dirty = True
        redraw_screen(stdscr)
        return ""
    return response

def server_listener(stdscr, stop_event):
    global comms_log, screen_dirty, messages, unread_messages, listener_socket, last_no_data
    log_comms(f"Starting server listener, connecting to {SERVER_HOST}:{SERVER_PORT}")
    log_event(f"Listener thread started, COMM_MODE={COMM_MODE}", debug=True)
    buffer = ""
    while not stop_event.is_set():
        try:
            if listener_socket is None or listener_socket.fileno() < 0:
                listener_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                listener_socket.settimeout(5)
                if LOG_CONNECTIVITY:
                    log_comms(f"TCP connecting to {SERVER_HOST}:{SERVER_PORT}")
                if DEBUG_SYNC:
                    log_event(f"Attempting connection to {SERVER_HOST}:{SERVER_PORT}", debug=True)
                for attempt in range(MAX_RETRIES):
                    try:
                        listener_socket.connect((SERVER_HOST, SERVER_PORT))
                        log_comms(f"TCP connected to {SERVER_HOST}:{SERVER_PORT}")
                        log_event(f"Connected on attempt {attempt + 1}", debug=True)
                        break
                    except ConnectionRefusedError:
                        log_comms(f"Connection failed, retrying ({attempt + 1}/{MAX_RETRIES})")
                        log_event(f"Connection refused, retry {attempt + 1}", debug=True)
                        time.sleep(RETRY_DELAY)
                else:
                    log_comms("Server unreachable, retrying in 10s")
                    log_event("All retries failed, waiting 10s", debug=True)
                    time.sleep(10)
                    continue
            while not stop_event.is_set():
                try:
                    if DEBUG_SYNC:
                        log_event("Calling recv on listener_socket", debug=True)
                    data = listener_socket.recv(512).decode()
                    if data:
                        buffer += data
                        log_comms(f"Received data: {data[:50]}")
                        log_event(f"Data received: {data[:100]}", debug=True)
                        while '\n' in buffer:
                            packet_end = buffer.find('\n')
                            packet = buffer[:packet_end]
                            if packet.startswith('MD5_forms|'):
                                process_server_data(stdscr, packet)
                                buffer = buffer[packet_end + 1:].lstrip('\n')
                            elif packet.startswith('ACK'):
                                if LOG_SUBMISSION_DETAILS:
                                    log_event("Received ACK from server", submission_details=True)
                                buffer = buffer[packet_end + 1:].lstrip('\n')
                            else:
                                break
                        if '\n\n' in buffer:
                            packets = buffer.split('\n\n')
                            for i, packet in enumerate(packets):
                                packet = packet.strip()
                                if packet and (packet.startswith('FORMS:') or (i == 0 and not packet.startswith('MD5_forms|')))
                                    if DEBUG_SYNC:
                                        log_event(f"Processing complete packet: {packet[:50]}", debug=True)
                                    process_server_data(stdscr, packet)
                            buffer = packets[-1] if not packets[-1].startswith(('MD5_forms|', 'FORMS:', 'MSG:', 'CHAT:', 'ACK')) else ""
                            if buffer:
                                log_event(f"Remaining buffer after split: {buffer[:50]}", debug=True)
                    else:
                        log_comms("Server closed connection, reconnecting")
                        log_event("Server disconnected: Empty data received", debug=True)
                        listener_socket.close()
                        listener_socket = None
                        buffer = ""
                        break
                except socket.timeout:
                    now = time.time()
                    if now - last_no_data >= 60:
                        log_comms("No data received, connection still alive")
                        last_no_data = now
                    if DEBUG_SYNC:
                        log_event("Recv timed out, socket still open", debug=True)
                except (ConnectionResetError, OSError) as e:
                    log_comms(f"Listener error: {str(e)} - reconnecting")
                    log_event(f"Socket error: {str(e)}, closing socket", debug=True)
                    listener_socket.close()
                    listener_socket = None
                    buffer = ""
                    break
                time.sleep(0.1)
        except Exception as e:
            log_comms(f"Unexpected listener error: {str(e)}")
            log_event(f"Listener crashed: {str(e)}, traceback: {traceback.format_exc()}", debug=True)
            listener_socket.close()
            listener_socket = None
            buffer = ""
            time.sleep(10)

def process_server_data(stdscr, data):
    global comms_log, screen_dirty, messages, unread_messages
    log_comms(f"Received: {data[:50]}")
    log_event(f"Processing data: {data[:100]}", debug=True)
    if data.startswith('MD5_forms|'):
        if DEBUG_SYNC:
            log_event("Processing MD5_forms packet", debug=True)
        _, server_hash, _ = data.split('|', 2)
        client_hash = hash_forms_dir()
        log_event(f"Server MD5: {server_hash}, Client MD5: {client_hash}", debug=True)
        if server_hash != client_hash:
            if LOG_COMM_DETAILS:
                log_comms(f"MD5 mismatch - server: {server_hash}, client: {client_hash}")
            index = build_forms_index()
            packet = f"INDEX:{CALLSIGN}:{index}"
            if DEBUG_SYNC:
                log_event(f"Sending INDEX: {packet}", debug=True)
            send_to_server(stdscr, packet)
        else:
            log_event("MD5 match, no sync needed", debug=True)
    elif data.startswith('FORMS:'):
        if DEBUG_FORMS:
            log_event("Processing FORMS packet", debug=True)
        parts = data.split(':', 3)
        if len(parts) == 4:
            _, fname, _, content = parts
            fname = fname.split('.')[0]
            file_path = os.path.join(FORMS_DIR, f"{fname}.txt")
            os.makedirs(FORMS_DIR, exist_ok=True)
            content = content.replace('\r\n', '\n').rstrip() + '\n'
            with open(file_path, 'w', newline='\n') as f:
                f.write(content)
            if LOG_FORM_UPDATES:
                log_comms(f"Wrote form {fname} to {file_path}")
            else:
                log_comms(f"Updated form: {fname}")
            if DEBUG_FORMS:
                log_event(f"Wrote {file_path}: {content[:50]}", debug=True)
        else:
            log_event(f"Malformed FORMS packet: {data[:100]}", debug=True)
    elif data.startswith('MSG:'):
        if DEBUG_SYNC:
            log_event("Processing MSG packet", debug=True)
        messages.append(data)
        unread_messages = True
        screen_dirty = True
    elif data.startswith('CHAT:'):
        if DEBUG_SYNC:
            log_event("Processing CHAT packet", debug=True)
        messages.append(data)
        unread_messages = True
        screen_dirty = True
    redraw_screen(stdscr)

# Chunk 7 v2.89 - Main Loop (Navigation & Submit) - Updated 2025-03-07
def main(stdscr):
    global cursor_offset, current_field, cursor_row, cursor_col, comms_log, screen_dirty, form_id, selecting_mode, field_values, form_fields, show_menu, menu_selection, mode
    # CHANGE: Updated version to v2.89
    log_event(f"Script v2.89 started", debug=True)
    stdscr.resize(ROWS, COLS)
    curses.curs_set(0)
    stdscr.nodelay(True)
    cursor_offset = 0
    current_field = None
    cursor_row = None
    cursor_col = None
    comms_log = []
    screen_dirty = True
    form_id = None
    selecting_mode = False
    show_menu = False
    menu_selection = 0
    mode = None
    form_fields = {}
    field_values = {}
    # update_form_lengths()  # Disabled to prevent mismatch with server forms

    stop_event = threading.Event()
    listener_thread = threading.Thread(target=server_listener, args=(stdscr, stop_event))
    listener_thread.daemon = True
    listener_thread.start()

    log_event("Entering main", debug=True)
    display_form_list(stdscr)
    while True:
        char = stdscr.getch()
        if char != -1:
            log_event(f"Key pressed: {char}", debug=True)
            if LOG_UI_STATE:
                log_event(f"State: form_id={form_id}, selecting_mode={selecting_mode}, current_field={current_field}", ui_state=True)
        if char == -1:
            time.sleep(0.05)
            continue
        log_event(f"Processing char: {char}", debug=True)
        if not form_id and not selecting_mode and not any(form_fields):
            if show_menu:
                if char == curses.KEY_UP and menu_selection > 0:
                    menu_selection -= 1
                    screen_dirty = True
                elif char == curses.KEY_DOWN and menu_selection < 5:
                    menu_selection += 1
                    screen_dirty = True
                elif char == 10:
                    if menu_selection == 0:
                        show_menu = False
                        screen_dirty = True
                    elif menu_selection == 1:
                        show_menu = False
                        screen_dirty = True
                        stdscr.addstr(1, 2, "Debug Control Screen - TBD", curses.color_pair(GREEN))
                        stdscr.refresh()
                        time.sleep(1)
                    elif menu_selection == 2:
                        show_menu = False
                        screen_dirty = True
                        stdscr.addstr(1, 2, "Forms Management Screen - TBD", curses.color_pair(GREEN))
                        stdscr.refresh()
                        time.sleep(1)
                    elif menu_selection == 3:
                        show_menu = True
                        screen_dirty = True
                    elif menu_selection == 4:
                        show_menu = False
                        screen_dirty = True
                        stdscr.addstr(1, 2, "Group Chat Screen - TBD", curses.color_pair(GREEN))
                        stdscr.refresh()
                        time.sleep(1)
                    elif menu_selection == 5:
                        log_comms("Quitting via menu")
                        log_event("Script exiting: Menu quit selected", debug=True)
                        stop_event.set()
                        break
                elif char == 27:
                    show_menu = False
                    screen_dirty = True
            else:
                log_event("Branch: Main screen selection", debug=True)
                form_files = [f[:-4] for f in os.listdir(FORMS_DIR) if f.endswith('.txt')]
                form_files.sort()
                if chr(char).isdigit() and 1 <= int(chr(char)) <= len(form_files):
                    form_idx = int(chr(char)) - 1
                    log_event(f"Form files: {form_files}", debug=True)
                    form_id = form_files[form_idx]
                    selecting_mode = True
                    display_mode_prompt(stdscr, form_id)
                elif char == ord('d') or char == ord('D'):
                    show_menu = True
                    menu_selection = 0
                    screen_dirty = True
                elif char == ord('q') or char == ord('Q'):
                    log_event("Ignoring Q on main screen - use menu", debug=True)
        elif selecting_mode:
            log_event("Branch: Mode selection", debug=True)
            if chr(char).lower() == 's':
                mode = 'S'
                load_form(stdscr, form_id)
            elif chr(char).lower() == 'i':
                mode = 'I'
                load_form(stdscr, form_id)
        elif char == 27 and form_fields:
            log_event("Branch: Escaping form to main screen", debug=True)
            form_id = None
            selecting_mode = False
            form_fields = {}
            field_values = {}
            current_field = None
            display_form_list(stdscr)
        elif char == 27 and show_menu and menu_selection == 3:
            show_menu = False
            screen_dirty = True
        elif char == 10 and current_field is not None and form_fields:
            log_event("Branch: Enter key", debug=True)
            if current_field == 'submit':
                packet = f"I|{CALLSIGN}|{form_id}|{mode}|"
                for fid, value in field_values.items():
                    packet += f"{fid}{value}"
                response = send_to_server(stdscr, packet)
                log_event(f"Submission attempted, response: {response if response else 'None'}", submission=True)
                form_id = None
                selecting_mode = False
                current_field = None
                cursor_row = None
                cursor_col = None
                mode = None
                form_fields = {}
                field_values = {}
                display_form_list(stdscr)
            elif current_field in form_fields:
                field_ids = sorted(form_fields.keys())
                idx = field_ids.index(current_field)
                if idx < len(field_ids) - 1:
                    current_field = field_ids[idx + 1]
                    cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'])
                else:
                    current_field = 'submit'
                    cursor_offset = 0
                row = 20 if current_field == 'submit' else form_fields[current_field]['row']
                col = 5 if current_field == 'submit' else form_fields[current_field]['col']
                move_cursor(stdscr, row, col + cursor_offset)
        elif char == curses.KEY_BACKSPACE:
            log_event("Branch: Backspace", debug=True)
            if current_field and current_field != 'submit' and form_fields and cursor_offset > 0:
                row = form_fields[current_field]['row']
                col = form_fields[current_field]['col']
                field_values[current_field] = (
                    field_values[current_field][:cursor_offset - 1] +
                    field_values[current_field][cursor_offset:]
                )
                cursor_offset -= 1
                move_cursor(stdscr, row, col + cursor_offset)
                redraw_screen(stdscr)
        elif char == curses.KEY_UP:
            log_event("Branch: Key up", debug=True)
            if current_field and current_field != 'submit' and form_fields:
                field_ids = sorted(form_fields.keys())
                idx = field_ids.index(current_field)
                if idx > 0:
                    current_field = field_ids[idx - 1]
                    cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                    move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + cursor_offset)
        elif char == curses.KEY_DOWN:
            log_event("Branch: Key down", debug=True)
            if current_field and form_fields:
                field_ids = sorted(form_fields.keys())
                idx = field_ids.index(current_field) if current_field != 'submit' else len(field_ids) - 1
                if idx < len(field_ids) - 1:
                    current_field = field_ids[idx + 1]
                    cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                    move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + cursor_offset)
                elif current_field != 'submit':
                    current_field = 'submit'
                    cursor_offset = 0
                    move_cursor(stdscr, 20, 5)
        elif char == 3:
            log_comms("Branch: Ctrl+C exit")
            log_event("Script exiting: Ctrl+C pressed", debug=True)
            stop_event.set()
            break
        elif 32 <= char <= 126:
            log_event("Branch: Input char", debug=True)
            if current_field and current_field != 'submit' and form_fields:
                row = form_fields[current_field]['row']
                col = form_fields[current_field]['col']
                length = form_fields[current_field]['len']
                if len(field_values[current_field]) < length:
                    field_values[current_field] = (
                        field_values[current_field][:cursor_offset] +
                        chr(char) +
                        field_values[current_field][cursor_offset:]
                    )[:length]
                    cursor_offset += 1
                    log_event(f"After input: offset={cursor_offset}", debug=True)
                    move_cursor(stdscr, row, col + cursor_offset)
                    screen_dirty = True
                    redraw_screen(stdscr)
        else:
            log_event(f"Branch: Unhandled char: {char}", debug=True)
        if screen_dirty:
            redraw_screen(stdscr)
        time.sleep(0.05)

# Chunk 8 v2.2 - Input Handling (unchanged)
# Moved to main loop

# Chunk 9 v2.1 - Arrow Key Navigation (unchanged)
# Moved to main loop

# Chunk 10 v2.89 - Main Loop (Exit Only) - Updated 2025-03-07
if __name__ == "__main__":
    print("Starting terminal client...")
    try:
        log_event("Client startup initiated", debug=True)
        curses.wrapper(main)
    except Exception as e:
        log_event(f"Curses failed: {str(e)}\n{traceback.format_exc()}", ui=True)
        print(f"Curses failed: {e}")

# CHANGES:
# - v2.89: Updated version to v2.89 in main (Chunk 7),
#          simplified send_to_server to send one packet if <128 bytes, split to ~100-byte chunks if >128, removed 256-char padding (Chunk 6),
#          added log_submission_payload and log_segment_failure to config and log_event (Chunk 1, 3),
#          turned off log_packet_details, log_comm_details, log_form_updates, log_ui_state to reduce spam (Chunk 1),
#          kept log_submission, log_segment_status, log_submission_details on for troubleshooting (Chunk 1),
#          backups logging remains always on (Chunk 3),
#          fixed truncated script—restored full line count with all chunks intact