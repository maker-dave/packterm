#!/usr/bin/env python3
# terminal_client.py
# Chunk 1 v2.94 - Imports and Config - Updated 2025-03-09  # CHANGE v2.94: Unified packet format, new callsign
import time
import random
import sys
import os
import curses
import socket
import traceback
import textwrap
import glob
import shutil
import hashlib
import threading
import configparser
import pandas as pd
from tabulate import tabulate

INSTALL_DIR = os.path.dirname(os.path.realpath(__file__))
CONFIG_FILE = os.path.join(INSTALL_DIR, "terminal_client.conf")
CALLSIGN = None
COMM_MODE = 'TCP'
ROWS, COLS = 24, 80
TX_WINDOW = 10
SERVER_HOST = 'pi4.lan'
SERVER_PORT = 12345
AGW_HOST = '127.0.0.1'
AGW_PORT = 8000
LOG_FILE = os.path.join(INSTALL_DIR, "skippys_messups.log")
FORMS_DIR = os.path.join(INSTALL_DIR, "forms")
BACKUP_DIR = os.path.join(INSTALL_DIR, "backups")
MAX_RETRIES = 5
RETRY_DELAY = 5  # seconds

PACLEN = 128

VERSION = "2.94"  # CHANGE v2.94: Updated to 2.94 for unified packet format

config = configparser.ConfigParser()
if not os.path.exists(CONFIG_FILE):
    config['Settings'] = {
        'callsign': 'KB8XYZ',  # CHANGE v2.94: Default client callsign (server uses KC8QKU)
        'comm_mode': 'TCP',
        'paclen': str(PACLEN),
        'log_callsign_prompt': 'True',
        'log_connectivity': 'True',
        'log_debug': 'True',
        'log_comm_details': 'False',       # Disabled spammy log
        'log_form_updates': 'False',       # Disabled spammy log
        'log_submission': 'True',
        'log_ui_state': 'False',           # Disabled spammy log
        'log_packet_details': 'False',     # Disabled spammy log
        'log_segment_status': 'True',
        'log_submission_details': 'True',
        'log_submission_payload': 'True',
        'log_segment_failure': 'True',
        'log_socket_state': 'True',
        'log_retries': 'True',
        'log_ui_transitions': 'True',
        'log_ack_processing': 'True',
        'log_send_state': 'True',
        'log_listener_state': 'True',
        'log_search_query': 'True',
        'log_search_results': 'True',
        'log_screen_state': 'True',
        'log_field_state': 'True',
        'log_submission_flow': 'True',
        'log_debug_forms': 'True',
        'log_debug_sync': 'True',
        'log_cursor_movement': 'True',
        'log_packet_timing': 'True',
        'log_error_details': 'True',
        # CHANGE v2.94: Added packet and sync logging for unified format
        'log_packet_build': 'True',        # Packet creation details
        'log_packet_parse': 'True',        # Packet interpretation details
        'log_sync_state': 'True'           # Form sync process
    }
    os.makedirs(INSTALL_DIR, exist_ok=True)
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)
config.read(CONFIG_FILE)
CALLSIGN = config.get('Settings', 'callsign', fallback='KB8XYZ')  # CHANGE v2.94: Fallback to KB8XYZ
COMM_MODE = config.get('Settings', 'comm_mode', fallback=COMM_MODE)
PACLEN = config.getint('Settings', 'paclen', fallback=PACLEN)
LOG_CALLSIGN_PROMPT = config.getboolean('Settings', 'log_callsign_prompt', fallback=True)
LOG_CONNECTIVITY = config.getboolean('Settings', 'log_connectivity', fallback=True)
LOG_DEBUG = config.getboolean('Settings', 'log_debug', fallback=True)
LOG_COMM_DETAILS = config.getboolean('Settings', 'log_comm_details', fallback=False)
LOG_FORM_UPDATES = config.getboolean('Settings', 'log_form_updates', fallback=False)
LOG_SUBMISSION = config.getboolean('Settings', 'log_submission', fallback=True)
LOG_UI_STATE = config.getboolean('Settings', 'log_ui_state', fallback=False)
LOG_PACKET_DETAILS = config.getboolean('Settings', 'log_packet_details', fallback=False)
LOG_SEGMENT_STATUS = config.getboolean('Settings', 'log_segment_status', fallback=True)
LOG_SUBMISSION_DETAILS = config.getboolean('Settings', 'log_submission_details', fallback=True)
LOG_SUBMISSION_PAYLOAD = config.getboolean('Settings', 'log_submission_payload', fallback=True)
LOG_SEGMENT_FAILURE = config.getboolean('Settings', 'log_segment_failure', fallback=True)
LOG_SOCKET_STATE = config.getboolean('Settings', 'log_socket_state', fallback=True)
LOG_RETRIES = config.getboolean('Settings', 'log_retries', fallback=True)
LOG_UI_TRANSITIONS = config.getboolean('Settings', 'log_ui_transitions', fallback=True)
LOG_ACK_PROCESSING = config.getboolean('Settings', 'log_ack_processing', fallback=True)
LOG_SEND_STATE = config.getboolean('Settings', 'log_send_state', fallback=True)
LOG_LISTENER_STATE = config.getboolean('Settings', 'log_listener_state', fallback=True)
LOG_SEARCH_QUERY = config.getboolean('Settings', 'log_search_query', fallback=True)
LOG_SEARCH_RESULTS = config.getboolean('Settings', 'log_search_results', fallback=True)
LOG_SCREEN_STATE = config.getboolean('Settings', 'log_screen_state', fallback=True)
LOG_FIELD_STATE = config.getboolean('Settings', 'log_field_state', fallback=True)
LOG_SUBMISSION_FLOW = config.getboolean('Settings', 'log_submission_flow', fallback=True)
LOG_DEBUG_FORMS = config.getboolean('Settings', 'log_debug_forms', fallback=True)
LOG_DEBUG_SYNC = config.getboolean('Settings', 'log_debug_sync', fallback=True)
LOG_CURSOR_MOVEMENT = config.getboolean('Settings', 'log_cursor_movement', fallback=True)
LOG_PACKET_TIMING = config.getboolean('Settings', 'log_packet_timing', fallback=True)
LOG_ERROR_DETAILS = config.getboolean('Settings', 'log_error_details', fallback=True)
# CHANGE v2.94: Added new logging variables
LOG_PACKET_BUILD = config.getboolean('Settings', 'log_packet_build', fallback=True)
LOG_PACKET_PARSE = config.getboolean('Settings', 'log_packet_parse', fallback=True)
LOG_SYNC_STATE = config.getboolean('Settings', 'log_sync_state', fallback=True)

# Chunk 2 v2.13 - Global State
cursor_row, cursor_col = None, None
form_fields = {}
field_values = {}
cursor_offset = 0
current_field = None
comms_log = []
debug_log = []
screen_dirty = True
form_id = None
selecting_mode = False
show_menu = False
menu_selection = 0
mode = None
messages = []
unread_messages = False
listener_socket = None
last_no_data = 0
sending = False
submission_result = None

# Chunk 3 v2.94 - Utility Functions  # CHANGE v2.94: Added packet logging
def log_event(message, ui=False, debug=False, submission=False, ui_state=False, packet=False, segment=False, submission_details=False, payload=False, segment_failure=False, socket_state=False, retries=False, ui_transitions=False, ack_processing=False, send_state=False, listener_state=False, search_query=False, search_results=False, screen_state=False, field_state=False, submission_flow=False, cursor_movement=False, packet_timing=False, error_details=False, packet_build=False, packet_parse=False, sync_state=False):
    global screen_dirty
    timestamp = time.ctime()
    log_line = f"{timestamp}: {message}"
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    with open(LOG_FILE, 'a') as f:
        f.write(log_line + '\n')
    if ui and not (debug or submission or ui_state or packet or segment or submission_details or payload or segment_failure or socket_state or retries or ui_transitions or ack_processing or send_state or listener_state or search_query or search_results or screen_state or field_state or submission_flow or cursor_movement or packet_timing or error_details or packet_build or packet_parse or sync_state):
        comms_log.append((message, timestamp))
        if len(comms_log) > 20:
            comms_log.pop(0)
        screen_dirty = True
    if debug and LOG_DEBUG:
        debug_log.append((message, timestamp))
    if submission and LOG_SUBMISSION:
        debug_log.append((message, timestamp))
    if ui_state and LOG_UI_STATE:
        debug_log.append((message, timestamp))
    if packet and LOG_PACKET_DETAILS:
        debug_log.append((message, timestamp))
    if segment and LOG_SEGMENT_STATUS:
        debug_log.append((message, timestamp))
    if submission_details and LOG_SUBMISSION_DETAILS:
        debug_log.append((message, timestamp))
    if payload and LOG_SUBMISSION_PAYLOAD:
        debug_log.append((message, timestamp))
    if segment_failure and LOG_SEGMENT_FAILURE:
        debug_log.append((message, timestamp))
    if socket_state and LOG_SOCKET_STATE:
        debug_log.append((message, timestamp))
    if retries and LOG_RETRIES:
        debug_log.append((message, timestamp))
    if ui_transitions and LOG_UI_TRANSITIONS:
        debug_log.append((message, timestamp))
    if ack_processing and LOG_ACK_PROCESSING:
        debug_log.append((message, timestamp))
    if send_state and LOG_SEND_STATE:
        debug_log.append((message, timestamp))
    if listener_state and LOG_LISTENER_STATE:
        debug_log.append((message, timestamp))
    if search_query and LOG_SEARCH_QUERY:
        debug_log.append((message, timestamp))
    if search_results and LOG_SEARCH_RESULTS:
        debug_log.append((message, timestamp))
    if screen_state and LOG_SCREEN_STATE:
        debug_log.append((message, timestamp))
    if field_state and LOG_FIELD_STATE:
        debug_log.append((message, timestamp))
    if submission_flow and LOG_SUBMISSION_FLOW:
        debug_log.append((message, timestamp))
    if cursor_movement and LOG_CURSOR_MOVEMENT:
        debug_log.append((message, timestamp))
    if packet_timing and LOG_PACKET_TIMING:
        debug_log.append((message, timestamp))
    if error_details and LOG_ERROR_DETAILS:
        debug_log.append((message, timestamp))
    # CHANGE v2.94: Added packet and sync logging
    if packet_build and LOG_PACKET_BUILD:
        debug_log.append((message, timestamp))
    if packet_parse and LOG_PACKET_PARSE:
        debug_log.append((message, timestamp))
    if sync_state and LOG_SYNC_STATE:
        debug_log.append((message, timestamp))

def log_comms(message):
    log_event(message, ui=True)

def backup_script():
    script_path = os.path.realpath(__file__)
    base_name = os.path.basename(script_path)
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_name = f"{base_name.rsplit('.', 1)[0]}_{timestamp}.{base_name.rsplit('.', 1)[1]}"
    backup_path = os.path.join(BACKUP_DIR, backup_name)
    try:
        shutil.copy2(script_path, backup_path)
        log_event(f"Backed up to {backup_path}", ui=True)  # Always on
    except PermissionError as e:
        log_event(f"Backup failed: {str(e)} - proceeding without backup", ui=True)  # Always on

def init_colors():
    log_event("Initializing colors", debug=True)
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)
    return 1, 2, 3, 4

def get_callsign():
    global CALLSIGN
    CALLSIGN = config.get('Settings', 'callsign', fallback='KB8XYZ')  # CHANGE v2.94: Fallback to KB8XYZ
    while not CALLSIGN:
        if LOG_CALLSIGN_PROMPT:
            log_event("Prompting for callsign", ui=True)
        print("Enter Your Callsign (e.g., KB8XYZ): ", end='', flush=True)
        CALLSIGN = input().strip().upper()
        if not CALLSIGN:
            print("Callsign cannot be empty—try again")
            time.sleep(1)
        else:
            config['Settings']['callsign'] = CALLSIGN
            with open(CONFIG_FILE, 'w') as configfile:
                config.write(configfile)
            log_event(f"Callsign set to {CALLSIGN}", ui=True)
    return CALLSIGN

def load_form_data(form_id):
    file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
    if not os.path.exists(file_path):
        log_event(f"Form file not found: {file_path}", debug=True)
        return None
    form_data = {'desc': '', 'fields': {}}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('desc:'):
                form_data['desc'] = line.split(':', 1)[1]
            elif ',' in line and len(line.split(',')) == 5:
                fid, label, row, col, length = line.split(',')
                form_data['fields'][fid] = {
                    'label': label,
                    'row': int(row),
                    'col': int(col),
                    'len': int(length)
                }
            else:
                log_event(f"Invalid line in {form_id}.txt: {line}", debug=True)
    if LOG_DEBUG_FORMS:
        log_event(f"Loaded form: {form_id}", debug=True)
    return form_data

def update_form_lengths():
    if not os.path.exists(FORMS_DIR) or not os.listdir(FORMS_DIR):
        log_event("No forms yet—awaiting server", debug=True)
        return
    log_event("TEMPORARY: Starting form length update to 256", debug=True)
    for form_file in os.listdir(FORMS_DIR):
        if form_file.endswith('.txt'):
            file_path = os.path.join(FORMS_DIR, form_file)
            lines = []
            with open(file_path, 'r') as f:
                for line in f:
                    if line.startswith('desc:'):
                        lines.append(line.strip())
                    elif ',' in line and len(line.split(',')) == 5:
                        fid, label, row, col, _ = line.strip().split(',')
                        lines.append(f"{fid},{label},{row},{col},256")
                    else:
                        log_event(f"Skipping invalid line in {form_file}: {line.strip()}", debug=True)
            with open(file_path, 'w') as f:
                f.write('\n'.join(lines) + '\n')
            if LOG_DEBUG_FORMS:
                log_event(f"TEMPORARY: Updated {form_file} fields to len=256", debug=True)
    log_event("TEMPORARY: Form length update complete", debug=True)

def hash_forms_dir():
    hasher = hashlib.md5()
    if os.path.exists(FORMS_DIR):
        for filename in sorted(glob.glob(os.path.join(FORMS_DIR, '*.txt'))):
            with open(filename, 'rb') as f:
                hasher.update(f.read())
            if LOG_DEBUG_SYNC:
                with open(filename, 'r') as f:
                    content = f.read()
                    log_event(f"Hashing {filename}: {content[:50]}", debug=True)
    forms_data = hasher.digest()
    md5_hash = hasher.hexdigest()
    if LOG_DEBUG_SYNC:
        log_event(f"Forms data before hash (length): {len(forms_data)}", debug=True)
        log_event(f"Computed client MD5: {md5_hash}", debug=True)
    return md5_hash

def build_forms_index():
    index_parts = []
    if os.path.exists(FORMS_DIR):
        for fname in sorted(os.listdir(FORMS_DIR)):
            if fname.endswith('.txt'):
                file_path = os.path.join(FORMS_DIR, fname)
                with open(file_path, 'r') as f:
                    content = f.read()
                    md5 = hashlib.md5(content.strip().encode()).hexdigest()
                index_parts.append(f"{fname[:-4]}:{md5}")
    index = "|".join(index_parts)
    if LOG_DEBUG_SYNC:
        log_event(f"Built forms index: {index}", debug=True)
    return index

if os.path.exists(LOG_FILE):
    os.remove(LOG_FILE)
    log_event("Deleted old log file", ui=True)
backup_script()
CALLSIGN = get_callsign()

# Chunk 4 v2.93 - Screen Functions - Updated 2025-03-09
def move_cursor(stdscr, row, col):
    global cursor_row, cursor_col, screen_dirty
    if LOG_DEBUG_FORMS:
        log_event(f"Moving cursor to row: {row}, col: {col}", debug=True)
    if LOG_CURSOR_MOVEMENT:
        log_event(f"Cursor moving from ({cursor_row}, {cursor_col}) to ({row}, {col})", cursor_movement=True)
    cursor_row, cursor_col = min(max(row, 0), ROWS-1), min(max(col, 0), COLS-1)
    screen_dirty = True
    redraw_screen(stdscr)

def redraw_screen(stdscr, sending=False):
    global screen_dirty, form_id, selecting_mode, form_fields, current_field, show_menu, menu_selection, cursor_offset, unread_messages, mode, submission_result
    if not screen_dirty:
        return
    stdscr.erase()
    stdscr.clear()
    RED, GREEN, YELLOW, LIGHT_BLUE = 1, 2, 3, 4
    border = "=" * (COLS - 1)
    max_y, max_x = stdscr.getmaxyx()
    if LOG_DEBUG_FORMS:
        log_event(f"Screen size: max_y={max_y}, max_x={max_x}", debug=True)
    stdscr.addstr(0, 0, border, curses.color_pair(RED))
    if form_fields and any(form_fields) and mode in ('I', 'S'):
        max_form_row = 21
        form_id_display = form_fields.get(next(iter(form_fields), None), {}).get('form_id', '')
        form_data = load_form_data(form_id_display)
        stdscr.addstr(1, 2, f"{'Insert' if mode == 'I' else 'Search'} Form: {form_data['desc'][:COLS-14]}" if form_data else '', curses.color_pair(GREEN))
        line = 3
        for fid in sorted(form_fields.keys()):
            info = form_fields[fid]
            label = f"{info['label']}:"
            text = field_values.get(fid, '')
            color = YELLOW if fid == current_field else GREEN
            if LOG_DEBUG_FORMS:
                log_event(f"Draw field {fid} at {line}, text='{text}'", debug=True)
            stdscr.addstr(line, 2, f"{label}", curses.color_pair(GREEN))
            wrapped_text = textwrap.fill(text, width=COLS - 14)
            wrapped_lines = wrapped_text.split('\n')
            for i, wrapped_line in enumerate(wrapped_lines):
                if line + i < max_form_row:
                    stdscr.addstr(line + i, 12, ' ' * (COLS - 14), curses.color_pair(color))
                    stdscr.addstr(line + i, 12, wrapped_line[:COLS - 14], curses.color_pair(color))
            if fid == current_field and current_field not in ('submit', 'cancel'):
                line_offset = 0
                pos = cursor_offset
                for i, wrapped_line in enumerate(wrapped_lines):
                    if pos <= len(wrapped_line):
                        line_offset = i
                        cursor_pos = pos
                        break
                    pos -= len(wrapped_line)
                else:
                    line_offset = len(wrapped_lines) - 1 if wrapped_lines else 0
                    cursor_pos = len(wrapped_lines[-1]) if wrapped_lines else 0
                cursor_x = 12 + cursor_pos
                if LOG_DEBUG_FORMS:
                    log_event(f"Cursor redraw: offset={cursor_offset}, pos={cursor_pos}, x={cursor_x}", debug=True)
                if line + line_offset < max_form_row and cursor_x < COLS - 2:
                    try:
                        stdscr.addstr(line + line_offset, cursor_x, '■', curses.color_pair(YELLOW))
                    except Exception as e:
                        log_event(f"addch failed: {str(e)}", debug=True)
                        raise
            line += len(wrapped_lines) if wrapped_lines else 1
        stdscr.addstr(19, 2, "Use arrow keys", curses.color_pair(GREEN))
        stdscr.addstr(20, 2, "Submit", curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(20, 12, "Cancel", curses.color_pair(LIGHT_BLUE))
        if current_field == 'submit':
            stdscr.addstr(20, 7, '■', curses.color_pair(LIGHT_BLUE))
        elif current_field == 'cancel':
            stdscr.addstr(20, 17, '■', curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(22, 2, "= Commands: Enter=Next Esc=Back Arrows=Up/Down =", curses.color_pair(GREEN))
        if sending:
            msg = "Sending. Please wait."
            y = max_y // 2
            x = (max_x - len(msg)) // 2
            stdscr.addstr(y, x, msg, curses.color_pair(YELLOW) | curses.A_BOLD)
    elif selecting_mode and form_id:
        if LOG_DEBUG_FORMS:
            log_event("Drawing mode prompt", debug=True)
        stdscr.addstr(1, 2, f"Selected {form_id}", curses.color_pair(GREEN))
        stdscr.addstr(2, 2, "S=Search, I=Insert", curses.color_pair(GREEN))
        stdscr.addstr(22, 2, "= Commands: S=Search I=Insert Esc=Back =", curses.color_pair(GREEN))
    elif show_menu and menu_selection == 3:
        if LOG_DEBUG_FORMS:
            log_event("Drawing messages screen", debug=True)
        stdscr.addstr(1, 2, "Messages", curses.color_pair(GREEN))
        line = 3
        for msg in messages[-20:]:
            if line < 20:
                prefix, from_call, text = msg.split(':', 2)
                if prefix == 'MSG':
                    _, to_call = from_call, text.split(':', 1)[0]
                    text = text.split(':', 1)[1]
                    if to_call == CALLSIGN:
                        stdscr.addstr(line, 2, f"{from_call} -> {text[:40]}", curses.color_pair(GREEN))
                elif prefix == 'CHAT':
                    stdscr.addstr(line, 2, f"{from_call}: {text[:40]}", curses.color_pair(GREEN))
                line += 1
        stdscr.addstr(22, 2, "= Commands: Esc=Back =", curses.color_pair(GREEN))
        unread_messages = False
    else:
        if LOG_DEBUG_FORMS:
            log_event("Drawing form list", debug=True)
        stdscr.addstr(1, 2, f"Callsign: {CALLSIGN}", curses.color_pair(GREEN))
        form_files = set(f[:-4] for f in os.listdir(FORMS_DIR) if f.endswith('.txt'))
        form_list = sorted(form_files)
        form_count = len(form_list)
        stdscr.addstr(2, 2, "Select a form:" + (" *" if unread_messages else ""), curses.color_pair(GREEN))
        for i, local_form_id in enumerate(form_list[:15], 1):
            form_data = load_form_data(local_form_id)
            desc = form_data['desc'] if form_data else 'Unknown'
            desc = desc.split('\n')[0][:COLS-14]
            if LOG_DEBUG_FORMS:
                log_event(f"Draw option {i}: {local_form_id}", debug=True)
            stdscr.addstr(i + 3, 4, f"{i}: {local_form_id} - {desc}", curses.color_pair(GREEN))
            stdscr.addstr(1, 42, "Comms Log", curses.color_pair(LIGHT_BLUE))
        stdscr.addstr(2, 42, "= " * 36, curses.color_pair(RED))
        for i, (msg, ts) in enumerate(comms_log[-20:], start=3):
            stdscr.addstr(i, 42, f"{msg[:36]}", curses.color_pair(GREEN))
        if submission_result:
            msg = f"Submission: {submission_result}"
            stdscr.addstr(21, (max_x - len(msg)) // 2, msg, curses.color_pair(YELLOW) | curses.A_BOLD)
            time.sleep(2)
            submission_result = None
            screen_dirty = True
        if show_menu:
            menu_options = [
                ("Main Screen", True),
                ("Debug Control", True),
                ("Forms Management", False),
                ("Messages", True),
                ("Group Chat", True),
                ("Quit", True)
            ]
            stdscr.addstr(6, 20, "+====================+", curses.color_pair(RED))
            for i, (option, active) in enumerate(menu_options):
                color = GREEN if active else RED
                if i == menu_selection:
                    stdscr.addstr(7 + i, 20, f"| {option:<18} |", curses.color_pair(color) | curses.A_REVERSE)
                else:
                    stdscr.addstr(7 + i, 20, f"| {option:<18} |", curses.color_pair(color))
            stdscr.addstr(13, 20, "| Up/Down=Move       |", curses.color_pair(GREEN))
            stdscr.addstr(14, 20, "| Enter=Sel Esc=Back |", curses.color_pair(GREEN))
            stdscr.addstr(15, 20, "+====================+", curses.color_pair(RED))
        stdscr.addstr(23, 0, border, curses.color_pair(RED))
        stdscr.addstr(22, 0, f"= Commands: D=Menu 1-{min(form_count, 15)}=Select =", curses.color_pair(GREEN))
    stdscr.refresh()
    screen_dirty = False

# Chunk 5 v2.93 - Display Functions - Updated 2025-03-09
def display_form_list(stdscr):
    global comms_log, screen_dirty, form_id, selecting_mode, form_fields, current_field, show_menu, mode, submission_result
    if LOG_DEBUG_FORMS:
        log_event("Showing form list", debug=True)
    if LOG_UI_TRANSITIONS:
        log_event("Transition to form list", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event("Screen state: Displaying form list", screen_state=True)
    form_id = None
    selecting_mode = False
    form_fields = {}
    current_field = None
    show_menu = False
    mode = None
    screen_dirty = True
    redraw_screen(stdscr)

def display_mode_prompt(stdscr, selected_form_id):
    global comms_log, screen_dirty, form_id, selecting_mode
    if LOG_DEBUG_FORMS:
        log_event("Showing mode prompt", debug=True)
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to mode prompt for {selected_form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying mode prompt for {selected_form_id}", screen_state=True)
    form_id = selected_form_id
    selecting_mode = True
    screen_dirty = True
    redraw_screen(stdscr)

def load_form(stdscr, form_id):
    global form_fields, field_values, cursor_row, cursor_col, cursor_offset, current_field, screen_dirty, selecting_mode, mode
    if LOG_DEBUG_FORMS:
        log_event(f"Loading form: {form_id}", debug=True)
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to form {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Loading form {form_id} in mode {mode}", screen_state=True)
    stdscr.erase()
    stdscr.clear()
    form_data = load_form_data(form_id)
    if form_data:
        form_fields = form_data['fields']
        for fid in form_fields:
            form_fields[fid]['form_id'] = form_id
        field_values = {fid: '' for fid in form_fields}
        first_field = min(form_fields.keys())
        current_field = first_field
        cursor_row, cursor_col = form_fields[first_field]['row'], form_fields[first_field]['col']
        cursor_offset = 0
        selecting_mode = False
        screen_dirty = True
        redraw_screen(stdscr)

# Chunk 6 v2.94 - Server Communication  # CHANGE v2.94: Unified packet format
def radio_send(packet):
    if COMM_MODE == 'RADIO':
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((AGW_HOST, AGW_PORT))
            s.send(packet.encode())
            log_comms(f"AGWPE sent: {packet[:50]}")

def send_to_server(stdscr, data):
    global comms_log, screen_dirty, mode, listener_socket, sending, submission_result
    send_start = time.time()
    if LOG_DEBUG_SYNC:
        log_event(f"Sending data: {data[:50]}", debug=True)
    sending = True
    if LOG_SEND_STATE:
        log_event("Send initiated", send_state=True)
    if LOG_SUBMISSION_FLOW:
        log_event("Starting submission process", submission_flow=True)
    
    # Build unified packet
    if data.startswith('INDEX:'):
        function = 'UPDATE'
        form_id = 'NONE'
        payload = data.split(':', 2)[2]
    elif data.startswith('REQ_UPDATE:'):
        function = 'REQUEST'
        form_id = 'NONE'
        payload = ''
    else:
        function = 'SEARCH' if mode == 'S' else 'INSERT'
        form_id = form_fields[next(iter(form_fields))]['form_id']
        payload = '|'.join(f"{fid}{value.rstrip()}" for fid, value in field_values.items())
        if LOG_SUBMISSION_PAYLOAD:
            log_event(f"Submission payload: {payload}", payload=True)
    
    full_packet = f"{function}|{CALLSIGN}|{form_id}|{payload}\n"
    if LOG_PACKET_BUILD:
        log_event(f"Built packet: {full_packet.strip()}", packet_build=True)
    if LOG_SEARCH_QUERY and function == 'SEARCH':
        log_event(f"Search query packet: {full_packet[:50]}", search_query=True)
    
    # Split into segments if needed
    if len(full_packet) > PACLEN:
        header = f"{function}|{CALLSIGN}|{form_id}|"
        chunk_size = PACLEN - len(header) - 6
        payload_chunks = [payload[i:i+chunk_size] for i in range(0, len(payload), chunk_size)]
        segments = [f"{header}{seq}:{len(payload_chunks)}|{chunk}\n" for seq, chunk in enumerate(payload_chunks, 1)]
    else:
        segments = [full_packet]
    
    total = len(segments)
    try:
        if COMM_MODE == 'TCP':
            if listener_socket and listener_socket.fileno() >= 0:
                s = listener_socket
                if LOG_DEBUG_SYNC:
                    log_event("Using existing listener_socket for send", debug=True)
                if LOG_SOCKET_STATE:
                    log_event("Socket state: Using existing listener_socket", socket_state=True)
            else:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(10)
                s.connect((SERVER_HOST, SERVER_PORT))
                if LOG_DEBUG_SYNC:
                    log_event(f"Created new socket for send to {SERVER_HOST}:{SERVER_PORT}", debug=True)
                if LOG_SOCKET_STATE:
                    log_event(f"Socket state: New socket created and connected to {SERVER_HOST}:{SERVER_PORT}", socket_state=True)
            if function in ('INSERT', 'SEARCH'):
                redraw_screen(stdscr, sending=True)
                stdscr.refresh()
            for seq, segment in enumerate(segments, 1):
                s.send(segment.encode())
                log_comms(f"TCP sent segment {seq}/{total}: {segment[:50]}")
                log_event(f"Segment {seq}/{total} sent successfully", segment=True)
            if LOG_PACKET_TIMING:
                log_event(f"Packet sent in {time.time() - send_start:.3f}s", packet_timing=True)
            if s != listener_socket:
                s.close()
                if LOG_DEBUG_SYNC:
                    log_event("Closed temporary send socket", debug=True)
                if LOG_SOCKET_STATE:
                    log_event("Socket state: Temporary send socket closed", socket_state=True)
        elif COMM_MODE == 'RADIO':
            radio_send(segments[0])
        if LOG_SEND_STATE:
            log_event("Send completed, awaiting ACK via listener", send_state=True)
        sending = False
    except Exception as e:
        log_comms(f"Send error: {str(e)}")
        log_event(f"Send failed: {str(e)}", debug=True)
        if LOG_ERROR_DETAILS:
            log_event(f"Send error details: {traceback.format_exc()}", error_details=True)
        log_event(f"Segment {seq}/{total} failed: {str(e)}", segment_failure=True)
        submission_result = "Failed"
        sending = False
        screen_dirty = True
        display_form_list(stdscr)
        if LOG_SEND_STATE:
            log_event(f"Send failed with error: {str(e)}", send_state=True)
        return ""
    return ""

def server_listener(stdscr, stop_event):
    global comms_log, screen_dirty, messages, unread_messages, listener_socket, last_no_data, sending, submission_result
    log_comms(f"Starting server listener, connecting to {SERVER_HOST}:{SERVER_PORT}")
    log_event(f"Listener thread started, COMM_MODE={COMM_MODE}", debug=True)
    buffer = ""
    last_timeout_log = 0
    while not stop_event.is_set():
        try:
            if listener_socket is None or listener_socket.fileno() < 0:
                listener_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                listener_socket.settimeout(5)
                if LOG_CONNECTIVITY:
                    log_comms(f"TCP connecting to {SERVER_HOST}:{SERVER_PORT}")
                if LOG_DEBUG_SYNC:
                    log_event(f"Attempting connection to {SERVER_HOST}:{SERVER_PORT}", debug=True)
                if LOG_SOCKET_STATE:
                    log_event(f"Socket state: Creating new socket for {SERVER_HOST}:{SERVER_PORT}", socket_state=True)
                if LOG_LISTENER_STATE:
                    log_event("Listener socket created", listener_state=True)
                for attempt in range(MAX_RETRIES):
                    try:
                        listener_socket.connect((SERVER_HOST, SERVER_PORT))
                        if LOG_CONNECTIVITY:
                            log_comms(f"TCP connected to {SERVER_HOST}:{SERVER_PORT}")
                        if LOG_RETRIES:
                            log_event(f"Retry {attempt + 1}/{MAX_RETRIES} succeeded", retries=True)
                        if LOG_SOCKET_STATE:
                            log_event(f"Socket state: Connected on attempt {attempt + 1}", socket_state=True)
                        if LOG_LISTENER_STATE:
                            log_event("Listener connected", listener_state=True)
                        break
                    except ConnectionRefusedError:
                        if LOG_CONNECTIVITY:
                            log_comms(f"Connection failed, retrying ({attempt + 1}/{MAX_RETRIES})")
                        if LOG_RETRIES:
                            log_event(f"Connection refused, retry {attempt + 1}/{MAX_RETRIES}", retries=True)
                        time.sleep(RETRY_DELAY)
                else:
                    if LOG_CONNECTIVITY:
                        log_comms("Server unreachable, retrying in 10s")
                    if LOG_RETRIES:
                        log_event("All retries failed, waiting 10s", retries=True)
                    if LOG_LISTENER_STATE:
                        log_event("Listener failed all retries", listener_state=True)
                    time.sleep(10)
                    continue
            while not stop_event.is_set():
                try:
                    if LOG_DEBUG_SYNC:
                        log_event("Calling recv on listener_socket", debug=True)
                    recv_start = time.time()
                    data = listener_socket.recv(512).decode()
                    if data:
                        buffer += data
                        log_comms(f"Received data: {data[:50]}")
                        log_event(f"Data received: {data[:100]}", debug=True)
                        if LOG_PACKET_TIMING:
                            log_event(f"Packet received in {time.time() - recv_start:.3f}s", packet_timing=True)
                        while '\n' in buffer:
                            packet_end = buffer.find('\n')
                            packet = buffer[:packet_end].strip()
                            if LOG_PACKET_PARSE:
                                log_event(f"Processing packet: {packet[:50]}", packet_parse=True)
                            parts = packet.split('|', 3)
                            if len(parts) != 4:
                                log_event(f"Malformed packet: {packet[:50]}", debug=True)
                                buffer = buffer[packet_end + 1:].lstrip('\n')
                                continue
                            function, callsign, form_id, payload = parts
                            if function == 'MD5':
                                if LOG_SYNC_STATE:
                                    log_event(f"Received MD5 from {callsign}: {payload}", sync_state=True)
                                server_hash = payload
                                client_hash = hash_forms_dir()
                                log_event(f"Server MD5: {server_hash}, Client MD5: {client_hash}", debug=True)
                                if server_hash != client_hash:
                                    index = build_forms_index()
                                    packet = f"UPDATE|{CALLSIGN}|NONE|{index}"
                                    if LOG_PACKET_BUILD:
                                        log_event(f"Built UPDATE packet: {packet}", packet_build=True)
                                    send_to_server(stdscr, packet)
                                else:
                                    log_event("MD5 match, no sync needed", debug=True)
                            elif function == 'FORM_UPDATE':
                                if LOG_DEBUG_FORMS:
                                    log_event(f"Processing FORM_UPDATE for {form_id}", debug=True)
                                file_path = os.path.join(FORMS_DIR, f"{form_id}.txt")
                                os.makedirs(FORMS_DIR, exist_ok=True)
                                content = payload.replace('\r\n', '\n').rstrip() + '\n'
                                with open(file_path, 'w', newline='\n') as f:
                                    f.write(content)
                                if LOG_FORM_UPDATES:
                                    log_comms(f"Wrote form {form_id} to {file_path}")
                                else:
                                    log_comms(f"Updated form: {form_id}")
                                if LOG_DEBUG_FORMS:
                                    log_event(f"Wrote {file_path}: {content[:50]}", debug=True)
                            elif function == 'SEARCH_RESULT':
                                if LOG_SEARCH_RESULTS:
                                    log_event(f"Received SEARCH_RESULT: {packet[:50]}", search_results=True)
                                sending = False
                                screen_dirty = True
                                display_results_screen(stdscr, form_id, payload)
                            elif function == 'ACK':
                                if LOG_SUBMISSION_DETAILS:
                                    log_event(f"Received ACK: {payload}", submission_details=True)
                                if LOG_SUBMISSION_FLOW:
                                    log_event("ACK received, submission successful", submission_flow=True)
                                sending = False
                                submission_result = payload  # e.g., "SUCCESS"
                                screen_dirty = True
                                display_form_list(stdscr)
                            elif function in ('MSG', 'CHAT'):
                                if LOG_DEBUG_SYNC:
                                    log_event(f"Processing {function} packet", debug=True)
                                messages.append(f"{function}:{callsign}:{payload}")
                                unread_messages = True
                                screen_dirty = True
                            buffer = buffer[packet_end + 1:].lstrip('\n')
                    else:
                        log_comms("Server closed connection, reconnecting")
                        log_event("Server disconnected: Empty data received", debug=True)
                        if LOG_SOCKET_STATE:
                            log_event("Socket state: Server closed connection", socket_state=True)
                        if LOG_LISTENER_STATE:
                            log_event("Listener detected server disconnect", listener_state=True)
                        listener_socket.close()
                        listener_socket = None
                        buffer = ""
                        break
                except socket.timeout:
                    now = time.time()
                    if now - last_no_data >= 60:
                        log_comms("No data received, connection still alive")
                        last_no_data = now
                    if LOG_DEBUG_SYNC and now - last_timeout_log >= 60:
                        log_event("Recv timed out, socket still open", debug=True)
                        last_timeout_log = now
                except (ConnectionResetError, OSError) as e:
                    log_comms(f"Listener error: {str(e)} - reconnecting")
                    log_event(f"Socket error: {str(e)}, closing socket", debug=True)
                    if LOG_ERROR_DETAILS:
                        log_event(f"Listener socket error details: {traceback.format_exc()}", error_details=True)
                    if LOG_SOCKET_STATE:
                        log_event(f"Socket state: Closed due to error {str(e)}", socket_state=True)
                    if LOG_LISTENER_STATE:
                        log_event(f"Listener error: {str(e)}", listener_state=True)
                    listener_socket.close()
                    listener_socket = None
                    buffer = ""
                    break
                time.sleep(0.1)
        except Exception as e:
            log_comms(f"Unexpected listener error: {str(e)}")
            log_event(f"Listener crashed: {str(e)}, traceback: {traceback.format_exc()}", debug=True)
            if LOG_ERROR_DETAILS:
                log_event(f"Listener crash details: {traceback.format_exc()}", error_details=True)
            if LOG_SOCKET_STATE:
                log_event(f"Socket state: Listener crashed, resetting", socket_state=True)
            if LOG_LISTENER_STATE:
                log_event(f"Listener crashed with error: {str(e)}", listener_state=True)
            listener_socket.close()
            listener_socket = None
            buffer = ""
            time.sleep(10)

def process_server_data(stdscr, data):
    # Legacy handling for old packet formats (not called with new unified format)
    pass

# Chunk 7 v2.94 - Main Loop (Navigation & Submit)  # CHANGE v2.94: Updated submit logic
def main(stdscr):
    global cursor_offset, current_field, cursor_row, cursor_col, comms_log, screen_dirty, form_id, selecting_mode, field_values, form_fields, show_menu, menu_selection, mode, sending, submission_result
    log_event(f"Script v2.94 started", debug=True)
    stdscr.resize(ROWS, COLS)
    curses.curs_set(0)
    stdscr.nodelay(True)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    cursor_offset = 0
    current_field = None
    cursor_row = None
    cursor_col = None
    comms_log = []
    screen_dirty = True
    form_id = None
    selecting_mode = False
    show_menu = False
    menu_selection = 0
    mode = None
    form_fields = {}
    field_values = {}
    sending = False
    submission_result = None

    stop_event = threading.Event()
    listener_thread = threading.Thread(target=server_listener, args=(stdscr, stop_event))
    listener_thread.daemon = True
    listener_thread.start()

    log_event("Entering main", debug=True)
    display_form_list(stdscr)
    while True:
        char = stdscr.getch()
        if char != -1:
            log_event(f"Key pressed: {char}", debug=True)
            if LOG_UI_STATE:
                log_event(f"State: form_id={form_id}, selecting_mode={selecting_mode}, current_field={current_field}", ui_state=True)
        if char == -1:
            time.sleep(0.05)
            continue
        log_event(f"Processing char: {char}", debug=True)
        if not form_id and not selecting_mode and not any(form_fields):
            if show_menu:
                if char == curses.KEY_UP and menu_selection > 0:
                    menu_selection -= 1
                    screen_dirty = True
                elif char == curses.KEY_DOWN and menu_selection < 5:
                    menu_selection += 1
                    screen_dirty = True
                elif char == 10:
                    if menu_selection == 0:
                        show_menu = False
                        screen_dirty = True
                    elif menu_selection == 1:
                        show_menu = False
                        screen_dirty = True
                        stdscr.addstr(1, 2, "Debug Control Screen - TBD", curses.color_pair(GREEN))
                        stdscr.refresh()
                        time.sleep(1)
                    elif menu_selection == 2:
                        show_menu = False
                        screen_dirty = True
                        stdscr.addstr(1, 2, "Forms Management Screen - TBD", curses.color_pair(GREEN))
                        stdscr.refresh()
                        time.sleep(1)
                    elif menu_selection == 3:
                        show_menu = True
                        screen_dirty = True
                    elif menu_selection == 4:
                        show_menu = False
                        screen_dirty = True
                        stdscr.addstr(1, 2, "Group Chat Screen - TBD", curses.color_pair(GREEN))
                        stdscr.refresh()
                        time.sleep(1)
                    elif menu_selection == 5:
                        log_comms("Quitting via menu")
                        log_event("Script exiting: Menu quit selected", debug=True)
                        stop_event.set()
                        break
                elif char == 27:
                    show_menu = False
                    screen_dirty = True
            else:
                log_event("Branch: Main screen selection", debug=True)
                form_files = [f[:-4] for f in os.listdir(FORMS_DIR) if f.endswith('.txt')]
                form_files.sort()
                if chr(char).isdigit() and 1 <= int(chr(char)) <= len(form_files):
                    form_idx = int(chr(char)) - 1
                    log_event(f"Form files: {form_files}", debug=True)
                    form_id = form_files[form_idx]
                    selecting_mode = True
                    display_mode_prompt(stdscr, form_id)
                elif char == ord('d') or char == ord('D'):
                    show_menu = True
                    menu_selection = 0
                    screen_dirty = True
                elif char == ord('q') or char == ord('Q'):
                    log_event("Ignoring Q on main screen - use menu", debug=True)
        elif selecting_mode:
            log_event("Branch: Mode selection", debug=True)
            if chr(char).lower() == 's':
                mode = 'S'
                display_search_screen(stdscr, form_id)
            elif chr(char).lower() == 'i':
                mode = 'I'
                load_form(stdscr, form_id)
        elif char == 27 and form_fields:
            log_event("Branch: Escaping form to main screen", debug=True)
            if sending:
                redraw_screen(stdscr, sending=True)
            else:
                form_id = None
                selecting_mode = False
                form_fields = {}
                field_values = {}
                current_field = None
                display_form_list(stdscr)
        elif char == 27 and show_menu and menu_selection == 3:
            show_menu = False
            screen_dirty = True
        elif char == 10 and current_field is not None and form_fields:
            log_event("Branch: Enter key", debug=True)
            if current_field == 'submit' and not sending:
                if LOG_SUBMISSION_FLOW:
                    log_event("Submit triggered", submission_flow=True)
                send_to_server(stdscr, "")  # Unified packet built in function
                form_id = None
                selecting_mode = False
                form_fields = {}
                field_values = {}
                current_field = None
                if LOG_SUBMISSION_FLOW:
                    log_event("Post-submit reset complete", submission_flow=True)
            elif current_field == 'cancel':
                form_id = None
                selecting_mode = False
                form_fields = {}
                field_values = {}
                current_field = None
                display_form_list(stdscr)
            elif current_field in form_fields:
                field_ids = sorted(form_fields.keys()) + ['submit', 'cancel']
                idx = field_ids.index(current_field)
                current_field = field_ids[(idx + 1) % len(field_ids)]
                if LOG_FIELD_STATE:
                    log_event(f"Field changed to {current_field}", field_state=True)
                cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'])
                row = 20 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']
                col = 7 if current_field == 'submit' else 17 if current_field == 'cancel' else form_fields[current_field]['col']
                move_cursor(stdscr, row, col + cursor_offset)
        elif char == curses.KEY_BACKSPACE:
            log_event("Branch: Backspace", debug=True)
            if current_field and current_field not in ('submit', 'cancel') and form_fields and cursor_offset > 0:
                row = form_fields[current_field]['row']
                col = form_fields[current_field]['col']
                field_values[current_field] = (
                    field_values[current_field][:cursor_offset - 1] +
                    field_values[current_field][cursor_offset:]
                )
                cursor_offset -= 1
                move_cursor(stdscr, row, col + cursor_offset)
                redraw_screen(stdscr)
        elif char == curses.KEY_UP:
            log_event("Branch: Key up", debug=True)
            if current_field and current_field != 'submit' and form_fields:
                field_ids = sorted(form_fields.keys())
                idx = field_ids.index(current_field)
                if idx > 0:
                    current_field = field_ids[idx - 1]
                    cursor_offset = min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                    move_cursor(stdscr, form_fields[current_field]['row'], form_fields[current_field]['col'] + cursor_offset)
        elif char == curses.KEY_DOWN:
            log_event("Branch: Key down", debug=True)
            if current_field and form_fields:
                field_ids = sorted(form_fields.keys()) + ['submit', 'cancel']
                idx = field_ids.index(current_field)
                current_field = field_ids[(idx + 1) % len(field_ids)]
                cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values[current_field]), form_fields[current_field]['len'] - 1)
                row = 20 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']
                col = 7 if current_field == 'submit' else 17 if current_field == 'cancel' else form_fields[current_field]['col']
                move_cursor(stdscr, row, col + cursor_offset)
        elif char == 3:
            log_comms("Branch: Ctrl+C exit")
            log_event("Script exiting: Ctrl+C pressed", debug=True)
            stop_event.set()
            break
        elif 32 <= char <= 126:
            log_event("Branch: Input char", debug=True)
            if current_field and current_field not in ('submit', 'cancel') and form_fields:
                row = form_fields[current_field]['row']
                col = form_fields[current_field]['col']
                length = form_fields[current_field]['len']
                if len(field_values[current_field]) < length:
                    field_values[current_field] = (
                        field_values[current_field][:cursor_offset] +
                        chr(char) +
                        field_values[current_field][cursor_offset:]
                    )[:length]
                    cursor_offset += 1
                    log_event(f"After input: offset={cursor_offset}", debug=True)
                    move_cursor(stdscr, row, col + cursor_offset)
                    screen_dirty = True
                    redraw_screen(stdscr)
        else:
            log_event(f"Branch: Unhandled char: {char}", debug=True)
        if screen_dirty:
            redraw_screen(stdscr)
        time.sleep(0.05)

# Chunk 8 v2.94 - Search Screen  # CHANGE v2.94: Updated submit logic
def display_search_screen(stdscr, form_id):
    global form_fields, field_values, current_field, cursor_offset, screen_dirty, mode
    if LOG_DEBUG_FORMS:
        log_event(f"Displaying search screen for {form_id}", debug=True)
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to search screen for {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying search screen for {form_id}", screen_state=True)
    form_data = load_form_data(form_id)
    if not form_data:
        log_comms(f"Form {form_id} not found")
        display_form_list(stdscr)
        return
    form_fields = form_data['fields']
    field_values = {fid: '' for fid in form_fields}
    current_field = min(form_fields.keys())
    cursor_offset = 0
    screen_dirty = True
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    while True:
        redraw_screen(stdscr)
        char = stdscr.getch()
        if char == 27 or (char == 10 and current_field == 'cancel'):
            if LOG_SCREEN_STATE:
                log_event("Screen state: Cancelled search, returning to form list", screen_state=True)
            display_form_list(stdscr)
            break
        elif char == 10 and current_field == 'submit' and not sending:
            send_to_server(stdscr, "")
            break  # Wait for server response in server_listener
        elif char == 10:
            field_ids = sorted(form_fields.keys()) + ['submit', 'cancel']
            idx = field_ids.index(current_field)
            current_field = field_ids[(idx + 1) % len(field_ids)]
            cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'])
            row = 20 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']
            col = 7 if current_field == 'submit' else 17 if current_field == 'cancel' else form_fields[current_field]['col']
            move_cursor(stdscr, row, col)
        elif char in (curses.KEY_UP, curses.KEY_DOWN):
            field_ids = sorted(form_fields.keys()) + ['submit', 'cancel']
            idx = field_ids.index(current_field)
            delta = -1 if char == curses.KEY_UP else 1
            current_field = field_ids[(idx + delta) % len(field_ids)]
            cursor_offset = 0 if current_field in ('submit', 'cancel') else min(len(field_values.get(current_field, '')), form_fields[current_field]['len'])
            row = 20 if current_field in ('submit', 'cancel') else form_fields[current_field]['row']
            col = 7 if current_field == 'submit' else 17 if current_field == 'cancel' else form_fields[current_field]['col']
            move_cursor(stdscr, row, col)
        elif char == curses.KEY_BACKSPACE and current_field in form_fields and cursor_offset > 0:
            field_values[current_field] = field_values[current_field][:cursor_offset-1] + field_values[current_field][cursor_offset:]
            cursor_offset -= 1
            screen_dirty = True
        elif 32 <= char <= 126 and current_field in form_fields:
            length = form_fields[current_field]['len']
            if len(field_values[current_field]) < length:
                field_values[current_field] = field_values[current_field][:cursor_offset] + chr(char) + field_values[current_field][cursor_offset:]
                cursor_offset += 1
                screen_dirty = True
        if screen_dirty:
            redraw_screen(stdscr)

# Chunk 9 v2.93 - Results Screen - Updated 2025-03-09
def display_results_screen(stdscr, form_id, payload):
    global screen_dirty
    if LOG_DEBUG_FORMS:
        log_event(f"Displaying results screen for {form_id}", debug=True)
    if LOG_UI_TRANSITIONS:
        log_event(f"Transition to results screen for {form_id}", ui_transitions=True)
    if LOG_SCREEN_STATE:
        log_event(f"Screen state: Displaying search results for {form_id}", screen_state=True)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    rows = payload.split('~')
    parsed_rows = []
    for row in rows:
        fields = {}
        for field in row.split('|'):
            if len(field) >= 2:
                fields[field[:2]] = field[2:]
        parsed_rows.append(fields)
    all_fields = sorted(set().union(*[row.keys() for row in parsed_rows]))
    result_data = [{fid: row.get(fid, 'N/A') for fid in all_fields} for row in parsed_rows]
    result_df = pd.DataFrame(result_data)
    screen_dirty = True
    while True:
        stdscr.erase()
        stdscr.addstr(0, 0, "=" * (COLS-1), curses.color_pair(RED))
        stdscr.addstr(1, 2, f"Search Results for {form_id}", curses.color_pair(GREEN))
        table = tabulate(result_df, headers='keys', tablefmt='grid', showindex=False)
        for i, line in enumerate(table.split('\n')[:20]):
            stdscr.addstr(i+3, 2, line[:COLS-4], curses.color_pair(GREEN))
        stdscr.addstr(22, 2, "= Esc=Back =", curses.color_pair(GREEN))
        stdscr.addstr(23, 0, "=" * (COLS-1), curses.color_pair(RED))
        stdscr.refresh()
        char = stdscr.getch()
        if char == 27:
            if LOG_SCREEN_STATE:
                log_event("Screen state: Exiting results screen to form list", screen_state=True)
            display_form_list(stdscr)
            break

# Chunk 10 v2.94 - Main Loop (Exit Only)  # CHANGE v2.94: Updated version
if __name__ == "__main__":
    print("Starting terminal client...")
    try:
        log_event("Client startup initiated", debug=True)
        curses.wrapper(main)
    except Exception as e:
        log_event(f"Curses failed: {str(e)}\n{traceback.format_exc()}", ui=True)
        if LOG_ERROR_DETAILS:
            log_event(f"Main loop crash details: {traceback.format_exc()}", error_details=True)
        print(f"Curses failed: {e}")

# CHANGES:
# - v2.94: Updated VERSION to 2.94 (Chunk 1),
#          set client callsign to KB8XYZ (server uses KC8QKU) in config and get_callsign (Chunk 1),
#          unified packet format to (function)|(callsign)|(formID)|(payload)\n in send_to_server and server_listener (Chunk 6),
#          added log_packet_build, log_packet_parse, log_sync_state to config and log_event (Chunk 1, 3),
#          simplified submit logic in main and display_search_screen to use unified send_to_server (Chunk 7, 8),
#          kept spammy logs off, backups always on (Chunk 1, 3),
#          line count increased from 1123 to ~1180 with new logging and unified logic