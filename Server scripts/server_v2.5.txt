#!/usr/bin/env python3
# server.py
# Version 2.5 - 2025-03-12  # CHANGE v2.5: Updated form_edit_screen UI, enforced Lxx/Rxx, fixed TYPE bug, packet-only Comms Log

# Chunk 1 v2.5 - Imports, Early Globals, and Utilities
import os
import sys
import time
import socket
import threading
import hashlib
import logging
import shutil
import curses
import glob
import select
import traceback
import configparser
import re
import queue
from datetime import datetime
from collections import defaultdict  # CHANGE v2.3: Added for table row tracking in form_edit_screen

# Early globals (no config dependencies)
# comms_log: List for Main screen Comms Log area (cols ~40-80), displays only over-the-air packets (e.g., "MD5|SVR001|...", "UPDATE|CLT001|..."), not TCP/UI/debug events
comms_log = []
screen_dirty = True
clients = []  # (socket, address, callsign, last_data_time)
clients_lock = threading.Lock()
forms_md5 = None
last_mtime = 0
show_menu = False
menu_selection = 0
syncing_clients = set()
last_broadcast = {}

def log_event(message, ui=False, submission_details=False, submissions=False, submission_payload=False, segment_failure=False, socket_state=False, retries=False, ui_transitions=False, search_query=False, search_results=False, search_parsing=False, csv_processing=False, client_state=False, packet_build=False, packet_parse=False, sync_state=False, sync_md5=False, sync_forms=False, client_packet=False, packet_integrity=False, form_deletion=False, sync_start=False, sync_completion=False, packet_queue=False, client_queue=False, ui_packet_handling=False, queue_state=False, startup_errors=False, backups=False, connection_attempts=False, packet_drop=False, thread_state=False, form_field_creation=False, form_preview=False, field_positioning=False, table_edit=False, form_save=False, ui_render=False, form_sync_error=False, packet_fragments=False, sync_mismatches=False):  # CHANGE v2.5: Added ui_render, form_sync_error, packet_fragments, sync_mismatches; ui default False for packet-only Comms Log
    logging.info(message)
    if ui:  # Only raw packets (e.g., "MD5|SVR001|...") should set ui=True, via log_comms
        comms_log.append((message, datetime.now().strftime('%H:%M:%S')))
        if len(comms_log) > 20:
            comms_log.pop(0)
        global screen_dirty
        screen_dirty = True
    if submission_details and LOG_SUBMISSION_DETAILS: logging.info("Submission Detail: " + message)
    if submissions and LOG_SUBMISSIONS: logging.info("Submission: " + message)
    if submission_payload and LOG_SUBMISSION_PAYLOAD: logging.info("Submission Payload: " + message)
    if segment_failure and LOG_SEGMENT_FAILURE: logging.info("Segment Failure: " + message)
    if socket_state and LOG_SOCKET_STATE: logging.info("Socket State: " + message)
    if retries and LOG_RETRIES: logging.info("Retry: " + message)
    if ui_transitions and LOG_UI_TRANSITIONS: logging.info("UI Transition: " + message)
    if search_query and LOG_SEARCH_QUERY: logging.info("Search Query: " + message)
    if search_results and LOG_SEARCH_RESULTS: logging.info("Search Results: " + message)
    if search_parsing and LOG_SEARCH_PARSING: logging.info("Search Parsing: " + message)
    if csv_processing and LOG_CSV_PROCESSING: logging.info("CSV Processing: " + message)
    if client_state and LOG_CLIENT_STATE: logging.info("Client State: " + message)
    if packet_build and LOG_PACKET_BUILD: logging.info("Packet Build: " + message)
    if packet_parse and LOG_PACKET_PARSE: logging.info("Packet Parse: " + message)
    if sync_state and LOG_SYNC_STATE: logging.info("Sync State: " + message)
    if sync_md5 and LOG_SYNC_MD5: logging.info("Sync MD5: " + message)
    if sync_forms and LOG_SYNC_FORMS: logging.info("Sync Forms: " + message)
    if client_packet and LOG_CLIENT_PACKET: logging.info("Client Packet: " + message)
    if packet_integrity and LOG_PACKET_INTEGRITY: logging.info("Packet Integrity: " + message)
    if form_deletion and LOG_FORM_DELETION: logging.info("Form Deletion: " + message)
    if sync_start and LOG_SYNC_START: logging.info("Sync Start: " + message)
    if sync_completion and LOG_SYNC_COMPLETION: logging.info("Sync Completion: " + message)
    if packet_queue and LOG_PACKET_QUEUE: logging.info("Packet Queue: " + message)
    if client_queue and LOG_CLIENT_QUEUE: logging.info("Client Queue: " + message)
    if ui_packet_handling and LOG_UI_PACKET_HANDLING: logging.info("UI Packet Handling: " + message)
    if queue_state and LOG_QUEUE_STATE: logging.info("Queue State: " + message)
    if startup_errors and LOG_STARTUP_ERRORS: logging.info("Startup Error: " + message)
    if backups: logging.info("Backup: " + message)  # Backups always logged
    if connection_attempts and LOG_CONNECTION_ATTEMPTS: logging.info("Connection Attempt: " + message)
    if packet_drop and LOG_PACKET_DROP: logging.info("Packet Drop: " + message)
    if thread_state and LOG_THREAD_STATE: logging.info("Thread State: " + message)
    if form_field_creation and LOG_FORM_FIELD_CREATION: logging.info("Form Field Creation: " + message)
    if form_preview and LOG_FORM_PREVIEW: logging.info("Form Preview: " + message)
    if field_positioning and LOG_FIELD_POSITIONING: logging.info("Field Positioning: " + message)
    if table_edit and LOG_TABLE_EDIT: logging.info("Table Edit: " + message)
    if form_save and LOG_FORM_SAVE: logging.info("Form Save: " + message)
    if ui_render and LOG_UI_RENDER: logging.info("UI Render: " + message)  # CHANGE v2.5: Added for UI rendering issues
    if form_sync_error and LOG_FORM_SYNC_ERROR: logging.info("Form Sync Error: " + message)  # CHANGE v2.5: Added for sync troubleshooting
    if packet_fragments and LOG_PACKET_FRAGMENTS: logging.info("Packet Fragments: " + message)  # CHANGE v2.5: Added for multi-segment packet tracking
    if sync_mismatches and LOG_SYNC_MISMATCHES: logging.info("Sync Mismatch: " + message)  # CHANGE v2.5: Added for MD5 mismatch details

def log_comms(message):
    # CHANGE v2.5: Added to log only raw over-the-air packets to Comms Log
    log_event(message, ui=True)

def backup_script():
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_path = os.path.join(BACKUP_DIR, "server_" + timestamp + ".py")
    shutil.copy2(__file__, backup_path)
    log_event("Backed up to " + backup_path, ui=False, backups=True)  # Debug only, backups always on

VERSION = "2.5"  # CHANGE v2.5: Updated from 2.4 for UI fixes, packet-only Comms Log, enhanced logging
PACLEN = 255

config = configparser.ConfigParser()
CONFIG_FILE = None
if not os.path.exists(CONFIG_FILE or ''):
    config['Settings'] = {
        'callsign': 'SVR001',
        'paclen': str(PACLEN),
        'log_client_details': 'True',
        'log_form_sync': 'True',
        'log_submissions': 'True',
        'broadcast_interval': '60',
        'client_timeout': '1800',
        'log_submission_details': 'True',
        'log_packet_parsing': 'False',
        'log_buffer_events': 'False',
        'log_packet_content': 'False',
        'log_payload_processing': 'False',
        'log_submission_payload': 'True',
        'log_segment_failure': 'True',
        'log_socket_state': 'True',
        'log_retries': 'True',
        'log_ui_transitions': 'False',  # Spam-prone, off by default
        'log_search_query': 'True',
        'log_search_results': 'True',
        'log_search_parsing': 'True',
        'log_csv_processing': 'True',
        'log_client_state': 'True',
        'log_packet_build': 'True',
        'log_packet_parse': 'False',
        'log_sync_state': 'True',
        'log_sync_md5': 'False',
        'log_sync_forms': 'False',
        'log_client_packet': 'True',
        'log_packet_integrity': 'True',
        'log_form_deletion': 'True',
        'log_sync_start': 'True',
        'log_sync_completion': 'True',
        'log_packet_queue': 'True',
        'log_client_queue': 'True',
        'log_ui_packet_handling': 'True',
        'log_queue_state': 'True',
        'log_startup_errors': 'True',
        'home_dir': os.path.expanduser('~/terminal'),
        'server_host': '0.0.0.0',
        'server_port': '12345',
        'queue_maxsize': '100',
        'log_connection_attempts': 'True',
        'log_packet_drop': 'True',
        'log_thread_state': 'True',
        'log_form_field_creation': 'True',
        'log_form_preview': 'True',
        'log_field_positioning': 'False',  # CHANGE v2.5: Turned off, less useful with new UI
        'log_table_edit': 'True',
        'log_form_save': 'True',
        'log_ui_render': 'True',          # CHANGE v2.5: Added for UI rendering issues
        'log_form_sync_error': 'True',    # CHANGE v2.5: Added for sync troubleshooting
        'log_packet_fragments': 'True',   # CHANGE v2.5: Added for multi-segment packet tracking
        'log_sync_mismatches': 'True'     # CHANGE v2.5: Added for MD5 mismatch details
    }
    HOME_DIR = config['Settings']['home_dir']
    os.makedirs(HOME_DIR, exist_ok=True)
    CONFIG_FILE = os.path.join(HOME_DIR, 'server.conf')
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)
config.read(CONFIG_FILE or os.path.join(os.path.expanduser('~/terminal'), 'server.conf'))
HOME_DIR = config.get('Settings', 'home_dir', fallback=os.path.expanduser('~/terminal'))
CONFIG_FILE = os.path.join(HOME_DIR, 'server.conf')
FORMS_DIR = os.path.join(HOME_DIR, 'forms')
DATA_DIR = os.path.join(HOME_DIR, 'server_data')
LOG_FILE = os.path.join(DATA_DIR, 'server.log')
BACKUP_DIR = os.path.join(HOME_DIR, 'backups')
SERVER_HOST = config.get('Settings', 'server_host', fallback='0.0.0.0')
SERVER_PORT = config.getint('Settings', 'server_port', fallback=12345)
CALLSIGN = config.get('Settings', 'callsign', fallback='SVR001')
PACLEN = config.getint('Settings', 'paclen', fallback=PACLEN)
LOG_CLIENT_DETAILS = config.getboolean('Settings', 'log_client_details', fallback=True)
LOG_FORM_SYNC = config.getboolean('Settings', 'log_form_sync', fallback=True)
LOG_SUBMISSIONS = config.getboolean('Settings', 'log_submissions', fallback=True)
BROADCAST_INTERVAL = config.getint('Settings', 'broadcast_interval', fallback=60)
CLIENT_TIMEOUT = config.getint('Settings', 'client_timeout', fallback=1800)
LOG_SUBMISSION_DETAILS = config.getboolean('Settings', 'log_submission_details', fallback=True)
LOG_PACKET_PARSING = config.getboolean('Settings', 'log_packet_parsing', fallback=False)
LOG_BUFFER_EVENTS = config.getboolean('Settings', 'log_buffer_events', fallback=False)
LOG_PACKET_CONTENT = config.getboolean('Settings', 'log_packet_content', fallback=False)
LOG_PAYLOAD_PROCESSING = config.getboolean('Settings', 'log_payload_processing', fallback=False)
LOG_SUBMISSION_PAYLOAD = config.getboolean('Settings', 'log_submission_payload', fallback=True)
LOG_SEGMENT_FAILURE = config.getboolean('Settings', 'log_segment_failure', fallback=True)
LOG_SOCKET_STATE = config.getboolean('Settings', 'log_socket_state', fallback=True)
LOG_RETRIES = config.getboolean('Settings', 'log_retries', fallback=True)
LOG_UI_TRANSITIONS = config.getboolean('Settings', 'log_ui_transitions', fallback=False)
LOG_SEARCH_QUERY = config.getboolean('Settings', 'log_search_query', fallback=True)
LOG_SEARCH_RESULTS = config.getboolean('Settings', 'log_search_results', fallback=True)
LOG_SEARCH_PARSING = config.getboolean('Settings', 'log_search_parsing', fallback=True)
LOG_CSV_PROCESSING = config.getboolean('Settings', 'log_csv_processing', fallback=True)
LOG_CLIENT_STATE = config.getboolean('Settings', 'log_client_state', fallback=True)
LOG_PACKET_BUILD = config.getboolean('Settings', 'log_packet_build', fallback=True)
LOG_PACKET_PARSE = config.getboolean('Settings', 'log_packet_parse', fallback=False)
LOG_SYNC_STATE = config.getboolean('Settings', 'log_sync_state', fallback=True)
LOG_SYNC_MD5 = config.getboolean('Settings', 'log_sync_md5', fallback=False)
LOG_SYNC_FORMS = config.getboolean('Settings', 'log_sync_forms', fallback=False)
LOG_CLIENT_PACKET = config.getboolean('Settings', 'log_client_packet', fallback=True)
LOG_PACKET_INTEGRITY = config.getboolean('Settings', 'log_packet_integrity', fallback=True)
LOG_FORM_DELETION = config.getboolean('Settings', 'log_form_deletion', fallback=True)
LOG_SYNC_START = config.getboolean('Settings', 'log_sync_start', fallback=True)
LOG_SYNC_COMPLETION = config.getboolean('Settings', 'log_sync_completion', fallback=True)
LOG_PACKET_QUEUE = config.getboolean('Settings', 'log_packet_queue', fallback=True)
LOG_CLIENT_QUEUE = config.getboolean('Settings', 'log_client_queue', fallback=True)
LOG_UI_PACKET_HANDLING = config.getboolean('Settings', 'log_ui_packet_handling', fallback=True)
LOG_QUEUE_STATE = config.getboolean('Settings', 'log_queue_state', fallback=True)
LOG_STARTUP_ERRORS = config.getboolean('Settings', 'log_startup_errors', fallback=True)
LOG_CONNECTION_ATTEMPTS = config.getboolean('Settings', 'log_connection_attempts', fallback=True)
LOG_PACKET_DROP = config.getboolean('Settings', 'log_packet_drop', fallback=True)
LOG_THREAD_STATE = config.getboolean('Settings', 'log_thread_state', fallback=True)
LOG_FORM_FIELD_CREATION = config.getboolean('Settings', 'log_form_field_creation', fallback=True)
LOG_FORM_PREVIEW = config.getboolean('Settings', 'log_form_preview', fallback=True)
LOG_FIELD_POSITIONING = config.getboolean('Settings', 'log_field_positioning', fallback=False)
LOG_TABLE_EDIT = config.getboolean('Settings', 'log_table_edit', fallback=True)
LOG_FORM_SAVE = config.getboolean('Settings', 'log_form_save', fallback=True)
LOG_UI_RENDER = config.getboolean('Settings', 'log_ui_render', fallback=True)          # CHANGE v2.5: Added for UI rendering issues
LOG_FORM_SYNC_ERROR = config.getboolean('Settings', 'log_form_sync_error', fallback=True)  # CHANGE v2.5: Added for sync troubleshooting
LOG_PACKET_FRAGMENTS = config.getboolean('Settings', 'log_packet_fragments', fallback=True)  # CHANGE v2.5: Added for multi-segment packet tracking
LOG_SYNC_MISMATCHES = config.getboolean('Settings', 'log_sync_mismatches', fallback=True)  # CHANGE v2.5: Added for MD5 mismatch details
QUEUE_MAXSIZE = config.getint('Settings', 'queue_maxsize', fallback=100)

packet_queue = queue.Queue(maxsize=QUEUE_MAXSIZE)

if os.path.exists(LOG_FILE):
    os.remove(LOG_FILE)
logging.basicConfig(filename=LOG_FILE, level=logging.INFO, format='%(asctime)s - %(message)s')
log_event("Deleted old log file", ui=False)  # Debug only, not Comms Log
log_event(f"Initial packet_queue size: {packet_queue.qsize()}", ui=False, queue_state=True)  # Debug only

# Chunk 2 v2.5 - Utility Functions (was Chunk 3)
def get_callsign(stdscr):
    global CALLSIGN
    if not CALLSIGN:
        while True:
            stdscr.clear()
            stdscr.addstr(0, 0, "Enter Server Callsign (e.g., KC8QKU, required): ", curses.color_pair(2))
            stdscr.refresh()
            curses.echo()
            CALLSIGN = stdscr.getstr(1, 0, 10).decode().strip().upper()
            curses.noecho()
            if CALLSIGN:
                break
            stdscr.addstr(2, 0, "Callsign cannot be empty. Try again.", curses.color_pair(1))
            stdscr.refresh()
            time.sleep(1)
        config['Settings']['callsign'] = CALLSIGN
        with open(CONFIG_FILE, 'w') as configfile:
            config.write(configfile)
    log_event("Callsign set to " + CALLSIGN, ui=False)  # CHANGE v2.5: Debug only, not Comms Log
    return CALLSIGN

# Chunk 3 v2.5 - Form Sync Functions (was Chunk 4)
def hash_forms_dir():
    hasher = hashlib.md5()
    for filename in sorted(glob.glob(os.path.join(FORMS_DIR, '*.txt'))):
        with open(filename, 'rb') as f:
            content = f.read()
            hasher.update(content)
        if LOG_SYNC_FORMS:
            with open(filename, 'r') as f:
                log_event("Hashing " + filename + ": " + f.read()[:50], ui=False, sync_forms=True)  # Debug only
    return hasher.hexdigest()

def check_forms_changed():
    global last_mtime
    current_mtime = max([os.path.getmtime(f) for f in glob.glob(os.path.join(FORMS_DIR, '*.txt'))] or [0])
    if current_mtime > last_mtime:
        last_mtime = current_mtime
        log_event("Forms directory changed, new mtime: " + str(current_mtime), ui=False, sync_state=LOG_FORM_SYNC)  # Debug only
        return True
    return False

def update_forms_index():
    md5_hash = hash_forms_dir()
    if LOG_FORM_SYNC and check_forms_changed():
        log_event("Forms changed, new MD5: " + md5_hash, ui=False, sync_state=True)  # Debug only
    return md5_hash

def broadcast_forms_md5(stop_event):
    global forms_md5
    log_event("Starting broadcast_forms_md5 thread", ui=False, thread_state=LOG_FORM_SYNC)  # Debug only
    while not stop_event.is_set():
        start_time = time.time()
        forms_md5 = update_forms_index()
        log_event("Computed forms MD5: " + forms_md5, ui=False, sync_state=LOG_FORM_SYNC)  # Debug only
        packet = "MD5|" + CALLSIGN + "|NONE|" + forms_md5 + "\n"
        if LOG_PACKET_BUILD:
            log_event("Built MD5 packet: " + packet.strip(), ui=False, packet_build=True)  # Debug only
        log_comms(packet.strip())  # Raw packet to Comms Log
        with clients_lock:
            active_clients = []
            now = time.time()
            for client_socket, addr, callsign, last_data_time in clients[:]:
                if client_socket is None:
                    continue
                if addr in syncing_clients:
                    if LOG_SYNC_STATE:
                        log_event("Skipping MD5 broadcast to syncing client " + str(addr), ui=False, sync_state=True)
                    active_clients.append((client_socket, addr, callsign, last_data_time))
                    continue
                last_sent = last_broadcast.get(addr, 0)
                if now - last_sent < 10:
                    if LOG_SYNC_STATE:
                        log_event("Skipping MD5 broadcast to " + str(addr) + " (debounced)", ui=False, sync_state=True)
                    active_clients.append((client_socket, addr, callsign, last_data_time))
                    continue
                try:
                    client_socket.send(packet.encode())
                    last_broadcast[addr] = now
                    active_clients.append((client_socket, addr, callsign, last_data_time))
                    if LOG_SOCKET_STATE:
                        log_event("Broadcast to " + str(addr) + " successful", ui=False, socket_state=True)  # Debug only
                except Exception as e:
                    log_event("Broadcast to " + str(addr) + " failed: " + str(e), ui=False, segment_failure=True)
                    if LOG_SOCKET_STATE:
                        log_event("Socket state: Broadcast failed for " + str(addr), ui=False, socket_state=True)
            clients[:] = active_clients
        log_event(f"Post-broadcast packet_queue size: {packet_queue.qsize()}", ui=False, queue_state=True)  # Debug only
        elapsed = time.time() - start_time
        time.sleep(max(0, BROADCAST_INTERVAL - elapsed))

# Chunk 4 v2.5 - Submission Handling (was Chunk 5)
def handle_client(client_socket, address):
    log_event("Client connected: " + str(address), ui=False)  # Debug only
    if LOG_SOCKET_STATE:
        log_event("Socket state: New client connection from " + str(address), ui=False, socket_state=True)
    if LOG_CLIENT_STATE:
        log_event("New client " + str(address) + " added", ui=False, client_state=True)
    client_callsign = None
    last_data_time = time.time()
    with clients_lock:
        clients.append((client_socket, address, None, last_data_time))
    buffer = ""
    segments = {}
    while True:
        readable, _, _ = select.select([client_socket], [], [], 1.0)
        if readable:
            try:
                data = client_socket.recv(512).decode()
                if not data:
                    raise ConnectionError("Client closed")
                last_data_time = time.time()
                buffer += data
                while '\n' in buffer:
                    packet_end = buffer.find('\n')
                    if packet_end == -1:
                        break
                    packet = buffer[:packet_end].strip()
                    buffer = buffer[packet_end+1:]
                    log_comms(packet)  # Raw incoming packet to Comms Log
                    if LOG_PACKET_PARSE:
                        log_event("Received packet: " + packet[:50], ui=False, packet_parse=True)
                    if LOG_CLIENT_PACKET:
                        log_event("Raw packet from " + str(address) + ": " + packet, ui=False, client_packet=True)  # Debug only
                    parts_count = len(packet.split('|'))
                    ends_with_newline = data.endswith('\n')
                    if LOG_PACKET_INTEGRITY:
                        log_event("Received packet structure: parts=" + str(parts_count) + ", ends_with_newline=" + str(ends_with_newline), ui=False, packet_integrity=True)
                    try:
                        packet_queue.put_nowait((client_socket, address, packet, last_data_time))
                        if LOG_PACKET_QUEUE:
                            log_event("Enqueued packet from " + str(address) + ": " + packet[:50], ui=False, packet_queue=True)
                        if LOG_CLIENT_QUEUE:
                            log_event("Client " + str(address) + " packet queued: " + packet[:50], ui=False, client_queue=True)
                        if LOG_QUEUE_STATE:
                            log_event("Queue state: size=" + str(packet_queue.qsize()) + ", full=" + str(packet_queue.full()), ui=False, queue_state=True)
                    except queue.Full:
                        log_event("Queue full, dropped packet from " + str(address) + ": " + packet[:50], ui=False, packet_queue=True, packet_drop=True)
            except Exception as e:
                log_event("Client error " + str(address) + ": " + str(e), ui=False, segment_failure=True)  # Debug only
                break
        time.sleep(0.1)
    client_socket.close()
    if LOG_SOCKET_STATE:
        log_event("Socket state: Client " + str(address) + " disconnected", ui=False, socket_state=True)
    if LOG_CLIENT_STATE:
        log_event("Client " + str(address) + " (callsign: " + str(client_callsign) + ") disconnected", ui=False, client_state=True)
    with clients_lock:
        for i, (cs, addr, cc, ls) in enumerate(clients):
            if cs == client_socket:
                clients[i] = (None, addr, cc, ls)
                break
    if address in syncing_clients:
        syncing_clients.remove(address)
        if LOG_SYNC_COMPLETION:
            log_event("Sync aborted for " + str(address) + " due to disconnect", ui=False, sync_completion=True)
    log_event("Client disconnected: " + str(address), ui=False)  # Debug only

# Chunk 5 v2.5 - Forms Management Utils (was Chunk 6)
def load_form_data(form_id):
    file_path = os.path.join(FORMS_DIR, form_id + ".txt")
    if not os.path.exists(file_path):
        log_event("Form file not found: " + file_path, ui=False)  # Debug only
        return None
    form_data = {'desc': '', 'fields': {}}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('desc:'):
                form_data['desc'] = line.split(':', 1)[1]
            else:
                fid, label, row, col, length = line.split(',')
                form_data['fields'][fid] = {
                    'label': label,
                    'row': int(row),
                    'col': int(col),
                    'len': int(length)
                }
    return form_data

def create_form(form_id, desc, fields):
    file_path = os.path.join(FORMS_DIR, form_id + ".txt")
    with open(file_path, 'w') as f:
        f.write("desc:" + desc + "\n")
        for fid, field in fields.items():
            f.write(fid + "," + field['label'] + "," + str(field['row']) + "," + str(field['col']) + "," + str(field['len']) + "\n")
    log_event("Created/Updated form: " + form_id, ui=False)  # Debug only

# Chunk 6 v2.5 - People.csv Initialization (was Chunk 7)
def init_people_csv():
    people_file = os.path.join(DATA_DIR, 'people.csv')
    if not os.path.exists(people_file) or os.path.getsize(people_file) == 0:
        log_event("Seeding " + people_file + " with initial data", ui=False)  # Debug only
        with open(people_file, 'w') as f:
            f.write("id,name\n")
            f.write("P001,John Doe\n")
            f.write("P002,Jane Smith\n")
            f.write("P003,Alice Johnson\n")
            f.write("P004,Bob Brown\n")
            f.write("P005,Carol White\n")
            f.write("P006,David Green\n")
        log_event("Seeded " + people_file + " with 6 entries", ui=False)  # Debug only

# Chunk 7 v2.5 - UI Colors (split from Chunk 8)
def init_colors():
    log_event("Initializing colors", ui=False)  # Debug only
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)
    return 1, 2, 3, 4

# Chunk 8 v2.5 - Forms Management Screen (split from Chunk 8)
def forms_management_screen(stdscr):
    curses.curs_set(0)
    stdscr.nodelay(True)
    selection = 0
    screen_dirty = True
    if LOG_UI_TRANSITIONS:
        log_event("Entering Forms Management", ui=False, ui_transitions=True)  # Debug only
    while True:
        forms = sorted([f for f in os.listdir(FORMS_DIR) if re.match(r'[A-Z][A-Z][0-9][0-9]\.txt', f, re.IGNORECASE)])
        if screen_dirty:
            stdscr.clear()
            stdscr.addstr(0, 0, "Forms Management", curses.color_pair(4))
            stdscr.addstr(2, 2, "Current Forms:", curses.color_pair(4))
            for i, form in enumerate(forms[:15], start=3):
                if i - 3 == selection:
                    stdscr.addstr(i, 4, form[:-4], curses.color_pair(2) | curses.A_REVERSE)
                else:
                    stdscr.addstr(i, 4, form[:-4], curses.color_pair(2))
            if forms and selection < len(forms):
                form_id = forms[selection][:-4]
                form_data = load_form_data(form_id)
                if form_data:
                    stdscr.addstr(2, 40, "Form: " + form_id, curses.color_pair(4))
                    stdscr.addstr(3, 40, "Desc: " + form_data['desc'][:36], curses.color_pair(2))
                    stdscr.addstr(4, 40, "ID:Label (Row,Col,Len)", curses.color_pair(4))
                    line = 5
                    for fid, field in sorted(form_data['fields'].items()):
                        if line < 18:
                            text = fid + ":" + field['label'] + " (" + str(field['row']) + "," + str(field['col']) + "," + str(field['len']) + ")"
                            stdscr.addstr(line, 42, text[:36], curses.color_pair(2))
                            line += 1
            stdscr.addstr(19, 2, "C=Create Enter=Edit D=Delete Esc=Back", curses.color_pair(2))
            stdscr.refresh()
            screen_dirty = False
            if LOG_UI_RENDER:
                log_event("Rendered forms management screen", ui=False, ui_render=True)  # Debug only
        char = stdscr.getch()
        if char == -1:
            continue
        if char == curses.KEY_UP and selection > 0:
            selection -= 1
            screen_dirty = True
        elif char == curses.KEY_DOWN and selection < len(forms) - 1 and selection < 14:
            selection += 1
            screen_dirty = True
        elif char == ord('c') or char == ord('C'):
            form_edit_screen(stdscr, None)
            screen_dirty = True
        elif char == 10 and forms:
            form_id = forms[selection][:-4]
            form_edit_screen(stdscr, form_id)
            screen_dirty = True
        elif char == ord('d') or char == ord('D') and forms:
            form_id = forms[selection][:-4]
            stdscr.clear()
            stdscr.addstr(0, 0, "Delete Form: " + form_id, curses.color_pair(4))
            stdscr.addstr(2, 2, "Confirm Delete (Y/N)? ", curses.color_pair(2))
            stdscr.refresh()
            stdscr.nodelay(False)
            char = stdscr.getch()
            stdscr.nodelay(True)
            if char == ord('y') or char == ord('Y'):
                delete_form(form_id)
            screen_dirty = True
        elif char == 27:
            if LOG_UI_TRANSITIONS:
                log_event("Exiting Forms Management", ui=False, ui_transitions=True)  # Debug only
            return

# Chunk 9 v2.5 - Form Edit Screen (split from Chunk 8)
def form_edit_screen(stdscr, form_id):
    # CHANGE v2.5: Updated UI to cols 13-48/49-80 (36/32 chars), Lxx/Rxx only, placeholders for Form ID/Desc
    curses.curs_set(0)
    stdscr.nodelay(True)
    screen_dirty = True
    RED, GREEN, _, LIGHT_BLUE = init_colors()
    max_y, max_x = stdscr.getmaxyx()  # Typically 24x80
    cursor_row, cursor_col = 3, 13  # Start at L01 (row 3, col 13)
    table = defaultdict(lambda: {'label': ''})  # (row, col) -> {label}
    if form_id:
        form_data = load_form_data(form_id)
        if form_data:
            table[(3, 13)] = {'label': form_id}  # L01
            table[(3, 49)] = {'label': form_data['desc']}  # R01
            for fid, field in sorted(form_data['fields'].items(), key=lambda x: (x[1]['row'], x[1]['col'])):
                row = field['row'] + 1 if field['row'] > 3 else field['row']  # Shift old rows
                col = 13 if field['col'] == 12 else 49
                table[(row, col)] = {'label': field['label']}
    else:
        table[(3, 13)] = {'label': '(Form ID)'}
        table[(3, 49)] = {'label': '(Form Description)'}
    if LOG_UI_TRANSITIONS:
        log_event("Entering Form Edit for " + (form_id or 'new form'), ui=False, ui_transitions=True)  # Debug only
    while True:
        if screen_dirty:
            stdscr.clear()
            border = "=" * (max_x - 2)
            stdscr.addstr(0, 0, border, curses.color_pair(RED))
            for row in range(3, 18):
                left = table[(row, 13)]['label']
                right = table[(row, 49)]['label']
                # Left cell: [label                    ] (13-48, 36 chars)
                stdscr.addstr(row, 13, "[", curses.color_pair(GREEN))
                stdscr.addstr(row, 14, left[:34].ljust(34), curses.color_pair(GREEN if row > 3 else LIGHT_BLUE))
                stdscr.addstr(row, 48, "]", curses.color_pair(GREEN))
                # Right cell: [label                  ] (49-80, 32 chars)
                stdscr.addstr(row, 49, "[", curses.color_pair(GREEN))
                stdscr.addstr(row, 50, right[:30].ljust(30), curses.color_pair(GREEN if row > 3 else LIGHT_BLUE))
                stdscr.addstr(row, 80, "]", curses.color_pair(GREEN))
                if row == cursor_row:
                    stdscr.addstr(row, cursor_col, '■', curses.color_pair(GREEN))
            stdscr.addstr(max_y - 2, 2, "= Arrows/Tab/Shift-Tab=Move D=Delete S=Submit C=Cancel =", curses.color_pair(GREEN))
            stdscr.addstr(max_y - 1, 0, border, curses.color_pair(RED))
            stdscr.refresh()
            screen_dirty = False
            if LOG_FORM_PREVIEW:
                log_event(f"Table preview: {dict(table)}", ui=False, form_preview=True)  # Debug only
            if LOG_UI_RENDER:
                log_event(f"Rendered form edit screen for {form_id or 'new form'}", ui=False, ui_render=True)  # Debug only
        char = stdscr.getch()
        if char == -1:
            time.sleep(0.05)
            continue
        if char == curses.KEY_UP and cursor_row > 3:
            cursor_row -= 1
            screen_dirty = True
        elif char == curses.KEY_DOWN and cursor_row < 17:
            cursor_row += 1
            screen_dirty = True
        elif char == curses.KEY_RIGHT and cursor_col == 13:
            cursor_col = 49
            screen_dirty = True
        elif char == curses.KEY_LEFT and cursor_col == 49:
            cursor_col = 13
            screen_dirty = True
        elif char == 9:  # Tab
            if cursor_col == 13 and cursor_row < 17:
                cursor_col = 49
            elif cursor_col == 49 and cursor_row < 17:
                cursor_col = 13
                cursor_row += 1
            elif cursor_row == 17:
                cursor_col = 13
                cursor_row = 3
            screen_dirty = True
        elif char == curses.KEY_BTAB:  # Shift-Tab
            if cursor_col == 49 and cursor_row > 3:
                cursor_col = 13
            elif cursor_col == 13 and cursor_row > 3:
                cursor_col = 49
                cursor_row -= 1
            elif cursor_row == 3:
                cursor_col = 49
                cursor_row = 17
            screen_dirty = True
        elif char == 10:
            stdscr.nodelay(False)
            curses.curs_set(1)
            col_name = 'L' if cursor_col == 13 else 'R'
            current_label = table[(cursor_row, cursor_col)]['label']
            max_len = 34 if col_name == 'L' else 30
            stdscr.addstr(cursor_row, cursor_col + 1, " " * max_len, curses.color_pair(GREEN))
            curses.echo()
            new_label = stdscr.getstr(cursor_row, cursor_col + 1, max_len).decode().strip()
            curses.noecho()
            if new_label and new_label not in ['(Form ID)', '(Form Description)']:
                table[(cursor_row, cursor_col)] = {'label': new_label}
                if LOG_TABLE_EDIT:
                    log_event(f"Edited {col_name} at row {cursor_row}, col {cursor_col} to '{new_label}'", ui=False, table_edit=True)  # Debug only
            elif not new_label and current_label in ['(Form ID)', '(Form Description)']:
                table[(cursor_row, cursor_col)] = {'label': current_label}
            stdscr.nodelay(True)
            curses.curs_set(0)
            screen_dirty = True
        elif char == ord('d') or char == ord('D'):
            if table[(cursor_row, cursor_col)]['label'] not in ['(Form ID)', '(Form Description)']:
                col_name = 'L' if cursor_col == 13 else 'R'
                old_label = table[(cursor_row, cursor_col)]['label']
                del table[(cursor_row, cursor_col)]
                if LOG_TABLE_EDIT:
                    log_event(f"Deleted {col_name} at row {cursor_row}, col {cursor_col} (was '{old_label}')", ui=False, table_edit=True)  # Debug only
                screen_dirty = True
        elif char == ord('s') or char == ord('S'):
            form_id_val = table[(3, 13)]['label']
            form_desc = table[(3, 49)]['label']
            if (form_id_val not in ['', '(Form ID)'] and
                form_desc not in ['', '(Form Description)'] and
                any(table[(r, c)]['label'] not in ['', '(Form ID)', '(Form Description)'] for r, c in table if r > 3)):
                fields_dict = {}
                for (row, col) in sorted(table.keys()):
                    label = table[(row, col)]['label']
                    if label and label not in ['(Form ID)', '(Form Description)']:
                        fid = f"{'L' if col == 13 else 'R'}{row - 2:02d}"
                        fields_dict[fid] = {
                            'label': label.upper() if row == 3 else label,
                            'row': row,
                            'col': 12 if col == 13 else 32,  # Map to client cols
                            'len': 256
                        }
                create_form(form_id_val.upper(), form_desc.upper(), fields_dict)
                if LOG_FORM_SAVE:
                    log_event(f"Saved form {form_id_val.upper()} with fields: {fields_dict}", ui=False, form_save=True)  # Debug only
                if LOG_UI_TRANSITIONS:
                    log_event("Form " + form_id_val.upper() + " submitted, exiting edit", ui=False, ui_transitions=True)  # Debug only
                return
            screen_dirty = True
        elif char == 27 or char == ord('c') or char == ord('C'):
            if LOG_UI_TRANSITIONS:
                log_event("Form edit cancelled", ui=False, ui_transitions=True)  # Debug only
            return

# Chunk 10 v2.5 - Update UI (split from Chunk 8)
def update_ui(stdscr):
    global screen_dirty, show_menu, menu_selection
    if not screen_dirty:
        return
    max_y, max_x = stdscr.getmaxyx()
    stdscr.clear()
    border = "=" * (max_x - 2)
    stdscr.addstr(0, 0, border, curses.color_pair(1))
    stdscr.addstr(1, 2, "Packet Radio Server Status", curses.color_pair(4))
    stdscr.addstr(2, 2, "Recent Clients:", curses.color_pair(4))
    with clients_lock:
        now = time.time()
        clients[:] = [(cs, addr, cc, ls) for cs, addr, cc, ls in clients if now - ls < CLIENT_TIMEOUT]
        for i, (cs, addr, cc, ls) in enumerate(clients[:max_y-4], start=3):
            timestamp = datetime.fromtimestamp(ls).strftime('%H:%M:%S')
            display = (cc or 'Unknown') + " (" + str(addr[0]) + ") - " + timestamp
            stdscr.addstr(i, 4, display[:max_x//2-6], curses.color_pair(2))
    log_x = max_x // 2 + 1
    stdscr.addstr(1, log_x, "Comms Log", curses.color_pair(4))
    stdscr.addstr(2, log_x, "=" * ((max_x - log_x - 1) // 2), curses.color_pair(1))
    for i, (msg, ts) in enumerate(comms_log[-(max_y-5):], start=3):
        if i < max_y-2:
            stdscr.addstr(i, log_x, (msg[:max_x-log_x-1] + " - " + ts)[:max_x-log_x-1], curses.color_pair(2))
    stdscr.addstr(max_y-1, 0, border, curses.color_pair(1))
    stdscr.addstr(max_y-2, 2, "= Press Q to Quit D=Menu =", curses.color_pair(2))
    if show_menu:
        menu_width = 22
        menu_height = 8
        menu_y = (max_y - menu_height) // 2
        menu_x = (max_x - menu_width) // 2
        options = [("Main Screen", True), ("Forms Management", True), ("Quit", True)]
        stdscr.addstr(menu_y, menu_x, "+====================+", curses.color_pair(1))
        for i, (opt, active) in enumerate(options):
            color = 2 if active else 1
            if i == menu_selection:
                stdscr.addstr(menu_y + 1 + i, menu_x, "| " + opt.ljust(18) + " |", curses.color_pair(color) | curses.A_REVERSE)
            else:
                stdscr.addstr(menu_y + 1 + i, menu_x, "| " + opt.ljust(18) + " |", curses.color_pair(color))
        stdscr.addstr(menu_y + 4, menu_x, "| Up/Down=Move       |", curses.color_pair(2))
        stdscr.addstr(menu_y + 5, menu_x, "| Enter=Sel Esc=Back |", curses.color_pair(2))
        stdscr.addstr(menu_y + 6, menu_x, "+====================+", curses.color_pair(1))
    stdscr.refresh()
    screen_dirty = False
    if LOG_UI_RENDER:
        # CHANGE v2.5: Throttle UI render logging to once per second to reduce debug log spam
        global last_ui_render_log
        if 'last_ui_render_log' not in globals():
            last_ui_render_log = 0
        now = time.time()
        if now - last_ui_render_log >= 1.0:  # Log every 1s
            log_event("Rendered main UI screen", ui=False, ui_render=True)  # Debug only
            last_ui_render_log = now

# Chunk 11 v2.5 - Server Comms (was Chunk 9)
def accept_clients(server, stop_event):
    log_event("Starting accept_clients thread", ui=False, thread_state=True)  # Debug only
    while not stop_event.is_set():
        try:
            log_event(f"Listening for client connection on {SERVER_HOST}:{SERVER_PORT}", ui=False, connection_attempts=True)  # Debug only
            client_socket, address = server.accept()
            log_event("Accepted connection from " + str(address), ui=False)  # Debug only
            if LOG_SOCKET_STATE:
                log_event("Socket state: Accepted connection from " + str(address), ui=False, socket_state=True)
            client_thread = threading.Thread(target=handle_client, args=(client_socket, address))
            client_thread.daemon = True
            client_thread.start()
            if LOG_THREAD_STATE:
                log_event(f"Started client thread for {address}", ui=False, thread_state=True)  # Debug only
        except Exception as e:
            log_event("Accept error: " + str(e), ui=False)  # Debug only
            if LOG_SOCKET_STATE:
                log_event("Socket state: Accept failed - " + str(e), ui=False, socket_state=True)
        time.sleep(0.1)

# Chunk 12 v2.5 - Main Loop (was Chunk 10)
def main(stdscr):
    global CALLSIGN, screen_dirty, show_menu, menu_selection
    os.makedirs(DATA_DIR, exist_ok=True)
    os.makedirs(FORMS_DIR, exist_ok=True)
    CALLSIGN = get_callsign(stdscr)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    stdscr.clear()
    stdscr.nodelay(True)
    stdscr.refresh()
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((SERVER_HOST, SERVER_PORT))
    server.listen(5)
    log_event("Server running on " + SERVER_HOST + ":" + str(SERVER_PORT) + " (v" + VERSION + ")", ui=False)  # Debug only
    if LOG_SOCKET_STATE:
        log_event("Socket state: Server bound and listening on " + SERVER_HOST + ":" + str(SERVER_PORT), ui=False, socket_state=True)
    init_people_csv()
    stop_event = threading.Event()
    broadcast_thread = threading.Thread(target=broadcast_forms_md5, args=(stop_event,))
    broadcast_thread.daemon = True
    broadcast_thread.start()
    if LOG_THREAD_STATE:
        log_event("Broadcast thread started", ui=False, thread_state=True)  # Debug only
    accept_thread = threading.Thread(target=accept_clients, args=(server, stop_event))
    accept_thread.daemon = True
    accept_thread.start()
    if LOG_THREAD_STATE:
        log_event("Accept thread started", ui=False, thread_state=True)  # Debug only
    if LOG_UI_TRANSITIONS:
        log_event("Entering main UI loop", ui=False, ui_transitions=True)  # Debug only
    while True:
        update_ui(stdscr)
        char = stdscr.getch()
        if char == ord('q') or char == ord('Q') and not show_menu:
            log_event("Quitting via Q", ui=False)  # Debug only
            stop_event.set()
            log_event("Server shutdown complete", ui=False)  # Debug only
            if LOG_UI_TRANSITIONS:
                log_event("Exiting main UI loop", ui=False, ui_transitions=True)  # Debug only
            break
        elif char == ord('d') or char == ord('D'):
            show_menu = not show_menu
            menu_selection = 0
            screen_dirty = True
            if LOG_UI_TRANSITIONS:
                log_event("Menu toggled: " + str(show_menu), ui=False, ui_transitions=True)  # Debug only
        elif show_menu:
            if char == curses.KEY_UP and menu_selection > 0:
                menu_selection -= 1
                screen_dirty = True
            elif char == curses.KEY_DOWN and menu_selection < 2:
                menu_selection += 1
                screen_dirty = True
            elif char == 10:
                if menu_selection == 0:
                    show_menu = False
                    if LOG_UI_TRANSITIONS:
                        log_event("Returning to Main Screen", ui=False, ui_transitions=True)  # Debug only
                elif menu_selection == 1:
                    forms_management_screen(stdscr)
                elif menu_selection == 2:
                    log_event("Quitting via menu", ui=False)  # Debug only
                    stop_event.set()
                    log_event("Server shutdown complete", ui=False)  # Debug only
                    if LOG_UI_TRANSITIONS:
                        log_event("Exiting via menu quit", ui=False, ui_transitions=True)  # Debug only
                    break
                screen_dirty = True
            elif char == 27:
                show_menu = False
                screen_dirty = True
                if LOG_UI_TRANSITIONS:
                    log_event("Escaping menu to Main Screen", ui=False, ui_transitions=True)  # Debug only
        if not show_menu or menu_selection != 1:
            while not packet_queue.empty():
                try:
                    client_socket, address, packet, last_data_time = packet_queue.get_nowait()
                    if LOG_PACKET_QUEUE:
                        log_event("Dequeued packet from " + str(address) + ": " + packet[:50], ui=False, packet_queue=True)
                    if LOG_UI_PACKET_HANDLING:
                        log_event("UI handling packet from " + str(address) + ": " + packet[:50], ui=False, ui_packet_handling=True)
                    if LOG_QUEUE_STATE:
                        log_event("Queue state after dequeue: size=" + str(packet_queue.qsize()) + ", empty=" + str(packet_queue.empty()), ui=False, queue_state=True)
                    parts = packet.split('|', 3)
                    if len(parts) != 4:
                        log_event("Malformed packet: " + packet[:50], ui=False, segment_failure=True)  # Debug only
                        continue
                    function, callsign, form_id, payload = parts
                    with clients_lock:
                        for i, (cs, addr, _, ls) in enumerate(clients):
                            if cs == client_socket:
                                clients[i] = (cs, addr, callsign, last_data_time)
                                if LOG_CLIENT_STATE:
                                    log_event("Updated callsign for " + str(addr) + " to " + callsign, ui=False, client_state=True)
                                break
                    if function == 'INSERT':
                        log_event(f"Received INSERT from {callsign} for {form_id}: {payload[:50]}", ui=False, submissions=True)  # Debug only
                        if ':' in payload[:5]:
                            seq, total = map(int, payload.split('|', 1)[0].split(':'))
                            payload = payload.split('|', 1)[1]
                            key = callsign + ":" + form_id
                            segments.setdefault(key, {})[seq] = payload
                            log_event("Stored segment " + str(seq) + "/" + str(total) + " for " + key, ui=False, submissions=True)
                            if LOG_PACKET_FRAGMENTS:  # CHANGE v2.5: Added for fragment tracking
                                log_event(f"Fragment {seq}/{total} stored for {key}: {payload[:50]}", ui=False, packet_fragments=True)
                            if len(segments[key]) == total:
                                full_payload = ''.join(segments[key][i] for i in sorted(segments[key]))
                                csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                                os.makedirs(DATA_DIR, exist_ok=True)
                                with open(csv_path, 'a') as f:
                                    f.write(str(int(time.time())) + "," + callsign + "," + full_payload + "\n")
                                log_event("Submission saved to " + csv_path, ui=False, submissions=True)
                                response = "ACK|" + CALLSIGN + "|" + form_id + "|SUCCESS\n"
                                client_socket.send(response.encode())
                                log_comms(response.strip())  # Raw outgoing packet to Comms Log
                                if LOG_PACKET_BUILD:
                                    log_event("Built ACK packet: " + response.strip(), ui=False, packet_build=True)
                                del segments[key]
                        else:
                            csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                            os.makedirs(DATA_DIR, exist_ok=True)
                            with open(csv_path, 'a') as f:
                                f.write(str(int(time.time())) + "," + callsign + "," + payload + "\n")
                            log_event("Submission saved to " + csv_path, ui=False, submissions=True)
                            response = "ACK|" + CALLSIGN + "|" + form_id + "|SUCCESS\n"
                            client_socket.send(response.encode())
                            log_comms(response.strip())  # Raw outgoing packet to Comms Log
                            if LOG_PACKET_BUILD:
                                log_event("Built ACK packet: " + response.strip(), ui=False, packet_build=True)
                    elif function == 'SEARCH':
                        if LOG_SEARCH_QUERY:
                            log_event("Received search from " + callsign + ": " + packet[:50], ui=False, search_query=True)
                        search_fields = {}
                        for pair in payload.split('|'):
                            if not pair:
                                if LOG_SEARCH_PARSING:
                                    log_event("Skipping empty pair in payload", ui=False, search_parsing=True)
                                continue
                            key = pair[:2]
                            value = pair[2:] if len(pair) > 2 else ""
                            search_fields[key] = value
                            if LOG_SEARCH_PARSING:
                                log_event("Parsed field: " + key + "='" + value + "'", ui=False, search_parsing=True)
                        csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                        matches = []
                        if os.path.exists(csv_path):
                            with open(csv_path, 'r') as f:
                                for line in f:
                                    _, _, row_payload = line.strip().split(',', 2)
                                    if LOG_CSV_PROCESSING:
                                        log_event("Processing CSV row: " + row_payload[:50], ui=False, csv_processing=True)
                                    fields = {}
                                    for field in row_payload.split('|'):
                                        if field:
                                            fields[field[:2]] = field[2:] if len(field) > 2 else ""
                                            if LOG_CSV_PROCESSING:
                                                log_event("Parsed CSV field: " + field[:2] + "='" + fields[field[:2]] + "'", ui=False, csv_processing=True)
                                    match = all(fields.get(k, '') == v for k, v in search_fields.items() if v)
                                    if match:
                                        matches.append(row_payload)
                                    if LOG_CSV_PROCESSING:
                                        log_event("Match check for " + str(search_fields) + ": " + ("Yes" if match else "No"), ui=False, csv_processing=True)
                        response = "SEARCH_RESULT|" + CALLSIGN + "|" + form_id + "|" + '~'.join(matches) + "\n"
                        client_socket.send(response.encode())
                        log_comms(response.strip())  # Raw outgoing packet to Comms Log
                        if LOG_SEARCH_RESULTS:
                            log_event("Sent search results to " + callsign + ": " + response[:50], ui=False, search_results=True)
                        if LOG_PACKET_BUILD:
                            log_event("Built SEARCH_RESULT packet: " + response.strip(), ui=False, packet_build=True)
                    elif function == 'UPDATE':
                        if LOG_SYNC_STATE:
                            log_event("Received UPDATE from " + callsign + ": " + payload[:50], ui=False, sync_state=True)
                        syncing_clients.add(address)
                        if LOG_SYNC_START:
                            log_event("Sync started for " + str(address), ui=False, sync_start=True)
                        client_forms = {}
                        for pair in payload.split('|'):
                            if ':' in pair:
                                fname, fhash = pair.split(':', 1)
                                client_forms[fname] = fhash
                                if LOG_SYNC_FORMS:
                                    log_event("Client form " + fname + " hash: " + fhash, ui=False, sync_forms=True)
                        server_forms = {}
                        for fname in glob.glob(os.path.join(FORMS_DIR, '*.txt')):
                            fname = os.path.basename(fname)[:-4]
                            with open(os.path.join(FORMS_DIR, fname + ".txt"), 'rb') as f:
                                server_hash = hashlib.md5(f.read()).hexdigest()
                                server_forms[fname] = server_hash
                            if LOG_SYNC_FORMS:
                                log_event("Server form " + fname + " hash: " + server_hash, ui=False, sync_forms=True)
                        for fname, server_hash in server_forms.items():
                            if fname not in client_forms or client_forms[fname] != server_hash:
                                with open(os.path.join(FORMS_DIR, fname + ".txt"), 'r') as f:
                                    content = f.read().strip()
                                content_replaced = content.replace('\n', '~')
                                response = f"FORM_UPDATE|{CALLSIGN}|{fname}|{content_replaced}\n"  # CHANGE v2.5: Fixed TYPE bug by using fname directly
                                client_socket.send(response.encode())
                                log_comms(response.strip())  # Raw outgoing packet to Comms Log
                                if LOG_PACKET_BUILD:
                                    log_event("Built FORM_UPDATE packet: " + response.strip(), ui=False, packet_build=True)
                                if LOG_FORM_SYNC:
                                    log_event("Sent form update for " + fname + " to " + callsign, ui=False, sync_state=True)
                                if LOG_PACKET_INTEGRITY:
                                    log_event("FORM_UPDATE sent: len=" + str(len(response)) + ", newlines=" + str(response.count('\n')), ui=False, packet_integrity=True)
                            elif client_forms[fname] != server_hash and LOG_FORM_SYNC_ERROR:
                                log_event(f"Sync mismatch for {fname}: client hash {client_forms[fname]} != server hash {server_hash}", ui=False, form_sync_error=True)  # CHANGE v2.5: Added for sync issues
                            if LOG_SYNC_MISMATCHES and client_forms.get(fname) != server_hash:  # CHANGE v2.5: Added for mismatch details
                                log_event(f"MD5 mismatch: {fname} - client: {client_forms.get(fname, 'N/A')}, server: {server_hash}", ui=False, sync_mismatches=True)
                        for fname in client_forms:
                            if fname not in server_forms:
                                response = "FORM_DELETE|" + CALLSIGN + "|" + fname + "|\n"
                                client_socket.send(response.encode())
                                log_comms(response.strip())  # Raw outgoing packet to Comms Log
                                if LOG_PACKET_BUILD:
                                    log_event("Built FORM_DELETE packet: " + response.strip(), ui=False, packet_build=True)
                                if LOG_FORM_DELETION:
                                    log_event("Sent FORM_DELETE for " + fname + " to " + callsign, ui=False, form_deletion=True)
                                if LOG_PACKET_INTEGRITY:
                                    log_event("FORM_DELETE sent: len=" + str(len(response)) + ", newlines=" + str(response.count('\n')), ui=False, packet_integrity=True)
                        syncing_clients.remove(address)
                        if LOG_SYNC_COMPLETION:
                            log_event("Sync completed for " + str(address), ui=False, sync_completion=True)
                    packet_queue.task_done()
                except queue.Empty:
                    break
        time.sleep(0.05)
    server.close()
    if LOG_SOCKET_STATE:
        log_event("Socket state: Server socket closed", ui=False, socket_state=True)

# Chunk 13 v2.5 - Design Goals and Statuses (was Chunk 11)
# DESIGN GOALS:
# - v2.03.2: Fix comms_log NameError by moving globals above log_event - Done
# - v2.03.3: Fix QUEUE_MAXSIZE NameError by moving packet_queue after config - Done
# - v2.03.5: Add default callsign SVR001, show packets in UI, enhance logging for troubleshooting - Done
# - v2.1: Add two-column form support with Lxx/Rxx field IDs in form_edit_screen - Done
# - v2.2: Fix Lxx/Rxx pairing (e.g., L01/R01 per row), update preview to match client layout, add form troubleshooting logs - Done
# - v2.3: Support uneven Lxx/Rxx columns, replace form_edit_screen with table-based UI, apply consistent theme - Done
# - v2.4: Replace table UI with [ ] cells, integrate Form ID/Desc as L01/R01 (uppercased), use (L/R)(row#) IDs on save, maintain 15-row cap - Done
# - v2.5: Update form_edit_screen UI (cols 13-48, 49-80), enforce Lxx/Rxx only, fix TYPE sync bug, restrict Comms Log to packets only, add troubleshooting logs (ui_render, form_sync_error, packet_fragments, sync_mismatches), throttle UI logging - Done  # CHANGE v2.5: New goals for v2.5
# - Future: Separate people.csv sync (MD5_people:)
# - Future: Add options screen for config and logging control
# CHANGES:
# - v2.3: Updated VERSION to 2.3 (Chunk 1),
#         added collections.defaultdict import (Chunk 1),
#         rewrote form_edit_screen for table UI with uneven column support (Chunk 8),
#         applied update_ui theme (red borders, green text, cyan headers) to form_edit_screen (Chunk 8),
#         capped table at 15 rows (rows 3-17) with Form ID/Desc at top (Chunk 8),
#         fixed typo in log_event ("dishonorificabilitudinitatibusfile" → "file") (Chunk 1),
#         line count increased from 1215 to ~1250 (Chunk 11)
# - v2.4: Rewrote form_edit_screen for [ ] cells (cols 12-48, 42-78), integrated Form ID/Desc as L01/R01 (uppercased), assigned (L/R)(row#) IDs (Chunk 8),
#         added log_table_edit and log_form_save (Chunk 8), turned off log_ui_transitions by default (Chunk 1),
#         line count increased from ~1250 to ~1275 (Chunk 11)
# - v2.5: Updated VERSION to 2.5 (Chunk 1), added log_comms for packet-only Comms Log (Chunk 1), set log_event ui default to False (Chunk 1),
#         updated all chunks to use log_comms for packets and ui=False elsewhere (Chunks 1-12),
#         added log_ui_render, log_form_sync_error, log_packet_fragments, log_sync_mismatches with config toggles (Chunk 1),
#         throttled update_ui logging to 1/sec (Chunk 10), fixed TYPE bug in FORM_UPDATE (Chunk 12),
#         updated form_edit_screen UI to cols 13-48/49-80 (Chunk 9), turned off log_field_positioning (Chunk 1),
#         split UI into 4 chunks (7-10), line count increased from ~1275 to ~1350 due to logging, UI fixes, and comments (Chunk 13)  # CHANGE v2.5: Detailed updates

backup_script()

# Chunk 14 v2.5 - Entry Point (was Chunk 12)
if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except Exception as e:
        with open(LOG_FILE, 'a') as f:
            f.write(str(datetime.now()) + " - Fatal error: " + str(e) + " - traceback: " + traceback.format_exc() + "\n")
        log_event("Startup failed: " + str(e), ui=False, startup_errors=True)  # Debug only
        sys.exit(1)