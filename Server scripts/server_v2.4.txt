#!/usr/bin/env python3
# server.py
# Version 2.4 - 2025-03-11  # CHANGE v2.3: Added uneven Lxx/Rxx support, table-based form UI, consistent theme

# Chunk 1 v2.4 - Imports, Early Globals, and Utilities
import os
import sys
import time
import socket
import threading
import hashlib
import logging
import shutil
import curses
import glob
import select
import traceback
import configparser
import re
import queue
from datetime import datetime
from collections import defaultdict  # CHANGE v2.3: Added for table row tracking in form_edit_screen

# Early globals (no config dependencies)
comms_log = []
screen_dirty = True
clients = []  # (socket, address, callsign, last_data_time)
clients_lock = threading.Lock()
forms_md5 = None
last_mtime = 0
show_menu = False
menu_selection = 0
syncing_clients = set()
last_broadcast = {}

def log_event(message, ui=True, submission_details=False, submissions=False, submission_payload=False, segment_failure=False, socket_state=False, retries=False, ui_transitions=False, search_query=False, search_results=False, search_parsing=False, csv_processing=False, client_state=False, packet_build=False, packet_parse=False, sync_state=False, sync_md5=False, sync_forms=False, client_packet=False, packet_integrity=False, form_deletion=False, sync_start=False, sync_completion=False, packet_queue=False, client_queue=False, ui_packet_handling=False, queue_state=False, startup_errors=False, backups=False, connection_attempts=False, packet_drop=False, thread_state=False, form_field_creation=False, form_preview=False, field_positioning=False, table_edit=False, form_save=False):  # CHANGE v2.4: Added table_edit, form_save for troubleshooting
    logging.info(message)
    if ui:
        comms_log.append((message, datetime.now().strftime('%H:%M:%S')))
        if len(comms_log) > 20:
            comms_log.pop(0)
        global screen_dirty
        screen_dirty = True
    if submission_details and LOG_SUBMISSION_DETAILS: logging.info("Submission Detail: " + message)
    if submissions and LOG_SUBMISSIONS: logging.info("Submission: " + message)
    if submission_payload and LOG_SUBMISSION_PAYLOAD: logging.info("Submission Payload: " + message)
    if segment_failure and LOG_SEGMENT_FAILURE: logging.info("Segment Failure: " + message)
    if socket_state and LOG_SOCKET_STATE: logging.info("Socket State: " + message)
    if retries and LOG_RETRIES: logging.info("Retry: " + message)
    if ui_transitions and LOG_UI_TRANSITIONS: logging.info("UI Transition: " + message)
    if search_query and LOG_SEARCH_QUERY: logging.info("Search Query: " + message)
    if search_results and LOG_SEARCH_RESULTS: logging.info("Search Results: " + message)
    if search_parsing and LOG_SEARCH_PARSING: logging.info("Search Parsing: " + message)
    if csv_processing and LOG_CSV_PROCESSING: logging.info("CSV Processing: " + message)
    if client_state and LOG_CLIENT_STATE: logging.info("Client State: " + message)
    if packet_build and LOG_PACKET_BUILD: logging.info("Packet Build: " + message)
    if packet_parse and LOG_PACKET_PARSE: logging.info("Packet Parse: " + message)
    if sync_state and LOG_SYNC_STATE: logging.info("Sync State: " + message)
    if sync_md5 and LOG_SYNC_MD5: logging.info("Sync MD5: " + message)
    if sync_forms and LOG_SYNC_FORMS: logging.info("Sync Forms: " + message)
    if client_packet and LOG_CLIENT_PACKET: logging.info("Client Packet: " + message)
    if packet_integrity and LOG_PACKET_INTEGRITY: logging.info("Packet Integrity: " + message)
    if form_deletion and LOG_FORM_DELETION: logging.info("Form Deletion: " + message)
    if sync_start and LOG_SYNC_START: logging.info("Sync Start: " + message)
    if sync_completion and LOG_SYNC_COMPLETION: logging.info("Sync Completion: " + message)
    if packet_queue and LOG_PACKET_QUEUE: logging.info("Packet Queue: " + message)
    if client_queue and LOG_CLIENT_QUEUE: logging.info("Client Queue: " + message)
    if ui_packet_handling and LOG_UI_PACKET_HANDLING: logging.info("UI Packet Handling: " + message)
    if queue_state and LOG_QUEUE_STATE: logging.info("Queue State: " + message)
    if startup_errors and LOG_STARTUP_ERRORS: logging.info("Startup Error: " + message)
    if backups: logging.info("Backup: " + message)  # Backups always logged
    if connection_attempts and LOG_CONNECTION_ATTEMPTS: logging.info("Connection Attempt: " + message)
    if packet_drop and LOG_PACKET_DROP: logging.info("Packet Drop: " + message)
    if thread_state and LOG_THREAD_STATE: logging.info("Thread State: " + message)
    if form_field_creation and LOG_FORM_FIELD_CREATION: logging.info("Form Field Creation: " + message)
    if form_preview and LOG_FORM_PREVIEW: logging.info("Form Preview: " + message)
    if field_positioning and LOG_FIELD_POSITIONING: logging.info("Field Positioning: " + message)
    if table_edit and LOG_TABLE_EDIT: logging.info("Table Edit: " + message)  # CHANGE v2.4: Added for cell edit/delete tracking
    if form_save and LOG_FORM_SAVE: logging.info("Form Save: " + message)  # CHANGE v2.4: Added for save details

def backup_script():
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_path = os.path.join(BACKUP_DIR, "server_" + timestamp + ".py")
    shutil.copy2(__file__, backup_path)
    log_event("Backed up to " + backup_path, ui=True, backups=True)

VERSION = "2.4"  # CHANGE v2.4: Bumped from 2.3 for [ ] table UI, L01/R01 uppercase, (L/R)(row#) IDs
PACLEN = 255

config = configparser.ConfigParser()
CONFIG_FILE = None
if not os.path.exists(CONFIG_FILE or ''):
    config['Settings'] = {
        'callsign': 'SVR001',
        'paclen': str(PACLEN),
        'log_client_details': 'True',
        'log_form_sync': 'True',
        'log_submissions': 'True',
        'broadcast_interval': '60',
        'client_timeout': '1800',
        'log_submission_details': 'True',
        'log_packet_parsing': 'False',
        'log_buffer_events': 'False',
        'log_packet_content': 'False',
        'log_payload_processing': 'False',
        'log_submission_payload': 'True',
        'log_segment_failure': 'True',
        'log_socket_state': 'True',
        'log_retries': 'True',
        'log_ui_transitions': 'False',  # CHANGE v2.4: Turned off by default to reduce spam
        'log_search_query': 'True',
        'log_search_results': 'True',
        'log_search_parsing': 'True',
        'log_csv_processing': 'True',
        'log_client_state': 'True',
        'log_packet_build': 'True',
        'log_packet_parse': 'False',
        'log_sync_state': 'True',
        'log_sync_md5': 'False',
        'log_sync_forms': 'False',
        'log_client_packet': 'True',
        'log_packet_integrity': 'True',
        'log_form_deletion': 'True',
        'log_sync_start': 'True',
        'log_sync_completion': 'True',
        'log_packet_queue': 'True',
        'log_client_queue': 'True',
        'log_ui_packet_handling': 'True',
        'log_queue_state': 'True',
        'log_startup_errors': 'True',
        'home_dir': os.path.expanduser('~/terminal'),
        'server_host': '0.0.0.0',
        'server_port': '12345',
        'queue_maxsize': '100',
        'log_connection_attempts': 'True',
        'log_packet_drop': 'True',
        'log_thread_state': 'True',
        'log_form_field_creation': 'True',
        'log_form_preview': 'True',
        'log_field_positioning': 'True',
        'log_table_edit': 'True',  # CHANGE v2.4: Added for table edit/delete tracking
        'log_form_save': 'True'    # CHANGE v2.4: Added for form save details
    }
    HOME_DIR = config['Settings']['home_dir']
    os.makedirs(HOME_DIR, exist_ok=True)
    CONFIG_FILE = os.path.join(HOME_DIR, 'server.conf')
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)
config.read(CONFIG_FILE or os.path.join(os.path.expanduser('~/terminal'), 'server.conf'))
HOME_DIR = config.get('Settings', 'home_dir', fallback=os.path.expanduser('~/terminal'))
CONFIG_FILE = os.path.join(HOME_DIR, 'server.conf')
FORMS_DIR = os.path.join(HOME_DIR, 'forms')
DATA_DIR = os.path.join(HOME_DIR, 'server_data')
LOG_FILE = os.path.join(DATA_DIR, 'server.log')
BACKUP_DIR = os.path.join(HOME_DIR, 'backups')
SERVER_HOST = config.get('Settings', 'server_host', fallback='0.0.0.0')
SERVER_PORT = config.getint('Settings', 'server_port', fallback=12345)
CALLSIGN = config.get('Settings', 'callsign', fallback='SVR001')
PACLEN = config.getint('Settings', 'paclen', fallback=PACLEN)
LOG_CLIENT_DETAILS = config.getboolean('Settings', 'log_client_details', fallback=True)
LOG_FORM_SYNC = config.getboolean('Settings', 'log_form_sync', fallback=True)
LOG_SUBMISSIONS = config.getboolean('Settings', 'log_submissions', fallback=True)
BROADCAST_INTERVAL = config.getint('Settings', 'broadcast_interval', fallback=60)
CLIENT_TIMEOUT = config.getint('Settings', 'client_timeout', fallback=1800)
LOG_SUBMISSION_DETAILS = config.getboolean('Settings', 'log_submission_details', fallback=True)
LOG_PACKET_PARSING = config.getboolean('Settings', 'log_packet_parsing', fallback=False)
LOG_BUFFER_EVENTS = config.getboolean('Settings', 'log_buffer_events', fallback=False)
LOG_PACKET_CONTENT = config.getboolean('Settings', 'log_packet_content', fallback=False)
LOG_PAYLOAD_PROCESSING = config.getboolean('Settings', 'log_payload_processing', fallback=False)
LOG_SUBMISSION_PAYLOAD = config.getboolean('Settings', 'log_submission_payload', fallback=True)
LOG_SEGMENT_FAILURE = config.getboolean('Settings', 'log_segment_failure', fallback=True)
LOG_SOCKET_STATE = config.getboolean('Settings', 'log_socket_state', fallback=True)
LOG_RETRIES = config.getboolean('Settings', 'log_retries', fallback=True)
LOG_UI_TRANSITIONS = config.getboolean('Settings', 'log_ui_transitions', fallback=False)  # CHANGE v2.4: Matches config default
LOG_SEARCH_QUERY = config.getboolean('Settings', 'log_search_query', fallback=True)
LOG_SEARCH_RESULTS = config.getboolean('Settings', 'log_search_results', fallback=True)
LOG_SEARCH_PARSING = config.getboolean('Settings', 'log_search_parsing', fallback=True)
LOG_CSV_PROCESSING = config.getboolean('Settings', 'log_csv_processing', fallback=True)
LOG_CLIENT_STATE = config.getboolean('Settings', 'log_client_state', fallback=True)
LOG_PACKET_BUILD = config.getboolean('Settings', 'log_packet_build', fallback=True)
LOG_PACKET_PARSE = config.getboolean('Settings', 'log_packet_parse', fallback=False)
LOG_SYNC_STATE = config.getboolean('Settings', 'log_sync_state', fallback=True)
LOG_SYNC_MD5 = config.getboolean('Settings', 'log_sync_md5', fallback=False)
LOG_SYNC_FORMS = config.getboolean('Settings', 'log_sync_forms', fallback=False)
LOG_CLIENT_PACKET = config.getboolean('Settings', 'log_client_packet', fallback=True)
LOG_PACKET_INTEGRITY = config.getboolean('Settings', 'log_packet_integrity', fallback=True)
LOG_FORM_DELETION = config.getboolean('Settings', 'log_form_deletion', fallback=True)
LOG_SYNC_START = config.getboolean('Settings', 'log_sync_start', fallback=True)
LOG_SYNC_COMPLETION = config.getboolean('Settings', 'log_sync_completion', fallback=True)
LOG_PACKET_QUEUE = config.getboolean('Settings', 'log_packet_queue', fallback=True)
LOG_CLIENT_QUEUE = config.getboolean('Settings', 'log_client_queue', fallback=True)
LOG_UI_PACKET_HANDLING = config.getboolean('Settings', 'log_ui_packet_handling', fallback=True)
LOG_QUEUE_STATE = config.getboolean('Settings', 'log_queue_state', fallback=True)
LOG_STARTUP_ERRORS = config.getboolean('Settings', 'log_startup_errors', fallback=True)
LOG_CONNECTION_ATTEMPTS = config.getboolean('Settings', 'log_connection_attempts', fallback=True)
LOG_PACKET_DROP = config.getboolean('Settings', 'log_packet_drop', fallback=True)
LOG_THREAD_STATE = config.getboolean('Settings', 'log_thread_state', fallback=True)
LOG_FORM_FIELD_CREATION = config.getboolean('Settings', 'log_form_field_creation', fallback=True)
LOG_FORM_PREVIEW = config.getboolean('Settings', 'log_form_preview', fallback=True)
LOG_FIELD_POSITIONING = config.getboolean('Settings', 'log_field_positioning', fallback=True)
LOG_TABLE_EDIT = config.getboolean('Settings', 'log_table_edit', fallback=True)  # CHANGE v2.4: Added for table edit/delete tracking
LOG_FORM_SAVE = config.getboolean('Settings', 'log_form_save', fallback=True)    # CHANGE v2.4: Added for form save details
QUEUE_MAXSIZE = config.getint('Settings', 'queue_maxsize', fallback=100)

packet_queue = queue.Queue(maxsize=QUEUE_MAXSIZE)

if os.path.exists(LOG_FILE):
    os.remove(LOG_FILE)
logging.basicConfig(filename=LOG_FILE, level=logging.INFO, format='%(asctime)s - %(message)s')
log_event("Deleted old log file")  # CHANGE v2.3: Fixed typo "dishonorificabilitudinitatibusfile" to "file"
log_event(f"Initial packet_queue size: {packet_queue.qsize()}", queue_state=True)

# Chunk 2 v2.4 - Placeholder; previously erased or skipped in earlier versions

# Chunk 3 v2.03.5 - Utility Functions (unchanged)
def get_callsign(stdscr):
    global CALLSIGN
    if not CALLSIGN:
        while True:
            stdscr.clear()
            stdscr.addstr(0, 0, "Enter Server Callsign (e.g., KC8QKU, required): ", curses.color_pair(2))
            stdscr.refresh()
            curses.echo()
            CALLSIGN = stdscr.getstr(1, 0, 10).decode().strip().upper()
            curses.noecho()
            if CALLSIGN:
                break
            stdscr.addstr(2, 0, "Callsign cannot be empty. Try again.", curses.color_pair(1))
            stdscr.refresh()
            time.sleep(1)
        config['Settings']['callsign'] = CALLSIGN
        with open(CONFIG_FILE, 'w') as configfile:
            config.write(configfile)
    log_event("Callsign set to " + CALLSIGN)
    return CALLSIGN

# Chunk 4 v2.03.5 - Form Sync Functions (unchanged)
def hash_forms_dir():
    hasher = hashlib.md5()
    for filename in sorted(glob.glob(os.path.join(FORMS_DIR, '*.txt'))):
        with open(filename, 'rb') as f:
            content = f.read()
            hasher.update(content)
        if LOG_SYNC_FORMS:
            with open(filename, 'r') as f:
                log_event("Hashing " + filename + ": " + f.read()[:50], sync_forms=True)
    return hasher.hexdigest()

def check_forms_changed():
    global last_mtime
    current_mtime = max([os.path.getmtime(f) for f in glob.glob(os.path.join(FORMS_DIR, '*.txt'))] or [0])
    if current_mtime > last_mtime:
        last_mtime = current_mtime
        log_event("Forms directory changed, new mtime: " + str(current_mtime), ui=LOG_FORM_SYNC, sync_state=True)
        return True
    return False

def update_forms_index():
    md5_hash = hash_forms_dir()
    if LOG_FORM_SYNC and check_forms_changed():
        log_event("Forms changed, new MD5: " + md5_hash, sync_state=True)
    return md5_hash

def broadcast_forms_md5(stop_event):
    global forms_md5
    log_event("Starting broadcast_forms_md5 thread", ui=LOG_FORM_SYNC, thread_state=True)
    while not stop_event.is_set():
        start_time = time.time()
        forms_md5 = update_forms_index()
        log_event("Computed forms MD5: " + forms_md5, ui=LOG_FORM_SYNC, sync_state=True)
        packet = "MD5|" + CALLSIGN + "|NONE|" + forms_md5 + "\n"
        if LOG_PACKET_BUILD:
            log_event("Built MD5 packet: " + packet.strip(), packet_build=True, ui=True)
        with clients_lock:
            active_clients = []
            now = time.time()
            for client_socket, addr, callsign, last_data_time in clients[:]:
                if client_socket is None:
                    continue
                if addr in syncing_clients:
                    if LOG_SYNC_STATE:
                        log_event("Skipping MD5 broadcast to syncing client " + str(addr), sync_state=True)
                    active_clients.append((client_socket, addr, callsign, last_data_time))
                    continue
                last_sent = last_broadcast.get(addr, 0)
                if now - last_sent < 10:
                    if LOG_SYNC_STATE:
                        log_event("Skipping MD5 broadcast to " + str(addr) + " (debounced)", sync_state=True)
                    active_clients.append((client_socket, addr, callsign, last_data_time))
                    continue
                try:
                    client_socket.send(packet.encode())
                    last_broadcast[addr] = now
                    active_clients.append((client_socket, addr, callsign, last_data_time))
                    if LOG_SOCKET_STATE:
                        log_event("Broadcast to " + str(addr) + " successful", socket_state=True)
                except Exception as e:
                    log_event("Broadcast to " + str(addr) + " failed: " + str(e), segment_failure=True)
                    if LOG_SOCKET_STATE:
                        log_event("Socket state: Broadcast failed for " + str(addr), socket_state=True)
            clients[:] = active_clients
        log_event(f"Post-broadcast packet_queue size: {packet_queue.qsize()}", queue_state=True)
        elapsed = time.time() - start_time
        time.sleep(max(0, BROADCAST_INTERVAL - elapsed))

# Chunk 5 v2.03.5 - Submission Handling (unchanged)
def handle_client(client_socket, address):
    log_event("Client connected: " + str(address))
    if LOG_SOCKET_STATE:
        log_event("Socket state: New client connection from " + str(address), socket_state=True)
    if LOG_CLIENT_STATE:
        log_event("New client " + str(address) + " added", client_state=True)
    client_callsign = None
    last_data_time = time.time()
    with clients_lock:
        clients.append((client_socket, address, None, last_data_time))
    buffer = ""
    segments = {}
    while True:
        readable, _, _ = select.select([client_socket], [], [], 1.0)
        if readable:
            try:
                data = client_socket.recv(512).decode()
                if not data:
                    raise ConnectionError("Client closed")
                last_data_time = time.time()
                buffer += data
                while '\n' in buffer:
                    packet_end = buffer.find('\n')
                    if packet_end == -1:
                        break
                    packet = buffer[:packet_end].strip()
                    buffer = buffer[packet_end+1:]
                    if LOG_PACKET_PARSE:
                        log_event("Received packet: " + packet[:50], packet_parse=True)
                    if LOG_CLIENT_PACKET:
                        log_event("Raw packet from " + str(address) + ": " + packet, client_packet=True, ui=True)
                    parts_count = len(packet.split('|'))
                    ends_with_newline = data.endswith('\n')
                    if LOG_PACKET_INTEGRITY:
                        log_event("Received packet structure: parts=" + str(parts_count) + ", ends_with_newline=" + str(ends_with_newline), packet_integrity=True)
                    try:
                        packet_queue.put_nowait((client_socket, address, packet, last_data_time))
                        if LOG_PACKET_QUEUE:
                            log_event("Enqueued packet from " + str(address) + ": " + packet[:50], packet_queue=True)
                        if LOG_CLIENT_QUEUE:
                            log_event("Client " + str(address) + " packet queued: " + packet[:50], client_queue=True)
                        if LOG_QUEUE_STATE:
                            log_event("Queue state: size=" + str(packet_queue.qsize()) + ", full=" + str(packet_queue.full()), queue_state=True)
                    except queue.Full:
                        log_event("Queue full, dropped packet from " + str(address) + ": " + packet[:50], packet_queue=True, packet_drop=True)
            except Exception as e:
                log_event("Client error " + str(address) + ": " + str(e), segment_failure=True)
                break
        time.sleep(0.1)
    client_socket.close()
    if LOG_SOCKET_STATE:
        log_event("Socket state: Client " + str(address) + " disconnected", socket_state=True)
    if LOG_CLIENT_STATE:
        log_event("Client " + str(address) + " (callsign: " + str(client_callsign) + ") disconnected", client_state=True)
    with clients_lock:
        for i, (cs, addr, cc, ls) in enumerate(clients):
            if cs == client_socket:
                clients[i] = (None, addr, cc, ls)
                break
    if address in syncing_clients:
        syncing_clients.remove(address)
        if LOG_SYNC_COMPLETION:
            log_event("Sync aborted for " + str(address) + " due to disconnect", sync_completion=True)
    log_event("Client disconnected: " + str(address))

# Chunk 6 v2.1 - Forms Management Utils (unchanged)
def load_form_data(form_id):
    file_path = os.path.join(FORMS_DIR, form_id + ".txt")
    if not os.path.exists(file_path):
        log_event("Form file not found: " + file_path)
        return None
    form_data = {'desc': '', 'fields': {}}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('desc:'):
                form_data['desc'] = line.split(':', 1)[1]
            else:
                fid, label, row, col, length = line.split(',')
                form_data['fields'][fid] = {
                    'label': label,
                    'row': int(row),
                    'col': int(col),
                    'len': int(length)
                }
    return form_data

def create_form(form_id, desc, fields):
    file_path = os.path.join(FORMS_DIR, form_id + ".txt")
    with open(file_path, 'w') as f:
        f.write("desc:" + desc + "\n")
        for fid, field in fields.items():
            f.write(fid + "," + field['label'] + "," + str(field['row']) + "," + str(field['col']) + "," + str(field['len']) + "\n")
    log_event("Created/Updated form: " + form_id)

# Chunk 7 v1.73 - People.csv Initialization (unchanged)
def init_people_csv():
    people_file = os.path.join(DATA_DIR, 'people.csv')
    if not os.path.exists(people_file) or os.path.getsize(people_file) == 0:
        log_event("Seeding " + people_file + " with initial data")
        with open(people_file, 'w') as f:
            f.write("id,name\n")
            f.write("P001,John Doe\n")
            f.write("P002,Jane Smith\n")
            f.write("P003,Alice Johnson\n")
            f.write("P004,Bob Brown\n")
            f.write("P005,Carol White\n")
            f.write("P006,David Green\n")
        log_event("Seeded " + people_file + " with 6 entries")

# Chunk 8 v2.4 - UI Functions
def init_colors():
    log_event("Initializing colors", ui=False)
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)
    return 1, 2, 3, 4

def forms_management_screen(stdscr):
    curses.curs_set(0)
    stdscr.nodelay(True)
    selection = 0
    screen_dirty = True
    if LOG_UI_TRANSITIONS:
        log_event("Entering Forms Management", ui_transitions=True)
    while True:
        forms = sorted([f for f in os.listdir(FORMS_DIR) if re.match(r'[A-Z][A-Z][0-9][0-9]\.txt', f, re.IGNORECASE)])
        if screen_dirty:
            stdscr.clear()
            stdscr.addstr(0, 0, "Forms Management", curses.color_pair(4))
            stdscr.addstr(2, 2, "Current Forms:", curses.color_pair(4))
            for i, form in enumerate(forms[:15], start=3):
                if i - 3 == selection:
                    stdscr.addstr(i, 4, form[:-4], curses.color_pair(2) | curses.A_REVERSE)
                else:
                    stdscr.addstr(i, 4, form[:-4], curses.color_pair(2))
            if forms and selection < len(forms):
                form_id = forms[selection][:-4]
                form_data = load_form_data(form_id)
                if form_data:
                    stdscr.addstr(2, 40, "Form: " + form_id, curses.color_pair(4))
                    stdscr.addstr(3, 40, "Desc: " + form_data['desc'][:36], curses.color_pair(2))
                    stdscr.addstr(4, 40, "ID:Label (Row,Col,Len)", curses.color_pair(4))
                    line = 5
                    for fid, field in sorted(form_data['fields'].items()):
                        if line < 18:
                            text = fid + ":" + field['label'] + " (" + str(field['row']) + "," + str(field['col']) + "," + str(field['len']) + ")"
                            stdscr.addstr(line, 42, text[:36], curses.color_pair(2))
                            line += 1
            stdscr.addstr(19, 2, "C=Create Enter=Edit D=Delete Esc=Back", curses.color_pair(2))
            stdscr.refresh()
            screen_dirty = False
        char = stdscr.getch()
        if char == -1:
            continue
        if char == curses.KEY_UP and selection > 0:
            selection -= 1
            screen_dirty = True
        elif char == curses.KEY_DOWN and selection < len(forms) - 1 and selection < 14:
            selection += 1
            screen_dirty = True
        elif char == ord('c') or char == ord('C'):
            form_edit_screen(stdscr, None)
            screen_dirty = True
        elif char == 10 and forms:
            form_id = forms[selection][:-4]
            form_edit_screen(stdscr, form_id)
            screen_dirty = True
        elif char == ord('d') or char == ord('D') and forms:
            form_id = forms[selection][:-4]
            stdscr.clear()
            stdscr.addstr(0, 0, "Delete Form: " + form_id, curses.color_pair(4))
            stdscr.addstr(2, 2, "Confirm Delete (Y/N)? ", curses.color_pair(2))
            stdscr.refresh()
            stdscr.nodelay(False)
            char = stdscr.getch()
            stdscr.nodelay(True)
            if char == ord('y') or char == ord('Y'):
                delete_form(form_id)
            screen_dirty = True
        elif char == 27:
            if LOG_UI_TRANSITIONS:
                log_event("Exiting Forms Management", ui_transitions=True)
            return

def form_edit_screen(stdscr, form_id):
    # CHANGE v2.4: Rewritten for table-only UI with [ ] cells, L01/R01 as ID/Desc (uppercased), (L/R)(row#) IDs on save
    curses.curs_set(0)
    stdscr.nodelay(True)
    screen_dirty = True
    RED, GREEN, _, LIGHT_BLUE = init_colors()
    max_y, max_x = stdscr.getmaxyx()  # Typically 24x80
    cursor_row, cursor_col = 3, 12  # Start at L01 (row 3, col 12)
    # Table: rows 3-17 (15 rows), cols 12-48 (left), 42-78 (right), ~36 chars per cell
    table = defaultdict(lambda: {'label': ''})  # (row, col) -> {label}, no fid until save
    if form_id:
        form_data = load_form_data(form_id)
        if form_data:
            # Populate L01 with form_id, R01 with desc, shift fields down
            table[(3, 12)] = {'label': form_id}
            table[(3, 42)] = {'label': form_data['desc']}
            for fid, field in sorted(form_data['fields'].items(), key=lambda x: (x[1]['row'], x[1]['col'])):
                # Map old rows to new table (shift +1 if below row 3)
                row = field['row'] if field['row'] <= 3 else field['row'] + 1
                col = 12 if field['col'] == 12 else 42
                table[(row, col)] = {'label': field['label']}
    if LOG_UI_TRANSITIONS:  # CHANGE v2.4: Turned off by default in config to reduce spam
        log_event("Entering Form Edit for " + (form_id or 'new form'), ui_transitions=True)
    while True:
        if screen_dirty:
            stdscr.clear()
            border = "=" * (max_x - 1)
            stdscr.addstr(0, 0, border, curses.color_pair(RED))
            # Table: [label] cells, no fid shown
            for row in range(3, 18):
                left = table[(row, 12)]
                right = table[(row, 42)]
                # Left cell: [label                             ] (12-48, 36 chars)
                stdscr.addstr(row, 12, "[", curses.color_pair(GREEN))
                stdscr.addstr(row, 13, left['label'][:34].ljust(34), curses.color_pair(GREEN if row > 3 else LIGHT_BLUE))
                stdscr.addstr(row, 48, "]", curses.color_pair(GREEN))
                # Right cell: [label                             ] (42-78, 36 chars)
                stdscr.addstr(row, 42, "[", curses.color_pair(GREEN))
                stdscr.addstr(row, 43, right['label'][:34].ljust(34), curses.color_pair(GREEN if row > 3 else LIGHT_BLUE))
                stdscr.addstr(row, 78, "]", curses.color_pair(GREEN))
                if row == cursor_row:
                    stdscr.addstr(row, cursor_col + 1, 'â– ', curses.color_pair(GREEN))
            stdscr.addstr(max_y - 2, 2, "= Arrows/Tab/Shift-Tab=Move D=Delete S=Submit C=Cancel =", curses.color_pair(GREEN))
            stdscr.addstr(max_y - 1, 0, border, curses.color_pair(RED))
            stdscr.refresh()
            screen_dirty = False
            if LOG_FORM_PREVIEW:
                log_event(f"Table preview: {dict(table)}", form_preview=True)
        char = stdscr.getch()
        if char == -1:
            time.sleep(0.05)
            continue
        # Navigation
        if char == curses.KEY_UP and cursor_row > 3:
            cursor_row -= 1
            screen_dirty = True
        elif char == curses.KEY_DOWN and cursor_row < 17:
            cursor_row += 1
            screen_dirty = True
        elif char == curses.KEY_RIGHT and cursor_col == 12:
            cursor_col = 42
            screen_dirty = True
        elif char == curses.KEY_LEFT and cursor_col == 42:
            cursor_col = 12
            screen_dirty = True
        elif char == 9:  # Tab
            if cursor_col == 12 and cursor_row < 17:
                cursor_col = 42
            elif cursor_col == 42 and cursor_row < 17:
                cursor_col = 12
                cursor_row += 1
            elif cursor_row == 17:
                cursor_col = 12
                cursor_row = 3
            screen_dirty = True
        elif char == curses.KEY_BTAB:  # Shift-Tab
            if cursor_col == 42 and cursor_row > 3:
                cursor_col = 12
            elif cursor_col == 12 and cursor_row > 3:
                cursor_col = 42
                cursor_row -= 1
            elif cursor_row == 3:
                cursor_col = 42
                cursor_row = 17
            screen_dirty = True
        # Edit Cell
        elif char == 10:
            stdscr.nodelay(False)
            curses.curs_set(1)
            col_name = 'L' if cursor_col == 12 else 'R'
            stdscr.addstr(cursor_row, cursor_col + 1, " " * 34, curses.color_pair(GREEN))
            curses.echo()
            new_label = stdscr.getstr(cursor_row, cursor_col + 1, 34).decode().strip()
            curses.noecho()
            if new_label:
                table[(cursor_row, cursor_col)] = {'label': new_label}
                if LOG_TABLE_EDIT:  # CHANGE v2.4: Added for edit tracking
                    log_event(f"Edited {col_name} at row {cursor_row}, col {cursor_col} to '{new_label}'", table_edit=True)
            stdscr.nodelay(True)
            curses.curs_set(0)
            screen_dirty = True
        # Delete Cell
        elif char == ord('d') or char == ord('D'):
            if table[(cursor_row, cursor_col)]['label']:
                col_name = 'L' if cursor_col == 12 else 'R'
                old_label = table[(cursor_row, cursor_col)]['label']
                del table[(cursor_row, cursor_col)]
                if LOG_TABLE_EDIT:  # CHANGE v2.4: Added for delete tracking
                    log_event(f"Deleted {col_name} at row {cursor_row}, col {cursor_col} (was '{old_label}')", table_edit=True)
                screen_dirty = True
        # Submit
        elif char == ord('s') or char == ord('S'):
            form_id_val = table[(3, 12)]['label']
            form_desc = table[(3, 42)]['label']
            if form_id_val and form_desc and any(table[(r, c)]['label'] for r, c in table if r > 3):
                fields_dict = {}
                for (row, col) in sorted(table.keys()):
                    label = table[(row, col)]['label']
                    if label:
                        fid = f"{'L' if col == 12 else 'R'}{row - 2:02d}"  # row 3 = 01, row 4 = 02, etc.
                        fields_dict[fid] = {
                            'label': label.upper() if row == 3 else label,
                            'row': row,
                            'col': 12 if col == 12 else 32,  # Map to client cols
                            'len': 256
                        }
                create_form(form_id_val.upper(), form_desc.upper(), fields_dict)
                if LOG_FORM_SAVE:  # CHANGE v2.4: Added for save details
                    log_event(f"Saved form {form_id_val.upper()} with fields: {fields_dict}", form_save=True)
                if LOG_UI_TRANSITIONS:
                    log_event("Form " + form_id_val.upper() + " submitted, exiting edit", ui_transitions=True)
                return
            screen_dirty = True
        # Cancel
        elif char == 27 or char == ord('c') or char == ord('C'):
            if LOG_UI_TRANSITIONS:
                log_event("Form edit cancelled", ui_transitions=True)
            return

def update_ui(stdscr):
    global screen_dirty, show_menu, menu_selection
    if not screen_dirty:
        return
    max_y, max_x = stdscr.getmaxyx()
    stdscr.clear()
    border = "=" * (max_x - 1)
    stdscr.addstr(0, 0, border, curses.color_pair(1))
    stdscr.addstr(1, 2, "Packet Radio Server Status", curses.color_pair(4))
    stdscr.addstr(2, 2, "Recent Clients:", curses.color_pair(4))
    with clients_lock:
        now = time.time()
        clients[:] = [(cs, addr, cc, ls) for cs, addr, cc, ls in clients if now - ls < CLIENT_TIMEOUT]
        for i, (cs, addr, cc, ls) in enumerate(clients[:max_y-4], start=3):
            timestamp = datetime.fromtimestamp(ls).strftime('%H:%M:%S')
            display = (cc or 'Unknown') + " (" + str(addr[0]) + ") - " + timestamp
            stdscr.addstr(i, 4, display[:max_x//2-6], curses.color_pair(2))
    log_x = max_x // 2 + 1
    stdscr.addstr(1, log_x, "Comms Log", curses.color_pair(4))
    stdscr.addstr(2, log_x, "=" * ((max_x - log_x - 1) // 2), curses.color_pair(1))
    for i, (msg, ts) in enumerate(comms_log[-(max_y-5):], start=3):
        if i < max_y-2:
            stdscr.addstr(i, log_x, (msg[:max_x-log_x-1] + " - " + ts)[:max_x-log_x-1], curses.color_pair(2))
    stdscr.addstr(max_y-1, 0, border, curses.color_pair(1))
    stdscr.addstr(max_y-2, 2, "= Press Q to Quit D=Menu =", curses.color_pair(2))
    if show_menu:
        menu_width = 22
        menu_height = 8
        menu_y = (max_y - menu_height) // 2
        menu_x = (max_x - menu_width) // 2
        options = [("Main Screen", True), ("Forms Management", True), ("Quit", True)]
        stdscr.addstr(menu_y, menu_x, "+====================+", curses.color_pair(1))
        for i, (opt, active) in enumerate(options):
            color = 2 if active else 1
            if i == menu_selection:
                stdscr.addstr(menu_y + 1 + i, menu_x, "| " + opt.ljust(18) + " |", curses.color_pair(color) | curses.A_REVERSE)
            else:
                stdscr.addstr(menu_y + 1 + i, menu_x, "| " + opt.ljust(18) + " |", curses.color_pair(color))
        stdscr.addstr(menu_y + 4, menu_x, "| Up/Down=Move       |", curses.color_pair(2))
        stdscr.addstr(menu_y + 5, menu_x, "| Enter=Sel Esc=Back |", curses.color_pair(2))
        stdscr.addstr(menu_y + 6, menu_x, "+====================+", curses.color_pair(1))
    stdscr.refresh()
    screen_dirty = False
# Chunk 9 v2.03.5 - Server Comms (unchanged)
def accept_clients(server, stop_event):
    log_event("Starting accept_clients thread", thread_state=True)
    while not stop_event.is_set():
        try:
            log_event(f"Listening for client connection on {SERVER_HOST}:{SERVER_PORT}", connection_attempts=True)
            client_socket, address = server.accept()
            log_event("Accepted connection from " + str(address))
            if LOG_SOCKET_STATE:
                log_event("Socket state: Accepted connection from " + str(address), socket_state=True)
            client_thread = threading.Thread(target=handle_client, args=(client_socket, address))
            client_thread.daemon = True
            client_thread.start()
            if LOG_THREAD_STATE:
                log_event(f"Started client thread for {address}", thread_state=True)
        except Exception as e:
            log_event("Accept error: " + str(e))
            if LOG_SOCKET_STATE:
                log_event("Socket state: Accept failed - " + str(e), socket_state=True)
        time.sleep(0.1)

# Chunk 10 v2.03.5 - Main Loop (unchanged)
def main(stdscr):
    global CALLSIGN, screen_dirty, show_menu, menu_selection
    os.makedirs(DATA_DIR, exist_ok=True)
    os.makedirs(FORMS_DIR, exist_ok=True)
    CALLSIGN = get_callsign(stdscr)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    stdscr.clear()
    stdscr.nodelay(True)
    stdscr.refresh()
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((SERVER_HOST, SERVER_PORT))
    server.listen(5)
    log_event("Server running on " + SERVER_HOST + ":" + str(SERVER_PORT) + " (v" + VERSION + ")")
    if LOG_SOCKET_STATE:
        log_event("Socket state: Server bound and listening on " + SERVER_HOST + ":" + str(SERVER_PORT), socket_state=True)
    init_people_csv()
    stop_event = threading.Event()
    broadcast_thread = threading.Thread(target=broadcast_forms_md5, args=(stop_event,))
    broadcast_thread.daemon = True
    broadcast_thread.start()
    if LOG_THREAD_STATE:
        log_event("Broadcast thread started", thread_state=True)
    accept_thread = threading.Thread(target=accept_clients, args=(server, stop_event))
    accept_thread.daemon = True
    accept_thread.start()
    if LOG_THREAD_STATE:
        log_event("Accept thread started", thread_state=True)
    if LOG_UI_TRANSITIONS:
        log_event("Entering main UI loop", ui_transitions=True)
    while True:
        update_ui(stdscr)
        char = stdscr.getch()
        if char == ord('q') or char == ord('Q') and not show_menu:
            log_event("Quitting via Q")
            stop_event.set()
            log_event("Server shutdown complete")
            if LOG_UI_TRANSITIONS:
                log_event("Exiting main UI loop", ui_transitions=True)
            break
        elif char == ord('d') or char == ord('D'):
            show_menu = not show_menu
            menu_selection = 0
            screen_dirty = True
            if LOG_UI_TRANSITIONS:
                log_event("Menu toggled: " + str(show_menu), ui_transitions=True)
        elif show_menu:
            if char == curses.KEY_UP and menu_selection > 0:
                menu_selection -= 1
                screen_dirty = True
            elif char == curses.KEY_DOWN and menu_selection < 2:
                menu_selection += 1
                screen_dirty = True
            elif char == 10:
                if menu_selection == 0:
                    show_menu = False
                    if LOG_UI_TRANSITIONS:
                        log_event("Returning to Main Screen", ui_transitions=True)
                elif menu_selection == 1:
                    forms_management_screen(stdscr)
                elif menu_selection == 2:
                    log_event("Quitting via menu")
                    stop_event.set()
                    log_event("Server shutdown complete")
                    if LOG_UI_TRANSITIONS:
                        log_event("Exiting via menu quit", ui_transitions=True)
                    break
                screen_dirty = True
            elif char == 27:
                show_menu = False
                screen_dirty = True
                if LOG_UI_TRANSITIONS:
                    log_event("Escaping menu to Main Screen", ui_transitions=True)
        if not show_menu or menu_selection != 1:
            while not packet_queue.empty():
                try:
                    client_socket, address, packet, last_data_time = packet_queue.get_nowait()
                    if LOG_PACKET_QUEUE:
                        log_event("Dequeued packet from " + str(address) + ": " + packet[:50], packet_queue=True)
                    if LOG_UI_PACKET_HANDLING:
                        log_event("UI handling packet from " + str(address) + ": " + packet[:50], ui_packet_handling=True)
                    if LOG_QUEUE_STATE:
                        log_event("Queue state after dequeue: size=" + str(packet_queue.qsize()) + ", empty=" + str(packet_queue.empty()), queue_state=True)
                    parts = packet.split('|', 3)
                    if len(parts) != 4:
                        log_event("Malformed packet: " + packet[:50], segment_failure=True)
                        continue
                    function, callsign, form_id, payload = parts
                    with clients_lock:
                        for i, (cs, addr, _, ls) in enumerate(clients):
                            if cs == client_socket:
                                clients[i] = (cs, addr, callsign, last_data_time)
                                if LOG_CLIENT_STATE:
                                    log_event("Updated callsign for " + str(addr) + " to " + callsign, client_state=True)
                                break
                    if function == 'INSERT':
                        log_event(f"Received INSERT from {callsign} for {form_id}: {payload[:50]}", submissions=True, ui=True)
                        if ':' in payload[:5]:
                            seq, total = map(int, payload.split('|', 1)[0].split(':'))
                            payload = payload.split('|', 1)[1]
                            key = callsign + ":" + form_id
                            segments.setdefault(key, {})[seq] = payload
                            log_event("Stored segment " + str(seq) + "/" + str(total) + " for " + key, submissions=True)
                            if len(segments[key]) == total:
                                full_payload = ''.join(segments[key][i] for i in sorted(segments[key]))
                                csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                                os.makedirs(DATA_DIR, exist_ok=True)
                                with open(csv_path, 'a') as f:
                                    f.write(str(int(time.time())) + "," + callsign + "," + full_payload + "\n")
                                log_event("Submission saved to " + csv_path, submissions=True)
                                response = "ACK|" + CALLSIGN + "|" + form_id + "|SUCCESS\n"
                                client_socket.send(response.encode())
                                if LOG_PACKET_BUILD:
                                    log_event("Built ACK packet: " + response.strip(), packet_build=True, ui=True)
                                del segments[key]
                        else:
                            csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                            os.makedirs(DATA_DIR, exist_ok=True)
                            with open(csv_path, 'a') as f:
                                f.write(str(int(time.time())) + "," + callsign + "," + payload + "\n")
                            log_event("Submission saved to " + csv_path, submissions=True)
                            response = "ACK|" + CALLSIGN + "|" + form_id + "|SUCCESS\n"
                            client_socket.send(response.encode())
                            if LOG_PACKET_BUILD:
                                log_event("Built ACK packet: " + response.strip(), packet_build=True, ui=True)
                    elif function == 'SEARCH':
                        if LOG_SEARCH_QUERY:
                            log_event("Received search from " + callsign + ": " + packet[:50], search_query=True)
                        search_fields = {}
                        for pair in payload.split('|'):
                            if not pair:
                                if LOG_SEARCH_PARSING:
                                    log_event("Skipping empty pair in payload", search_parsing=True)
                                continue
                            key = pair[:2]
                            value = pair[2:] if len(pair) > 2 else ""
                            search_fields[key] = value
                            if LOG_SEARCH_PARSING:
                                log_event("Parsed field: " + key + "='" + value + "'", search_parsing=True)
                        csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                        matches = []
                        if os.path.exists(csv_path):
                            with open(csv_path, 'r') as f:
                                for line in f:
                                    _, _, row_payload = line.strip().split(',', 2)
                                    if LOG_CSV_PROCESSING:
                                        log_event("Processing CSV row: " + row_payload[:50], csv_processing=True)
                                    fields = {}
                                    for field in row_payload.split('|'):
                                        if field:
                                            fields[field[:2]] = field[2:] if len(field) > 2 else ""
                                            if LOG_CSV_PROCESSING:
                                                log_event("Parsed CSV field: " + field[:2] + "='" + fields[field[:2]] + "'", csv_processing=True)
                                    match = all(fields.get(k, '') == v for k, v in search_fields.items() if v)
                                    if match:
                                        matches.append(row_payload)
                                    if LOG_CSV_PROCESSING:
                                        log_event("Match check for " + str(search_fields) + ": " + ("Yes" if match else "No"), csv_processing=True)
                        response = "SEARCH_RESULT|" + CALLSIGN + "|" + form_id + "|" + '~'.join(matches) + "\n"
                        client_socket.send(response.encode())
                        if LOG_SEARCH_RESULTS:
                            log_event("Sent search results to " + callsign + ": " + response[:50], search_results=True)
                        if LOG_PACKET_BUILD:
                            log_event("Built SEARCH_RESULT packet: " + response.strip(), packet_build=True, ui=True)
                    elif function == 'UPDATE':
                        if LOG_SYNC_STATE:
                            log_event("Received UPDATE from " + callsign + ": " + payload[:50], sync_state=True)
                        syncing_clients.add(address)
                        if LOG_SYNC_START:
                            log_event("Sync started for " + str(address), sync_start=True)
                        client_forms = {}
                        for pair in payload.split('|'):
                            if ':' in pair:
                                fname, fhash = pair.split(':', 1)
                                client_forms[fname] = fhash
                                if LOG_SYNC_FORMS:
                                    log_event("Client form " + fname + " hash: " + fhash, sync_forms=True)
                        server_forms = {}
                        for fname in glob.glob(os.path.join(FORMS_DIR, '*.txt')):
                            fname = os.path.basename(fname)[:-4]
                            with open(os.path.join(FORMS_DIR, fname + ".txt"), 'rb') as f:
                                server_hash = hashlib.md5(f.read()).hexdigest()
                                server_forms[fname] = server_hash
                            if LOG_SYNC_FORMS:
                                log_event("Server form " + fname + " hash: " + server_hash, sync_forms=True)
                        for fname, server_hash in server_forms.items():
                            if fname not in client_forms or client_forms[fname] != server_hash:
                                with open(os.path.join(FORMS_DIR, fname + ".txt"), 'r') as f:
                                    content = f.read().strip()
                                content_replaced = content.replace('\n', '~')
                                response = "FORM_UPDATE|" + CALLSIGN + "|" + fname + "|" + content_replaced + "\n"
                                client_socket.send(response.encode())
                                if LOG_PACKET_BUILD:
                                    log_event("Built FORM_UPDATE packet: " + response.strip(), packet_build=True, ui=True)
                                if LOG_FORM_SYNC:
                                    log_event("Sent form update for " + fname + " to " + callsign, sync_state=True)
                                if LOG_PACKET_INTEGRITY:
                                    newline_count = response.count('\n')
                                    log_event("FORM_UPDATE sent: len=" + str(len(response)) + ", newlines=" + str(newline_count), packet_integrity=True)
                        for fname in client_forms:
                            if fname not in server_forms:
                                response = "FORM_DELETE|" + CALLSIGN + "|" + fname + "|\n"
                                client_socket.send(response.encode())
                                if LOG_PACKET_BUILD:
                                    log_event("Built FORM_DELETE packet: " + response.strip(), packet_build=True, ui=True)
                                if LOG_FORM_DELETION:
                                    log_event("Sent FORM_DELETE for " + fname + " to " + callsign, form_deletion=True)
                                if LOG_PACKET_INTEGRITY:
                                    newline_count = response.count('\n')
                                    log_event("FORM_DELETE sent: len=" + str(len(response)) + ", newlines=" + str(newline_count), packet_integrity=True)
                        syncing_clients.remove(address)
                        if LOG_SYNC_COMPLETION:
                            log_event("Sync completed for " + str(address), sync_completion=True)
                    packet_queue.task_done()
                except queue.Empty:
                    break
        time.sleep(0.05)
    server.close()
    if LOG_SOCKET_STATE:
        log_event("Socket state: Server socket closed", socket_state=True)

# Chunk 11 v2.4 - Design Goals and Statuses
# DESIGN GOALS:
# - v2.03.2: Fix comms_log NameError by moving globals above log_event - Done
# - v2.03.3: Fix QUEUE_MAXSIZE NameError by moving packet_queue after config - Done
# - v2.03.5: Add default callsign SVR001, show packets in UI, enhance logging for troubleshooting - Done
# - v2.1: Add two-column form support with Lxx/Rxx field IDs in form_edit_screen - Done
# - v2.2: Fix Lxx/Rxx pairing (e.g., L01/R01 per row), update preview to match client layout, add form troubleshooting logs - Done
# - v2.3: Support uneven Lxx/Rxx columns, replace form_edit_screen with table-based UI, apply consistent theme - Done
# - v2.4: Replace table UI with [ ] cells, integrate Form ID/Desc as L01/R01 (uppercased), use (L/R)(row#) IDs on save, maintain 15-row cap - Done  # CHANGE v2.4: New goal for updated table UI
# - Future: Separate people.csv sync (MD5_people:)
# - Future: Add options screen for config and logging control
# CHANGES:
# - v2.3: Updated VERSION to 2.3 (Chunk 1),
#         added collections.defaultdict import for table state (Chunk 1),
#         rewrote form_edit_screen for table UI with uneven column support (Chunk 8),
#         applied update_ui theme (red borders, green text, cyan headers) to form_edit_screen (Chunk 8),
#         capped table at 15 rows (rows 3-17) with Form ID/Desc at top and commands at bottom (Chunk 8),
#         fixed typo in log_event ("dishonorificabilitudinitatibusfile" â†’ "file") (Chunk 1),
#         line count increased from 1215 to ~1250 due to table UI logic and comments (Chunk 11)
# - v2.4: Rewrote form_edit_screen for [ ] cells (cols 12-48, 42-78, ~36 chars wide), integrated Form ID/Desc as L01/R01 (uppercased on save), assigned (L/R)(row#) IDs on submit (row 3 = 01), added log_table_edit and log_form_save for troubleshooting (Chunk 8), turned off log_ui_transitions by default to reduce spam (config in Chunk 1), line count increased from ~1250 to ~1275 due to table UI enhancements, logging, and comments (Chunk 11)  # CHANGE v2.4: Detailed updates for v2.4

backup_script()
# Chunk 12 v1.90 - Entry Point (unchanged)
if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except Exception as e:
        with open(LOG_FILE, 'a') as f:
            f.write(str(datetime.now()) + " - Fatal error: " + str(e) + " - traceback: " + traceback.format_exc() + "\n")
        log_event("Startup failed: " + str(e), startup_errors=True)
        sys.exit(1)