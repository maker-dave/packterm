#!/usr/bin/env python3
# server.py
# Version 4.0.0 - 2025-03-22  # Merged v3.0.14 with v4.0.0 CMS, compression, menu access

import os
import sys
import time
import socket
import threading
import hashlib
import logging
import shutil
import curses
import glob
import select
import traceback
import configparser
import re
import queue
import crcmod
import json
import zlib
from datetime import datetime
from collections import defaultdict
from pathlib import Path

# Early Globals
comms_log = []
screen_dirty = True
clients = []  # (callsign, last_data_time)
clients_lock = threading.Lock()
forms_md5 = None
push_md5 = None
last_mtime = 0
last_push_mtime = 0
show_menu = False
menu_selection = 0
syncing_clients = set()
last_broadcast = {}
kiss_socket = None
kiss_socket_ready = threading.Event()
last_md5_time = None
response_parts = {}
segments = {}  # Restored from v3.0.14 for multi-packet assembly

# CMS Config
CMS_DIR = Path(os.path.expanduser('~/terminal/cms'))
CMS_PUSH_DIR = CMS_DIR / "push"
CMS_DIR.mkdir(exist_ok=True)
CMS_PUSH_DIR.mkdir(exist_ok=True)

def log_event(message, ui=False, submission_details=False, submissions=False, submission_payload=False, segment_failure=False, socket_state=False, retries=False, ui_transitions=False, search_query=False, search_results=False, search_parsing=False, csv_processing=False, client_state=False, packet_build=False, packet_parse=False, sync_state=False, sync_md5=False, sync_forms=False, client_packet=False, packet_integrity=False, form_deletion=False, sync_start=False, sync_completion=False, packet_queue=False, client_queue=False, ui_packet_handling=False, queue_state=False, startup_errors=False, backups=False, connection_attempts=False, packet_drop=False, thread_state=False, form_field_creation=False, form_preview=False, field_positioning=False, table_edit=False, form_save=False, ui_render=False, form_sync_error=False, packet_fragments=False, sync_mismatches=False, forms_management=False, kiss_framing=False, packet_timing=False, ax25_state=False, ax25_packet=False, kiss_packet_received=False, ax25_parse_error=False, packet_send_failure=False, socket_send_state=False, socket_send_bytes=False, socket_flush=False, socket_config=False, broadcast_state=False, socket_error=False, thread_error=False, startup_sync=False, thread_sync=False, socket_init=False, ax25_header=False, ax25_parsing_error=False, json_rebuild=False, diff_state=False, broadcast_md5=False, ax25_raw_payload=False, ax25_fcs=False, sync_broadcast=False, sync_response=False, payload_validation=False, packet_length=False, transmission_validation=False, form_content=False, packet_sanitization=False, sync_packet_validation=False, form_field_validation=False, pre_send_validation=False, packet_raw_bytes=False, form_field_sanitization=False, ax25_frame_validation=False, command_validation=False, packet_handling=False, file_io=False, filesystem_sync=False, md5_change=False, multi_packet=False, buffer_management=False, cms_sync=False, cms_operations=False, cms_packet_build=False, cms_ui_state=False):
    logging.info(message)
    if ui:
        comms_log.append((message, datetime.now().strftime('%H:%M:%S')))
        if len(comms_log) > 19:
            comms_log.pop(0)
        global screen_dirty
        screen_dirty = True
    # Logging flags from v3.0.14 and v4.0.0
    if submission_details and LOG_SUBMISSION_DETAILS: logging.info("Submission Detail: " + message)
    if submissions and LOG_SUBMISSIONS: logging.info("Submission: " + message)
    if backups: logging.info("Backup: " + message)
    if cms_sync and LOG_CMS_SYNC: logging.info("CMS Sync: " + message)
    if cms_operations and LOG_CMS_OPERATIONS: logging.info("CMS Operation: " + message)
    if cms_packet_build and LOG_CMS_PACKET_BUILD: logging.info("CMS Packet Build: " + message)
    if multi_packet and LOG_MULTI_PACKET: logging.info("Multi-Packet: " + message)
    if buffer_management and LOG_BUFFER_MANAGEMENT: logging.info("Buffer Management: " + message)

def log_comms(message):
    if not message.startswith(f"0{CALLSIGN}>ALL:M|"):
        log_event(message, ui=True)

def backup_script():
    os.makedirs(BACKUP_DIR, exist_ok=True)
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_path = os.path.join(BACKUP_DIR, "server_" + timestamp + ".py")
    shutil.copy2(__file__, backup_path)
    log_event("Backed up to " + backup_path, ui=False, backups=True)

VERSION = "4.0.0"
PACLEN = 255

# Configuration (Restored from v3.0.14 with v4.0.0 additions)
config = configparser.ConfigParser()
HOME_DIR = os.path.expanduser('~/terminal')
CONFIG_FILE = os.path.join(HOME_DIR, 'server.conf')
if not os.path.exists(CONFIG_FILE):
    config['Settings'] = {
        'callsign': 'SVR001',
        'paclen': str(PACLEN),
        'log_client_details': 'True',
        'log_form_sync': 'True',
        'log_submissions': 'True',
        'broadcast_interval': '60',
        'client_timeout': '1800',
        'cms_sync_enabled': 'True',
        'cms_sync_max_age': '604800',
        'log_submission_details': 'True',
        'log_packet_parsing': 'False',
        'log_buffer_events': 'False',
        'log_packet_content': 'False',
        'log_payload_processing': 'False',
        'log_submission_payload': 'True',
        'log_segment_failure': 'True',
        'log_socket_state': 'False',
        'log_retries': 'True',
        'log_ui_transitions': 'False',
        'log_search_query': 'True',
        'log_search_results': 'True',
        'log_search_parsing': 'True',
        'log_csv_processing': 'True',
        'log_client_state': 'True',
        'log_packet_build': 'True',
        'log_packet_parse': 'True',
        'log_sync_state': 'True',
        'log_sync_md5': 'True',
        'log_sync_forms': 'True',
        'log_client_packet': 'True',
        'log_packet_integrity': 'True',
        'log_form_deletion': 'True',
        'log_sync_start': 'True',
        'log_sync_completion': 'True',
        'log_packet_queue': 'True',
        'log_client_queue': 'True',
        'log_ui_packet_handling': 'True',
        'log_queue_state': 'True',
        'log_startup_errors': 'True',
        'home_dir': HOME_DIR,
        'server_host': '0.0.0.0',
        'server_port': '12345',
        'fake_direwolf_host': '127.0.0.1',
        'fake_direwolf_port': '8051',
        'queue_maxsize': '100',
        'log_cms_sync': 'True',
        'log_cms_operations': 'True',
        'log_cms_packet_build': 'True',
        'log_cms_ui_state': 'False',
        'log_multi_packet': 'True',
        'log_buffer_management': 'True'
    }
    os.makedirs(HOME_DIR, exist_ok=True)
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)
config.read(CONFIG_FILE)
HOME_DIR = config.get('Settings', 'home_dir', fallback=os.path.expanduser('~/terminal'))
FORMS_DIR = os.path.join(HOME_DIR, 'forms')
DATA_DIR = os.path.join(HOME_DIR, 'server_data')
LOG_FILE = os.path.join(DATA_DIR, 'server.log')
BACKUP_DIR = os.path.join(HOME_DIR, 'backups')
CALLSIGN = config.get('Settings', 'callsign', fallback='SVR001')
PACLEN = config.getint('Settings', 'paclen', fallback=PACLEN)
FAKE_DIREWOLF_HOST = config.get('Settings', 'fake_direwolf_host', fallback='127.0.0.1')
FAKE_DIREWOLF_PORT = config.getint('Settings', 'fake_direwolf_port', fallback=8051)
CMS_SYNC_ENABLED = config.getboolean('Settings', 'cms_sync_enabled', fallback=True)
CMS_SYNC_MAX_AGE = config.getint('Settings', 'cms_sync_max_age', fallback=604800)
LOG_SUBMISSION_DETAILS = config.getboolean('Settings', 'log_submission_details', fallback=True)
LOG_SUBMISSIONS = config.getboolean('Settings', 'log_submissions', fallback=True)
LOG_CMS_SYNC = config.getboolean('Settings', 'log_cms_sync', fallback=True)
LOG_CMS_OPERATIONS = config.getboolean('Settings', 'log_cms_operations', fallback=True)
LOG_CMS_PACKET_BUILD = config.getboolean('Settings', 'log_cms_packet_build', fallback=True)
LOG_CMS_UI_STATE = config.getboolean('Settings', 'log_cms_ui_state', fallback=False)
LOG_MULTI_PACKET = config.getboolean('Settings', 'log_multi_packet', fallback=True)
LOG_BUFFER_MANAGEMENT = config.getboolean('Settings', 'log_buffer_management', fallback=True)
BROADCAST_INTERVAL = config.getint('Settings', 'broadcast_interval', fallback=60)
CLIENT_TIMEOUT = config.getint('Settings', 'client_timeout', fallback=1800)
QUEUE_MAXSIZE = config.getint('Settings', 'queue_maxsize', fallback=100)

packet_queue = queue.Queue(maxsize=QUEUE_MAXSIZE)
if os.path.exists(LOG_FILE):
    os.remove(LOG_FILE)
logging.basicConfig(filename=LOG_FILE, level=logging.INFO, format='%(asctime)s - %(message)s')
log_event("Deleted old log file", ui=False)

# Utility Functions
def get_callsign(stdscr):
    global CALLSIGN
    if not CALLSIGN:
        while True:
            stdscr.clear()
            stdscr.addstr(0, 0, "Enter Server Callsign (e.g., KC8QKU, required): ", curses.color_pair(2))
            stdscr.refresh()
            curses.echo()
            CALLSIGN = stdscr.getstr(1, 0, 10).decode().strip().upper()
            curses.noecho()
            if CALLSIGN:
                break
            stdscr.addstr(2, 0, "Callsign cannot be empty. Try again.", curses.color_pair(1))
            stdscr.refresh()
            time.sleep(1)
        config['Settings']['callsign'] = CALLSIGN
        with open(CONFIG_FILE, 'w') as configfile:
            config.write(configfile)
    log_event("Callsign set to " + CALLSIGN, ui=False)
    return CALLSIGN

def build_ax25_packet(source, dest, payload, compress=False):
    crc16 = crcmod.predefined.mkCrcFun('crc-ccitt-false')
    def encode_callsign(callsign, ssid=0, last=False):
        callsign = callsign.ljust(6)[:6].upper()
        ssid_byte = (0x60 | (ssid << 1) | (1 if last else 0))
        return bytes([ord(c) << 1 for c in callsign]) + bytes([ssid_byte])
    payload_bytes = payload.encode()
    if compress:
        payload_bytes = zlib.compress(payload_bytes)
        payload = f"C|{payload_bytes.hex()}"
    max_payload = PACLEN - 32
    if len(payload) > max_payload:
        log_event(f"Payload exceeds max ({max_payload}): {len(payload)} bytes, splitting", packet_length=True, multi_packet=True)
        parts = [payload[i:i + max_payload] for i in range(0, len(payload), max_payload)]
        packets = []
        for i, part in enumerate(parts):
            tagged_payload = f"{i+1}:{len(parts)}|{part}"
            address = encode_callsign(dest) + encode_callsign(source, last=True)
            frame = address + b'\x03\xF0' + tagged_payload.encode()
            fcs = crc16(frame).to_bytes(2, 'little')
            packet = b'\x7E' + frame + fcs + b'\x7E'
            packets.append(packet)
        return packets
    address = encode_callsign(dest) + encode_callsign(source, last=True)
    frame = address + b'\x03\xF0' + payload.encode()
    fcs = crc16(frame).to_bytes(2, 'little')
    packet = b'\x7E' + frame + fcs + b'\x7E'
    return [packet]

def build_kiss_packet(ax25_packet):
    kiss_data = ax25_packet.replace(b'\xC0', b'\xDB\xDC').replace(b'\xDB', b'\xDB\xDD')
    frame = b'\xC0\x00' + kiss_data + b'\xC0'
    return frame

# CMS Functions (v4.0.0)
def check_push_changed():
    global last_push_mtime
    now = time.time()
    files = [f for f in CMS_PUSH_DIR.rglob('*.txt') if now - os.path.getmtime(f) <= CMS_SYNC_MAX_AGE]
    current_mtime = max([os.path.getmtime(f) for f in files] or [0])
    if current_mtime > last_push_mtime:
        last_push_mtime = current_mtime
        log_event(f"Push directory changed, new mtime: {current_mtime}", ui=False, sync_state=True, cms_sync=True)
        return True
    return False

def update_cms_push_index():
    global push_md5
    push_index_path = CMS_DIR / 'push_index.json'
    if CMS_SYNC_ENABLED and check_push_changed():
        push_dict = {"push": {}}
        now = time.time()
        txt_files = [f for f in CMS_PUSH_DIR.rglob('*.txt') if now - os.path.getmtime(f) <= CMS_SYNC_MAX_AGE]
        for filename in txt_files:
            rel_path = filename.relative_to(CMS_PUSH_DIR).as_posix()
            with open(filename, 'rb') as f:
                content = f.read()
                file_md5 = hashlib.md5(content).hexdigest()
                push_dict["push"][rel_path] = {"md5": file_md5, "mtime": os.path.getmtime(filename)}
        with open(push_index_path, 'w') as f:
            json.dump(push_dict, f, indent=2)
            os.fsync(f.fileno())
        with open(push_index_path, 'r') as f:
            push_index_content = f.read()
        push_md5 = hashlib.md5(push_index_content.encode()).hexdigest()
    elif push_md5 is None and CMS_SYNC_ENABLED:
        try:
            with open(push_index_path, 'r') as f:
                push_index_content = f.read()
            push_md5 = hashlib.md5(push_index_content.encode()).hexdigest()
        except FileNotFoundError:
            push_md5 = hashlib.md5('{"push": {}}'.encode()).hexdigest()
    return push_md5

def list_cms_content(category):
    cat_path = CMS_DIR / category
    if not cat_path.is_dir():
        return f"L|{CALLSIGN}|{category}|Error: Invalid category"
    files = [f for f in cat_path.iterdir() if f.is_file() and f.suffix == ".txt"]
    response = f"L|{CALLSIGN}|{category}|{len(files)} items - " + ", ".join(f.name[:-4] for f in files) if files else "No items"
    return response

def get_cms_content(category, item_id):
    file_path = CMS_DIR / category / f"{item_id}.txt"
    if not file_path.is_file():
        return f"G001/001|{CALLSIGN}|{category}|{item_id}|Error: Item not found"
    with open(file_path, "r") as f:
        content = f.read().encode()
    packets = [f"G{i+1:03d}/{len(packets):03d}|{CALLSIGN}|{category}|{item_id}|{p.hex()}"
               for i, p in enumerate(content[i:i+PACLEN-32] for i in range(0, len(content), PACLEN-32))]
    return packets

def post_cms_content(category, item_id, content, max_age=None):
    cat_path = CMS_DIR / category
    cat_path.mkdir(parents=True, exist_ok=True)
    file_path = cat_path / f"{item_id}.txt"
    with open(file_path, "w") as f:
        f.write(content)
    if max_age:
        os.utime(file_path, times=(time.time(), time.time() + int(max_age)))
    return f"A|{CALLSIGN}|{category}|{item_id}|SUCCESS"

# Form Sync Functions (v3.0.14)
def check_forms_changed():
    global last_mtime
    current_mtime = max([os.path.getmtime(f) for f in glob.glob(os.path.join(FORMS_DIR, '*.txt'))] or [0])
    if current_mtime > last_mtime:
        last_mtime = current_mtime
        return True
    return False

def update_forms_index():
    global forms_md5
    forms_index_path = os.path.join(FORMS_DIR, 'forms_index.json')
    if check_forms_changed():
        forms_dict = {"forms": {}}
        txt_files = glob.glob(os.path.join(FORMS_DIR, '*.txt'))
        for filename in txt_files:
            form_id = os.path.basename(filename)[:-4]
            if form_id == 'forms_index.json':
                continue
            with open(filename, 'rb') as f:
                content = f.read()
                form_md5 = hashlib.md5(content).hexdigest()
                forms_dict["forms"][form_id] = {"md5": form_md5}
        with open(forms_index_path, 'w') as f:
            json.dump(forms_dict, f, indent=2)
            os.fsync(f.fileno())
        with open(forms_index_path, 'r') as f:
            forms_index_content = f.read()
        forms_md5 = hashlib.md5(forms_index_content.encode()).hexdigest()
    elif forms_md5 is None:
        try:
            with open(forms_index_path, 'r') as f:
                forms_index_content = f.read()
            forms_md5 = hashlib.md5(forms_index_content.encode()).hexdigest()
        except FileNotFoundError:
            forms_md5 = hashlib.md5('{"forms": {}}'.encode()).hexdigest()
    return forms_md5

def broadcast_forms_md5(stop_event):
    global forms_md5, push_md5, last_md5_time
    kiss_socket_ready.wait()
    if forms_md5 is None:
        forms_md5 = update_forms_index()
    if push_md5 is None and CMS_SYNC_ENABLED:
        push_md5 = update_cms_push_index()
    while not stop_event.is_set():
        start_time = time.time()
        try:
            if check_forms_changed():
                forms_md5 = update_forms_index()
            if CMS_SYNC_ENABLED and check_push_changed():
                push_md5 = update_cms_push_index()
            # Forms MD5
            payload = f"M|{CALLSIGN}|NONE|{forms_md5}"
            ax25_packets = build_ax25_packet(CALLSIGN, "ALL", payload)
            for ax25_packet in ax25_packets:
                kiss_frame = build_kiss_packet(ax25_packet)
                kiss_socket.send(kiss_frame)
                log_comms(f"0{CALLSIGN}>ALL:{payload}")
            # CMS Push MD5
            if CMS_SYNC_ENABLED:
                payload = f"M|{CALLSIGN}|PUSH|{push_md5}"
                ax25_packets = build_ax25_packet(CALLSIGN, "ALL", payload)
                for ax25_packet in ax25_packets:
                    kiss_frame = build_kiss_packet(ax25_packet)
                    kiss_socket.send(kiss_frame)
                    log_comms(f"0{CALLSIGN}>ALL:{payload}")
            last_md5_time = datetime.now().strftime('%H:%M')
        except Exception as e:
            log_event(f"Broadcast failed: {e}", ui=False, packet_send_failure=True)
        elapsed = time.time() - start_time
        time.sleep(max(0, BROADCAST_INTERVAL - elapsed))

def handle_ax25(stop_event):
    global kiss_socket
    crc16 = crcmod.predefined.mkCrcFun('crc-ccitt-false')
    kiss_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    kiss_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    try:
        kiss_socket.connect((FAKE_DIREWOLF_HOST, FAKE_DIREWOLF_PORT))
        kiss_socket_ready.set()
    except Exception as e:
        log_event(f"Failed to connect to Direwolf: {e}", ui=False, startup_errors=True)
        stop_event.set()
        return
    buffer = b""
    while not stop_event.is_set():
        readable, _, _ = select.select([kiss_socket], [], [], 1.0)
        if readable:
            try:
                data = kiss_socket.recv(512)
                if not data:
                    raise ConnectionError("Direwolf disconnected")
                buffer += data
                while b'\xC0' in buffer[1:]:
                    start = buffer.find(b'\xC0')
                    end = buffer.find(b'\xC0', start + 1)
                    if end == -1:
                        break
                    frame = buffer[start:end + 1]
                    buffer = buffer[end + 1:]
                    ax25_packet = frame[2:-1]
                    if len(ax25_packet) < 18 or ax25_packet[0] != 0x7E or ax25_packet[-1] != 0x7E:
                        continue
                    frame_content = ax25_packet[1:-3]
                    received_fcs = ax25_packet[-3:-1]
                    calculated_fcs = crc16(frame_content).to_bytes(2, 'little')
                    if received_fcs != calculated_fcs:
                        continue
                    address = ax25_packet[1:15]
                    dest = ''.join(chr(b >> 1) for b in address[:6]).strip()
                    src = ''.join(chr(b >> 1) for b in address[7:13]).strip()
                    payload_start = 17
                    payload_end = -3
                    raw_payload = ax25_packet[payload_start:payload_end]
                    payload = raw_payload.decode('ascii', errors='replace')
                    if payload.startswith("C|"):
                        payload = zlib.decompress(bytes.fromhex(payload[2:])).decode('ascii', errors='replace')
                    log_comms(f"0{src}>{dest}:{payload}")
                    parts = payload.split('|', 3)
                    if len(parts) != 4:
                        continue
                    function, callsign, form_id, payload_content = parts
                    if ':' in payload_content[:5] and function in ['X', 'S', 'I', 'L', 'G', 'P']:
                        seq_total, content = payload_content.split('|', 1)
                        seq, total = map(int, seq_total.split(':'))
                        key = f"{callsign}:{form_id}"
                        response_parts.setdefault(key, {})[seq] = content
                        if len(response_parts[key]) == total:
                            full_payload = ''.join(response_parts[key][i] for i in range(1, total + 1))
                            packet_queue.put_nowait((callsign, f"0{src}>{dest}:{function}|{callsign}|{form_id}|{full_payload}", time.time()))
                            del response_parts[key]
                        continue
                    last_data_time = time.time()
                    with clients_lock:
                        if callsign not in [c[0] for c in clients]:
                            clients.append((callsign, last_data_time))
                        else:
                            for i, (cs, _) in enumerate(clients):
                                if cs == callsign:
                                    clients[i] = (cs, last_data_time)
                                    break
                    packet_queue.put_nowait((callsign, f"0{src}>{dest}:{payload}", last_data_time))
            except Exception as e:
                log_event(f"AX.25 error: {e}", ui=False)
                break
        time.sleep(0.1)
    kiss_socket.close()

# Forms Management Utils (v3.0.14)
def load_form_data(form_id):
    file_path = os.path.join(FORMS_DIR, form_id + ".txt")
    if not os.path.exists(file_path):
        return None
    form_data = {'desc': '', 'fields': {}}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('desc:'):
                form_data['desc'] = line.split(':', 1)[1]
            else:
                fid, label, row, col, length = line.split(',')
                form_data['fields'][fid] = {
                    'label': label,
                    'row': int(row),
                    'col': int(col),
                    'len': int(length)
                }
    return form_data

def create_form(form_id, desc, fields):
    file_path = os.path.join(FORMS_DIR, form_id + ".txt")
    with open(file_path, 'w') as f:
        f.write("desc:" + desc + "\n")
        for fid, field in fields.items():
            f.write(fid + "," + field['label'] + "," + str(field['row']) + "," + str(field['col']) + "," + str(field['len']) + "\n")
        os.fsync(f.fileno())

def init_people_csv():
    people_file = os.path.join(DATA_DIR, 'people.csv')
    if not os.path.exists(people_file) or os.path.getsize(people_file) == 0:
        with open(people_file, 'w') as f:
            f.write("id,name\n")
            f.write("P001,John Doe\n")
            f.write("P002,Jane Smith\n")
            f.write("P003,Alice Johnson\n")
            f.write("P004,Bob Brown\n")
            f.write("P005,Carol White\n")
            f.write("P006,David Green\n")

def init_colors():
    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)
    return 1, 2, 3, 4

def forms_management_screen(stdscr):
    curses.curs_set(0)
    stdscr.nodelay(True)
    selection = 0
    screen_dirty = True
    while True:
        all_files = glob.glob(os.path.join(FORMS_DIR, '*.txt'))
        forms = sorted([os.path.basename(f) for f in all_files if not f.endswith('forms_index.json.txt')])
        if screen_dirty:
            stdscr.clear()
            RED, GREEN, _, LIGHT_BLUE = init_colors()
            max_y, max_x = stdscr.getmaxyx()
            border = "=" * (max_x - 2)
            stdscr.addstr(0, 0, border, curses.color_pair(RED))
            stdscr.addstr(1, 2, "Forms Management", curses.color_pair(LIGHT_BLUE))
            stdscr.addstr(2, 2, "Current Forms:", curses.color_pair(LIGHT_BLUE))
            for i, form in enumerate(forms[:15], start=3):
                form_name = form[:-4]
                if i - 3 == selection:
                    stdscr.addstr(i, 4, form_name, curses.color_pair(GREEN) | curses.A_REVERSE)
                else:
                    stdscr.addstr(i, 4, form_name, curses.color_pair(GREEN))
            if forms and selection < len(forms):
                form_id = forms[selection][:-4]
                form_data = load_form_data(form_id)
                if form_data:
                    stdscr.addstr(2, 40, "Form: " + form_id, curses.color_pair(LIGHT_BLUE))
                    stdscr.addstr(3, 40, "Desc: " + form_data['desc'][:36], curses.color_pair(GREEN))
                    stdscr.addstr(4, 40, "ID:Label (Row,Col,Len)", curses.color_pair(LIGHT_BLUE))
                    line = 5
                    for fid, field in sorted(form_data['fields'].items()):
                        if line < 18:
                            text = fid + ":" + field['label'] + " (" + str(field['row']) + "," + str(field['col']) + "," + str(field['len']) + ")"
                            stdscr.addstr(line, 42, text[:36], curses.color_pair(GREEN))
                            line += 1
            options_text = "(C)reate (E)dit (D)elete E(s)c"
            start_x = (max_x - len(options_text)) // 2
            stdscr.addstr(max_y - 2, start_x, options_text, curses.color_pair(GREEN))
            stdscr.addstr(max_y - 1, 0, border, curses.color_pair(RED))
            stdscr.refresh()
            screen_dirty = False
        char = stdscr.getch()
        if char == -1:
            continue
        if char == curses.KEY_UP and selection > 0:
            selection -= 1
            screen_dirty = True
        elif char == curses.KEY_DOWN and selection < len(forms) - 1 and selection < 14:
            selection += 1
            screen_dirty = True
        elif char == ord('c') or char == ord('C'):
            form_edit_screen(stdscr, None)
            screen_dirty = True
        elif char == 10 and forms:
            form_id = forms[selection][:-4]
            form_edit_screen(stdscr, form_id)
            screen_dirty = True
        elif char == ord('d') or char == ord('D') and forms:
            form_id = forms[selection][:-4]
            stdscr.clear()
            stdscr.addstr(0, 0, "Delete Form: " + form_id, curses.color_pair(LIGHT_BLUE))
            stdscr.addstr(2, 2, "Confirm Delete (Y/N)? ", curses.color_pair(GREEN))
            stdscr.refresh()
            stdscr.nodelay(False)
            char = stdscr.getch()
            stdscr.nodelay(True)
            if char == ord('y') or char == ord('Y'):
                os.remove(os.path.join(FORMS_DIR, form_id + ".txt"))
            screen_dirty = True
        elif char == 27:
            return

def form_edit_screen(stdscr, form_id):
    curses.curs_set(0)
    stdscr.nodelay(True)
    screen_dirty = True
    RED, GREEN, _, LIGHT_BLUE = init_colors()
    max_y, max_x = stdscr.getmaxyx()
    cursor_row, cursor_col = 3, 13
    table = defaultdict(lambda: {'label': ''})
    if form_id:
        form_data = load_form_data(form_id)
        if form_data:
            table[(3, 13)] = {'label': form_id}
            table[(3, 49)] = {'label': form_data['desc']}
            for fid, field in sorted(form_data['fields'].items(), key=lambda x: (x[1]['row'], x[1]['col'])):
                row = field['row'] + 1 if field['row'] > 3 else field['row']
                col = 13 if field['col'] == 12 else 49
                table[(row, col)] = {'label': field['label']}
    else:
        table[(3, 13)] = {'label': '(Form ID)'}
        table[(3, 49)] = {'label': '(Form Description)'}
    while True:
        if screen_dirty:
            stdscr.clear()
            border = "=" * (max_x - 2)
            stdscr.addstr(0, 0, border, curses.color_pair(RED))
            for row in range(3, 18):
                left = table[(row, 13)]['label']
                right = table[(row, 49)]['label']
                stdscr.addstr(row, 13, "[", curses.color_pair(GREEN))
                stdscr.addstr(row, 14, left[:34].ljust(34), curses.color_pair(GREEN if row > 3 else LIGHT_BLUE))
                stdscr.addstr(row, 48, "]", curses.color_pair(GREEN))
                stdscr.addstr(row, 49, "[", curses.color_pair(GREEN))
                stdscr.addstr(row, 50, right[:29].ljust(29), curses.color_pair(GREEN if row > 3 else LIGHT_BLUE))
                stdscr.addstr(row, 79, "]", curses.color_pair(GREEN))
                if row == cursor_row:
                    stdscr.addstr(row, cursor_col, 'â– ', curses.color_pair(GREEN))
            stdscr.addstr(max_y - 2, 2, "= Arrows/Tab/Shift-Tab=Move D=Delete S=Submit C=Cancel =", curses.color_pair(GREEN))
            stdscr.addstr(max_y - 1, 0, border, curses.color_pair(RED))
            stdscr.refresh()
            screen_dirty = False
        char = stdscr.getch()
        if char == -1:
            time.sleep(0.05)
            continue
        if char == curses.KEY_UP and cursor_row > 3:
            cursor_row -= 1
            screen_dirty = True
        elif char == curses.KEY_DOWN and cursor_row < 17:
            cursor_row += 1
            screen_dirty = True
        elif char == curses.KEY_RIGHT and cursor_col == 13:
            cursor_col = 49
            screen_dirty = True
        elif char == curses.KEY_LEFT and cursor_col == 49:
            cursor_col = 13
            screen_dirty = True
        elif char == 10:
            stdscr.nodelay(False)
            curses.curs_set(1)
            col_name = 'L' if cursor_col == 13 else 'R'
            current_label = table[(cursor_row, cursor_col)]['label']
            max_len = 34 if col_name == 'L' else 29
            stdscr.addstr(cursor_row, cursor_col + 1, " " * max_len, curses.color_pair(GREEN))
            curses.echo()
            new_label = stdscr.getstr(cursor_row, cursor_col + 1, max_len).decode().strip()
            curses.noecho()
            if new_label and new_label not in ['(Form ID)', '(Form Description)']:
                table[(cursor_row, cursor_col)] = {'label': new_label}
            stdscr.nodelay(True)
            curses.curs_set(0)
            screen_dirty = True
        elif char == ord('d') or char == ord('D'):
            if table[(cursor_row, cursor_col)]['label'] not in ['(Form ID)', '(Form Description)']:
                del table[(cursor_row, cursor_col)]
                screen_dirty = True
        elif char == ord('s') or char == ord('S'):
            form_id_val = table[(3, 13)]['label']
            form_desc = table[(3, 49)]['label']
            if (form_id_val not in ['', '(Form ID)'] and
                form_desc not in ['', '(Form Description)'] and
                any(table[(r, c)]['label'] not in ['', '(Form ID)', '(Form Description)'] for r, c in table if r > 3)):
                fields_dict = {}
                for (row, col) in sorted(table.keys()):
                    label = table[(row, col)]['label']
                    if label and label not in ['(Form ID)', '(Form Description)']:
                        fid = f"{'L' if col == 13 else 'R'}{row - 2:02d}"
                        fields_dict[fid] = {
                            'label': label.upper() if row == 3 else label,
                            'row': row,
                            'col': 12 if col == 13 else 32,
                            'len': 256
                        }
                create_form(form_id_val.upper(), form_desc.upper(), fields_dict)
                return
        elif char == 27:
            return

def cms_management_screen(stdscr):
    curses.curs_set(0)
    stdscr.nodelay(True)
    selection = 0
    screen_dirty = True
    while True:
        categories = [str(Path(d).relative_to(CMS_DIR)) for d, _, _ in os.walk(CMS_DIR) if d != str(CMS_DIR)]
        if screen_dirty:
            stdscr.clear()
            RED, GREEN, _, LIGHT_BLUE = init_colors()
            max_y, max_x = stdscr.getmaxyx()
            border = "=" * (max_x - 2)
            stdscr.addstr(0, 0, border, curses.color_pair(RED))
            stdscr.addstr(1, 2, "CMS Management", curses.color_pair(LIGHT_BLUE))
            stdscr.addstr(2, 2, "Categories:", curses.color_pair(LIGHT_BLUE))
            for i, cat in enumerate(categories[:15], start=3):
                if i - 3 == selection:
                    stdscr.addstr(i, 4, cat, curses.color_pair(GREEN) | curses.A_REVERSE)
                else:
                    stdscr.addstr(i, 4, cat, curses.color_pair(GREEN))
            if categories and selection < len(categories):
                cat = categories[selection]
                files = [f.name[:-4] for f in (CMS_DIR / cat).glob('*.txt')]
                stdscr.addstr(2, 40, f"Items in {cat}:", curses.color_pair(LIGHT_BLUE))
                for i, item in enumerate(files[:10], start=3):
                    stdscr.addstr(i, 42, item, curses.color_pair(GREEN))
            stdscr.addstr(max_y - 2, 2, "= Up/Down=Select Esc=Back =", curses.color_pair(GREEN))
            stdscr.addstr(max_y - 1, 0, border, curses.color_pair(RED))
            stdscr.refresh()
            screen_dirty = False
        char = stdscr.getch()
        if char == -1:
            continue
        if char == curses.KEY_UP and selection > 0:
            selection -= 1
            screen_dirty = True
        elif char == curses.KEY_DOWN and selection < len(categories) - 1 and selection < 14:
            selection += 1
            screen_dirty = True
        elif char == 27:
            return

def update_ui(stdscr):
    global screen_dirty, show_menu, menu_selection
    if not screen_dirty:
        return
    max_y, max_x = stdscr.getmaxyx()
    stdscr.clear()
    border = "=" * (max_x - 2)
    stdscr.addstr(0, 0, border, curses.color_pair(1))
    stdscr.addstr(1, 2, "Packet Radio Server", curses.color_pair(4))
    stdscr.addstr(1, 40, "Direwolf [Connected]", curses.color_pair(4))
    stdscr.addstr(2, 2, f"Callsign:{CALLSIGN}", curses.color_pair(4))
    stdscr.addstr(3, 2, "Recent Clients:", curses.color_pair(4))
    stdscr.addstr(2, 40, "Comms Log", curses.color_pair(4))
    stdscr.addstr(3, 40, "=" * 19, curses.color_pair(1))
    with clients_lock:
        now = time.time()
        clients[:] = [(cs, ls) for cs, ls in clients if now - ls < CLIENT_TIMEOUT]
        for i, (callsign, last_data_time) in enumerate(clients[:max_y-6], start=4):
            timestamp = datetime.fromtimestamp(last_data_time).strftime('%H:%M:%S')
            display = f"{callsign} - {timestamp}"[:35]
            stdscr.addstr(i, 4, display, curses.color_pair(2))
    for i, (msg, ts) in enumerate(comms_log[-(max_y-7):], start=4):
        if i < max_y-3:
            stdscr.addstr(i, 40, (msg[:38] + " - " + ts)[:38], curses.color_pair(2))
    stdscr.addstr(max_y-2, 40, f"Last MD5 broadcast: {last_md5_time or 'N/A'}", curses.color_pair(2))
    stdscr.addstr(max_y-1, 40, f"Forms MD5: {forms_md5 or 'N/A'}", curses.color_pair(2))
    stdscr.addstr(max_y-3, 40, f"Push MD5: {push_md5 or 'N/A'}", curses.color_pair(2))
    stdscr.addstr(max_y-2, 2, "-= Commands: D=Menu =-", curses.color_pair(2))
    stdscr.addstr(max_y-1, 0, border, curses.color_pair(1))
    if show_menu:
        menu_width = 22
        menu_height = 8
        menu_y = (max_y - menu_height) // 2
        menu_x = (max_x - menu_width) // 2
        options = [("Main Screen", True), ("Forms Management", True), ("CMS Management", True), ("Quit", True)]
        stdscr.addstr(menu_y, menu_x, "+====================+", curses.color_pair(1))
        for i, (opt, active) in enumerate(options):
            color = 2 if active else 1
            if i == menu_selection:
                stdscr.addstr(menu_y + 1 + i, menu_x, "| " + opt.ljust(18) + " |", curses.color_pair(color) | curses.A_REVERSE)
            else:
                stdscr.addstr(menu_y + 1 + i, menu_x, "| " + opt.ljust(18) + " |", curses.color_pair(color))
        stdscr.addstr(menu_y + 5, menu_x, "| Up/Down=Move       |", curses.color_pair(2))
        stdscr.addstr(menu_y + 6, menu_x, "| Enter=Sel Esc=Back |", curses.color_pair(2))
        stdscr.addstr(menu_y + 7, menu_x, "+====================+", curses.color_pair(1))
    stdscr.refresh()
    screen_dirty = False

def main(stdscr):
    global CALLSIGN, screen_dirty, show_menu, menu_selection, kiss_socket
    os.makedirs(DATA_DIR, exist_ok=True)
    os.makedirs(FORMS_DIR, exist_ok=True)
    os.makedirs(CMS_DIR, exist_ok=True)
    CALLSIGN = get_callsign(stdscr)
    RED, GREEN, YELLOW, LIGHT_BLUE = init_colors()
    stdscr.clear()
    stdscr.nodelay(True)
    stdscr.refresh()
    init_people_csv()
    stop_event = threading.Event()
    broadcast_thread = threading.Thread(target=broadcast_forms_md5, args=(stop_event,))
    broadcast_thread.daemon = True
    broadcast_thread.start()
    ax25_thread = threading.Thread(target=handle_ax25, args=(stop_event,))
    ax25_thread.daemon = True
    ax25_thread.start()
    kiss_socket_ready.wait()
    while True:
        update_ui(stdscr)
        char = stdscr.getch()
        if char == ord('q') or char == ord('Q') and not show_menu:
            stop_event.set()
            kiss_socket.close()
            break
        elif char == ord('d') or char == ord('D'):
            show_menu = not show_menu
            menu_selection = 0
            screen_dirty = True
        elif show_menu:
            if char == curses.KEY_UP and menu_selection > 0:
                menu_selection -= 1
                screen_dirty = True
            elif char == curses.KEY_DOWN and menu_selection < 3:
                menu_selection += 1
                screen_dirty = True
            elif char == 10:
                if menu_selection == 0:
                    show_menu = False
                elif menu_selection == 1:
                    forms_management_screen(stdscr)
                elif menu_selection == 2:
                    cms_management_screen(stdscr)
                elif menu_selection == 3:
                    stop_event.set()
                    kiss_socket.close()
                    break
                screen_dirty = True
            elif char == 27:
                show_menu = False
                screen_dirty = True
        if not show_menu or menu_selection != 1:
            while not packet_queue.empty():
                try:
                    callsign, packet, last_data_time = packet_queue.get_nowait()
                    header, payload = packet.split(':', 1)
                    parts = payload.split('|', 3)
                    if len(parts) != 4:
                        continue
                    function, _, form_id, payload_content = parts
                    if function == 'I':
                        if ':' in payload_content[:5]:
                            seq, total = map(int, payload_content.split('|', 1)[0].split(':'))
                            payload_content = payload_content.split('|', 1)[1]
                            key = callsign + ":" + form_id
                            segments.setdefault(key, {})[seq] = payload_content
                            if len(segments[key]) == total:
                                full_payload = ''.join(segments[key][i] for i in sorted(segments[key]))
                                csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                                os.makedirs(DATA_DIR, exist_ok=True)
                                with open(csv_path, 'a') as f:
                                    f.write(f"{int(time.time())},{callsign},{full_payload}\n")
                                response = f"A|{CALLSIGN}|{form_id}|SUCCESS"
                                ax25_packets = build_ax25_packet(CALLSIGN, callsign, response)
                                for ax25_packet in ax25_packets:
                                    kiss_frame = build_kiss_packet(ax25_packet)
                                    kiss_socket.send(kiss_frame)
                                    log_comms(f"0{CALLSIGN}>{callsign}:{response}")
                                del segments[key]
                        else:
                            csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                            os.makedirs(DATA_DIR, exist_ok=True)
                            with open(csv_path, 'a') as f:
                                f.write(f"{int(time.time())},{callsign},{payload_content}\n")
                            response = f"A|{CALLSIGN}|{form_id}|SUCCESS"
                            ax25_packets = build_ax25_packet(CALLSIGN, callsign, response)
                            for ax25_packet in ax25_packets:
                                kiss_frame = build_kiss_packet(ax25_packet)
                                kiss_socket.send(kiss_frame)
                                log_comms(f"0{CALLSIGN}>{callsign}:{response}")
                    elif function == 'S':
                        search_fields = {}
                        for pair in payload_content.split('|'):
                            if not pair:
                                continue
                            key = pair[:2]
                            value = pair[2:] if len(pair) > 2 else ""
                            search_fields[key] = value
                        csv_path = os.path.join(DATA_DIR, form_id + "_submissions.csv")
                        matches = []
                        if os.path.exists(csv_path):
                            with open(csv_path, 'r') as f:
                                for line in f:
                                    _, _, row_payload = line.strip().split(',', 2)
                                    fields = {}
                                    for field in row_payload.split('|'):
                                        if field:
                                            fields[field[:2]] = field[2:] if len(field) > 2 else ""
                                    match = all(fields.get(k, '') == v for k, v in search_fields.items() if v)
                                    if match:
                                        matches.append(row_payload)
                        response = f"R|{CALLSIGN}|{form_id}|{'~'.join(matches)}"
                        ax25_packets = build_ax25_packet(CALLSIGN, callsign, response)
                        for ax25_packet in ax25_packets:
                            kiss_frame = build_kiss_packet(ax25_packet)
                            kiss_socket.send(kiss_frame)
                            log_comms(f"0{CALLSIGN}>{callsign}:{response}")
                    elif function == 'X':
                        if form_id == "PUSH" and CMS_SYNC_ENABLED:
                            syncing_clients.add(callsign)
                            try:
                                client_push = {}
                                for pair in payload_content.split('|'):
                                    if ':' in pair:
                                        fname, fhash = pair.split(':', 1)
                                        client_push[fname] = fhash
                                push_index_path = CMS_DIR / 'push_index.json'
                                try:
                                    with open(push_index_path, 'r') as f:
                                        server_push = json.load(f)['push']
                                except FileNotFoundError:
                                    server_push = {}
                                now = time.time()
                                for fname, data in server_push.items():
                                    if now - data['mtime'] > CMS_SYNC_MAX_AGE:
                                        continue
                                    if fname not in client_push or client_push[fname] != data['md5']:
                                        with open(CMS_PUSH_DIR / fname, 'r') as f:
                                            content = f.read().strip()
                                        response = f"U|{CALLSIGN}|{fname}|{content.replace('\n', '~')}"
                                        ax25_packets = build_ax25_packet(CALLSIGN, "ALL", response, compress=True)
                                        for ax25_packet in ax25_packets:
                                            kiss_frame = build_kiss_packet(ax25_packet)
                                            kiss_socket.send(kiss_frame)
                                            log_comms(f"0{CALLSIGN}>ALL:{response}")
                                for fname in client_push:
                                    if fname not in server_push or (now - server_push.get(fname, {}).get('mtime', 0) > CMS_SYNC_MAX_AGE):
                                        response = f"D|{CALLSIGN}|{fname}|"
                                        ax25_packets = build_ax25_packet(CALLSIGN, "ALL", response)
                                        for ax25_packet in ax25_packets:
                                            kiss_frame = build_kiss_packet(ax25_packet)
                                            kiss_socket.send(kiss_frame)
                                            log_comms(f"0{CALLSIGN}>ALL:{response}")
                            finally:
                                syncing_clients.remove(callsign)
                        else:
                            syncing_clients.add(callsign)
                            try:
                                client_forms = {}
                                for pair in payload_content.split('|'):
                                    if ':' in pair:
                                        fname, fhash = pair.split(':', 1)
                                        client_forms[fname] = fhash
                                forms_index_path = os.path.join(FORMS_DIR, 'forms_index.json')
                                try:
                                    with open(forms_index_path, 'r') as f:
                                        server_forms = json.load(f)['forms']
                                except FileNotFoundError:
                                    server_forms = {}
                                for fname, server_hash in server_forms.items():
                                    if fname not in client_forms or client_forms[fname] != server_hash:
                                        with open(os.path.join(FORMS_DIR, fname + ".txt"), 'r') as f:
                                            content = f.read().strip()
                                        response = f"U|{CALLSIGN}|{fname}|{content.replace('\n', '~')}"
                                        ax25_packets = build_ax25_packet(CALLSIGN, "ALL", response, compress=True)
                                        for ax25_packet in ax25_packets:
                                            kiss_frame = build_kiss_packet(ax25_packet)
                                            kiss_socket.send(kiss_frame)
                                            log_comms(f"0{CALLSIGN}>ALL:{response}")
                                for fname in client_forms:
                                    if fname not in server_forms:
                                        response = f"D|{CALLSIGN}|{fname}|"
                                        ax25_packets = build_ax25_packet(CALLSIGN, "ALL", response)
                                        for ax25_packet in ax25_packets:
                                            kiss_frame = build_kiss_packet(ax25_packet)
                                            kiss_socket.send(kiss_frame)
                                            log_comms(f"0{CALLSIGN}>ALL:{response}")
                            finally:
                                syncing_clients.remove(callsign)
                    elif function == 'L':
                        response = list_cms_content(form_id)
                        ax25_packets = build_ax25_packet(CALLSIGN, callsign, response)
                        for ax25_packet in ax25_packets:
                            kiss_frame = build_kiss_packet(ax25_packet)
                            kiss_socket.send(kiss_frame)
                            log_comms(f"0{CALLSIGN}>{callsign}:{response}")
                    elif function == 'G':
                        responses = get_cms_content(form_id, payload_content)
                        for response in responses:
                            ax25_packets = build_ax25_packet(CALLSIGN, callsign, response, compress=True)
                            for ax25_packet in ax25_packets:
                                kiss_frame = build_kiss_packet(ax25_packet)
                                kiss_socket.send(kiss_frame)
                                log_comms(f"0{CALLSIGN}>{callsign}:{response}")
                    elif function == 'P':
                        category, item_id, rest = payload_content.split('|', 2)
                        content = rest
                        max_age = None
                        if '|' in rest:
                            content, max_age = rest.rsplit('|', 1)
                            max_age = max_age if max_age.isdigit() else None
                        response = post_cms_content(category, item_id, content, max_age)
                        ax25_packets = build_ax25_packet(CALLSIGN, callsign, response)
                        for ax25_packet in ax25_packets:
                            kiss_frame = build_kiss_packet(ax25_packet)
                            kiss_socket.send(kiss_frame)
                            log_comms(f"0{CALLSIGN}>{callsign}:{response}")
                    packet_queue.task_done()
                except queue.Empty:
                    break
        time.sleep(0.05)

backup_script()

if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except Exception as e:
        with open(LOG_FILE, 'a') as f:
            f.write(str(datetime.now()) + " - Fatal error: " + str(e) + " - traceback: " + traceback.format_exc() + "\n")
        sys.exit(1)